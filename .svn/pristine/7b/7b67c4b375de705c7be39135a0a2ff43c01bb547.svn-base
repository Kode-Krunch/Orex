import React, { useEffect, useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { useLocation } from 'react-router-dom';
import { getPlaylistSummaryData } from './utils';
import StatisticCardwithfigure from 'components/common/StatisticCardwithfigure';
import {
  convertDateFormatyyyyMMdd,
  formatDateToDDMMMYYYY,
  openNotification,
} from 'views/Controls/GLOBALFUNACTION';
import { Card } from 'components/ui';
import Loader from 'views/Controls/Loader';
import { hideStackedSideNav_secondary } from 'views/Scheduling/general';
import { apiCallstoreprocedure } from 'services/CommonService';
import ReportsTable from 'views/Controls/ReportsTable/ReportsTable';
const TooblbarOption = { groupBy: false, manageColumns: false };
const CARD_FLAGS = {
  booked: 1,
  dropped: 2,
  songs: 3,
  promos: 4,
  ntc: 5,
  logged: 6,
  telecasted: 7,
  extra: 8

};

const prettifyHeader = (key) =>
  key
    .replace(/([A-Z])/g, ' $1')
    .replace(/_/g, ' ')
    .replace(/^./, (s) => s.toUpperCase());

const generateColumnsFromData = (data) => {
  if (!data || data.length === 0) return [];
  return Object.keys(data[0]).map((key) => ({
    header: prettifyHeader(key),
    accessorKey: key,
    // cell function matches the pattern used by your ReportsTable internals
    cell: (info) => {
      // info is the cell context from TanStack/React-Table style tables used in ReportsTable
      const value = typeof info?.getValue === 'function' ? info.getValue() : info;
      if (value == null) return '';
      if (key.toLowerCase().includes('date')) {
        const d = new Date(value);
        if (!isNaN(d)) return d.toISOString().split('T')[0];
      }
      return value;
    },
  }));
};

function CloudPlayout() {
  const apiCallInProgress = React.useRef(false);
  const channel = useSelector((state) => state.locale.selectedChannel);
  const location = useLocation();
  hideStackedSideNav_secondary();
  const CreditNoteColumns = useMemo(() => {
    return [
      { header: 'Agency Name', accessorKey: 'AgencyName' },
      { header: 'Address Line1', accessorKey: 'AddressLine1' },
      { header: 'Payable Amount', accessorKey: 'PayableAmount' },
      { header: 'Client', accessorKey: 'ClientName' },
      { header: 'Amount', accessorKey: 'Amount' },
      { header: 'Ref Date', accessorKey: 'RefDate' },
      { header: 'Invoice Date', accessorKey: 'InvoiceDate' },
      { header: 'GSTN Id', accessorKey: 'GSTN_id' },
      { header: 'Brand', accessorKey: 'BrandName' },
      { header: 'Booking Ref', accessorKey: 'BookingRefNumber' },
    ];
  }, []);
  const [date, setDate] = useState(null);
  const [playlistSummary, setPlaylistSummary] = useState([]);
  const [showLoader, setShowLoader] = useState(false);
  const [curTable, setCurTable] = useState(null);


  // Table states for ReportsTable
  const [tableData, setTableData] = useState([]);

  const [managedColumns, setManagedColumns] = useState([]);
  const [tableTitle, setTableTitle] = useState("");

  const originalColumns = useMemo(() => {
    if (tableData.length > 0) {
      return generateColumnsFromData(tableData);
    }
    return [];
  }, [tableData]);

  useEffect(() => {
    (async () => {
      try {
        if (location?.state?.date) {
          setShowLoader(true);
          setDate(location.state.date);
          const summary = await getPlaylistSummaryData(
            channel,
            convertDateFormatyyyyMMdd(location.state.date)
          );
          setPlaylistSummary(summary || []);
          setShowLoader(false);
        }
      } catch (error) {
        openNotification(
          'danger',
          'Something went wrong while retrieving Playlist Summary'
        );
        setShowLoader(false);
        console.error(error);
      }
    })();
  }, []);



  const getPlaylistDetailsByFlag = async (flag) => {
    if (apiCallInProgress.current) return; // block if already fetching
    apiCallInProgress.current = true;

    try {
      setShowLoader(true);
      // set table title based on flag
      const titles = {
        1: "Booked Spots Details",
        2: "Missed Spots Details",
        3: "Songs Details",
        4: "Promo Details",
        5: "NTC Details",
        6: "Logged Details",
        7: "Telecasted Details",
        8: "Extra Details"
      };
      setTableTitle(titles[flag] || "Playlist Details");

      const response = await apiCallstoreprocedure('USP_PlaylistSummary_Showdata', {
        par_LocationCode: channel.LocationCode,
        par_ChannelCode: channel.ChannelCode,
        par_TelecastDate: convertDateFormatyyyyMMdd(date),
        Flag: flag,
      });

      const dataArray = Array.isArray(response)
        ? response
        : Array.isArray(response?.data)
          ? response.data
          : [];

      setTableData(dataArray);

      if (dataArray.length > 0) {
        const generated = generateColumnsFromData(dataArray);

        setManagedColumns(generated.slice());
      } else {

        setManagedColumns([]);
      }
      setCurTable(flag ? `Flag: ${flag}` : 'Details');
    } catch (error) {
      openNotification('danger', 'Error fetching playlist details');
      console.error(error);
    } finally {
      setShowLoader(false);
      apiCallInProgress.current = false;
    }
  };

  return (
    <>
      <div className="flex justify-between items-center">
        <h3 className="mb-4">Cloud Playout</h3>
        <h4>{formatDateToDDMMMYYYY(date)}</h4>
      </div>

      <div className="flex gap-2 mb-4">
        <Card bodyClass="p-2 grid grid-cols-8 gap-2" bordered={false}>
          {playlistSummary.map((summary, index) => {
            let flag = null;
            switch (summary.title) {
              case 'Booked Spots':
                flag = CARD_FLAGS.booked;
                break;
              case 'Missed Spots':
                flag = CARD_FLAGS.dropped;
                break;
              case 'Total Songs':
                flag = CARD_FLAGS.songs;
                break;
              case 'Total Promos':
                flag = CARD_FLAGS.promos;
                break;
              case 'Total NTC':
                flag = CARD_FLAGS.ntc;
                break;
              case 'Logged Spots':
                flag = CARD_FLAGS.logged;
                break;
              case 'Telecasted Spots':
                flag = CARD_FLAGS.telecasted;
                break;
              case 'Extra Spots':
                flag = CARD_FLAGS.extra;
                break;
              default:
                flag = null;
            }
            return (
              <div
                key={index}
                onClick={() => {
                  if (flag) {
                    setCurTable(summary.title);
                    console.log(flag);
                    getPlaylistDetailsByFlag(flag);
                  }
                }}
                role="button"
                tabIndex={0}

              >
                <StatisticCardwithfigure
                  CardHeight={200}
                  AnimateColorClass={summary.iconBorderColor}
                  Icon={summary.icon}
                  CardName={summary.title}
                  CardNote={summary.description}
                  CardFigure={summary.count}
                  COLOR={summary.color}
                  cursor={true}
                />
              </div>
            );
          })}
        </Card>
        {/* <Card bodyClass="p-2 grid grid-cols-2 gap-2" bordered={false}>
          <div onClick={() => setCurTable('droppedSpots')}>
            <StatisticCardwithfigure
              key="droppedSpots"
              CardHeight={200}
              AnimateColorClass={'order1'}
              Icon={
                <CgPlayListRemove style={{ fontSize: 35, color: '#F55C52' }} />
              }
              CardName={'Dropped Spots'}
              CardNote={
                'Dropped Spots are advertisement slots that were removed or Not Telecasted from the Playlist.'
              }
              CardFigure={
                convertDateFormatyyyyMMdd(date) <
                  convertDateFormatyyyyMMdd(new Date())
                  ? DROPPED_SPOTS.length
                  : 0
              }
              COLOR={'#F55C52'}
              BackgroundColor="rgb(127 29 29 / 33%)" cursor={true}
            />
          </div>
          <div onClick={() => setCurTable('extraSpots')}>
            <StatisticCardwithfigure
              CardHeight={200}
              AnimateColorClass="order3"
              Icon={<LuListEnd style={{ fontSize: 35, color: '#6ee7b7' }} />}
              CardName="Extra spots on Aired"
              CardNote="Extra Telecasted Spots are additional advertisement slots aired beyond the originally scheduled spots."
              CardFigure={
                convertDateFormatyyyyMMdd(date) <
                  convertDateFormatyyyyMMdd(new Date())
                  ? EXTRA_TELECASTED_SPOTS.length
                  : 0
              }
              COLOR="#6ee7b7"
              BackgroundColor="rgb(6 78 59 / 47%)" cursor={true}
            />
          </div>
        </Card> */}
      </div>

      {/* Render ReportsTable only when we have data and columns */}
      {tableData?.length > 0 && originalColumns?.length > 0 ? (
        <>
          <h5 className="mb-2">{tableTitle}</h5>
          <ReportsTable
            tableData={tableData}
            tableName="PlaylistSummary" // can be any identifier you want
            originalColumns={originalColumns}
            managedColumns={managedColumns}
            setManagedColumns={setManagedColumns}
            exportFileName="Playlist_Summary"
            toolbarOptions={TooblbarOption}
          />
        </>
      ) : (
        // optional: show a message if user clicked but there is no data
        curTable && <div className="p-4">No data to show for {tableTitle}</div>
      )}
      {/* {curTable === 'extraSpots' ? (
        <ExtraTeleastedSpotsTable date={date} />
      ) : (
        <DroppedSpotsTable date={date} />
      )} */}
      <Loader showLoader={showLoader} />
    </>
  );
}

export default CloudPlayout;
