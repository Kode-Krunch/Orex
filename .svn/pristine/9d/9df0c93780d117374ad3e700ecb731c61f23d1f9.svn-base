import {
  FormItemcompact,
  Switcher,
  Input,
  FormContainer,
  Select,
} from 'components/ui';
import { Field, Form, Formik } from 'formik';
import * as Yup from 'yup';
import { PostForm, PutForm, dropmodulewise } from 'services/MasterService';
import { useSelector } from 'react-redux';
import React, { forwardRef, useState } from 'react';
import { useEffect } from 'react';
import { openNotification } from 'views/Controls/GLOBALFUNACTION';

const validationSchema = Yup.object().shape({
  FormName: Yup.string()
    .min(1, 'Too Short!')
    .max(50, 'Too Long!')
    .required(' Required'),
  ModuleCode: Yup.string()
    .min(1, 'Too Short!')
    .max(50, 'Too Long!')
    .required(' Required'),
  SubModuleCode: Yup.string()
    .min(1, 'Too Short!')
    .max(50, 'Too Long!')
    .required(' Required'),
  IndexNum: Yup.string()
    .min(1, 'Too Short!')
    .max(50, 'Too Long!')
    //.matches(/^[0-2]+$/, 'Must be only digits')
    .required(' Required'),
  WinFormName: Yup.string()
    .min(1, 'Too Short!')
    .max(500, 'Too Long!')
    .required(' Required'),
  // FormImage: Yup.string()
  //     .min(1, 'Too Short!')
  //     .max(50, 'Too Long!')
  //     .required('FormImage Required'),
  // IS_MO: Yup.number()
  //     .min(1, 'Too Short!')
  //     .max(50, 'Too Long!')
  //     .required('IS_MO Required'),
  IsActive: Yup.string().required('IsActives Required'),
  rememberMe: Yup.bool(),
});
const options = [
  { value: 'foo', label: 'Foo' },
  { value: 'bar', label: 'Bar' },
];

const FormEdit = forwardRef((props, ref) => {
  const { onDrawerClose, editData, setMessage, setlog, Module } = props;
  const [SubModule, setSubModule] = useState([]);
  const token = useSelector((state) => state.auth.session.token);
  //console.log(Module)

  useEffect(() => {
    if (editData.ModuleCode) {
      dropsub(editData.ModuleCode);
    }
  }, []);

  const dropsub = async (values) => {
    const SubModule = await dropmodulewise(values);
    const formattedOptions2 = SubModule.data.map((option) => ({
      value: option.SubModuleCode,
      label: option.SubModuleName,
    }));
    setSubModule(formattedOptions2);
  };

  const AddForm = async (values, token) => {
    try {
      const resp = await PostForm(values, token);

      if (resp.status == 200) {
        openNotification('success', 'Data Inserted Successfully.');
        return;
      }
      if (resp.status == 204) {
        openNotification('info', 'Data Already Exists.');
        return;
      }
    } catch (errors) {
      if (errors.response.status == 500) {
        openNotification('danger', 'Server Error.');
        return;
      }
    }
  };
  const EditForm = async (values, token) => {
    try {
      const resp = await PutForm(values, token);
      if (resp.status == 200) {
        openNotification('success', 'Data Updated Successfully');
        return;
      }
      if (resp.status == 204) {
        openNotification('info', 'Data already Exists');
        return;
      }
    } catch (errors) {
      if (errors.response.status == 500) {
        openNotification('danger', 'Server Error.');
        return;
      }
    }
  };
  const LoginId = useSelector((state) => state.auth.session.LoginId);
  return (
    <div>
      <Formik
        innerRef={ref}
        initialValues={{
          FormCode: editData.FormCode || '',
          FormName: editData.FormName || '',
          ModuleCode: editData.ModuleCode || '',
          SubModuleCode: editData.SubModuleCode || '',
          IndexNum: editData.IndexNum || '',
          WinFormName: editData.WinFormName || '',
          FormImage: editData.FormImage || '',
          IS_MO: editData.IS_MO || '',

          IsActive: editData.IsActive === 1 ? true : false,
        }}
        validationSchema={validationSchema}
        onSubmit={(values, { resetForm, setSubmitting }) => {
          setTimeout(() => {
            if (!editData.FormCode) {
              new Promise((resolve, reject) => {
                AddForm(values, token)
                  .then((response) => {
                    onDrawerClose(0, 0);
                    resolve(response);
                  })
                  .catch((errors) => {
                    reject(errors);
                  });
              });
            } else {
              new Promise((resolve, reject) => {
                setSubmitting(false);
                EditForm(values, token)
                  .then((response) => {
                    onDrawerClose(0, 0);
                    resolve(response);
                  })
                  .catch((errors) => {
                    reject(errors);
                  });
              });
            }

            resetForm();
          }, 400);
        }}
      >
        {({ values, touched, errors, setFieldValue }) => (
          <Form>
            <FormContainer>
              <Field
                size="sm"
                type="FormCode"
                autoComplete="off"
                name="FormCode"
                placeholder="FormCode name"
                component={Input}
                hidden
              />
              <div className="flex flex-wrap">
                <div style={{ width: '50%' }} className="px-1">
                  <FormItemcompact
                    asterisk
                    label="Screen Name"
                    invalid={errors.FormName && touched.FormName}
                    errorMessage={errors.FormName}
                  >
                    <Field name="FormName">
                      {({ field, form }) => (
                        <Input
                          type="text"
                          placeholder="Screen Name"
                          maxlength="30"
                          size="sm"
                          value={values.FormName}
                          name="FormName"
                          onChange={(e) => {
                            const newValue = e.target.value;

                            if (/^[a-zA-Z ]+$/.test(newValue)) {
                              form.setFieldValue(field.name, newValue);
                            }
                            if (newValue == '') {
                              form.setFieldValue(field.name, '');
                            }
                          }}
                        />
                      )}
                    </Field>
                  </FormItemcompact>
                </div>
                <div style={{ width: '50%' }} className="px-1">
                  <FormItemcompact
                    asterisk
                    label="Module Name"
                    invalid={errors.ModuleCode && touched.ModuleCode}
                    errorMessage={errors.ModuleCode}
                  >
                    <Field name="ModuleCode">
                      {({ field, form }) => (
                        <Select
                          size="sm"
                          field={field}
                          form={form}
                          options={Module}
                          value={Module.filter(
                            (option) => option.value === values.ModuleCode,
                          )}
                          onChange={(option) => {
                            form.setFieldValue(field.name, option?.value);
                            dropsub(option?.value);
                          }}
                        />
                      )}
                    </Field>
                  </FormItemcompact>
                </div>
                <div style={{ width: '50%' }} className="px-1">
                  <FormItemcompact
                    asterisk
                    label="SubModule Name"
                    invalid={errors.SubModuleCode && touched.SubModuleCode}
                    errorMessage={errors.SubModuleCode}
                    style={{ width: '250px' }}
                  >
                    <Field
                      size="sm"
                      name="SubModuleCode"
                      style={{ width: '250px' }}
                    >
                      {({ field, form }) => (
                        <Select
                          style={{ width: '250px' }}
                          field={field}
                          form={form}
                          className=" w-50"
                          options={SubModule}
                          value={SubModule.filter(
                            (option) => option.value === values.SubModuleCode,
                          )}
                          onChange={(option) =>
                            form.setFieldValue(field.name, option?.value)
                          }
                        />
                      )}
                    </Field>
                  </FormItemcompact>
                </div>

                <div style={{ width: '50%' }} className="px-1">
                  <FormItemcompact
                    asterisk
                    label="Index Number"
                    invalid={errors.IndexNum && touched.IndexNum}
                    errorMessage={errors.IndexNum}
                  >
                    <Field name="IndexNum">
                      {({ field, form }) => (
                        <Input
                          type="text"
                          placeholder="Index Number"
                          maxlength="4"
                          size="sm"
                          value={values.IndexNum}
                          name="IndexNum"
                          onChange={(e) => {
                            const newValue = e.target.value;

                            if (/^[0-9]*$/.test(newValue)) {
                              form.setFieldValue(field.name, newValue);
                            }
                            if (newValue == '') {
                              form.setFieldValue(field.name, '');
                            }
                          }}
                        />
                      )}
                    </Field>
                  </FormItemcompact>
                </div>
                <div style={{ width: '100%' }} className="px-1">
                  <FormItemcompact
                    asterisk
                    label="Route Path"
                    invalid={errors.WinFormName && touched.WinFormName}
                    errorMessage={errors.WinFormName}
                  >
                    <Field
                      size="sm"
                      type="WinFormName"
                      autoComplete="off"
                      name="WinFormName"
                      // disabled={LoginId == 1 || !editData.FormCode || LoginId == 4 ? false : true}
                      placeholder="WinFormName"
                      component={Input}
                      value={values.WinFormName}
                      onChange={(e) => {
                        const newValue = e.target.value;
                        if (/^[a-zA-Z]*$/.test(newValue)) {
                          setFieldValue('WinFormName', newValue);
                        }
                        if (newValue == '') {
                          setFieldValue('WinFormName', '');
                        }
                      }}
                    />
                  </FormItemcompact>
                </div>
                {/* <FormItemcompact
                                    label="FormImage"
                                    invalid={
                                        errors.FormImage && touched.FormImage
                                    }
                                    errorMessage={errors.FormImage}
                                >
                                    <Field size="sm"
                                        type="FormImage"
                                        autoComplete="off"
                                        name="FormImage"
                                        placeholder="FormImage"
                                        component={Input}
                                    />
                                </FormItemcompact> */}

                {/* <FormItemcompact
                                    label="IS_MO"
                                    invalid={errors.IS_MO && touched.IS_MO}
                                    errorMessage={errors.IS_MO}
                                >
                                    <Field size="sm"
                                        type="Number"
                                        autoComplete="off"
                                        name="IS_MO"
                                        placeholder="IS_MO"
                                        component={Input}
                                    />
                                </FormItemcompact> */}
              </div>
              <FormItemcompact
                label="Status"
                invalid={errors.IsActive && touched.IsActive}
                errorMessage={errors.IsActive}
              >
                <div>
                  <Field size="sm" name="IsActive" component={Switcher} />
                </div>
              </FormItemcompact>
              {/* <FormItemcompact>
                                <Button variant="solid" type="submit">
                                    Submit
                                </Button>
                            </FormItemcompact> */}
            </FormContainer>
          </Form>
        )}
      </Formik>
    </div>
  );
});

export default FormEdit;
