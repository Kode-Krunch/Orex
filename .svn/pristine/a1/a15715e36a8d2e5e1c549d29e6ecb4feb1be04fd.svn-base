import React, { useRef, useState } from 'react';
import SchedulerContext from './SchedulerContext';
import { DEFAULT_SEC_TABLE_TOOLBAR_STATE, SCTE_ROWS } from '../constants';
import {
  finalizeData,
  getCustomCellColorFromTable,
  getDefaultActiveFeatures,
  getDroppedSpots,
  getFeaturesList,
  getFilteredTableData,
  getLastMinuteSpots,
  getNTCParentRow,
  getProgramWithSegmentContent,
  getRowWithNTC,
  getSchedulingTableData,
  getSegmentWiseContent,
  getTableDataWithAdditionalInfo,
  getTableScrolledOffset,
  isAnyNTCPaid,
  isBasicDragInvalid,
  isCommercialInsertValid,
  isDragValidForSourceRow,
  isNTCInsertValid,
  isRowBetweenValidTime,
  isRowDataTypePresentInDraggedRows,
  isSegmentValid,
  removeAdditionalInfoFromRows,
  removeRowsFromTableData,
  updateOffsetStartTime,
  updateProgramInSchedulingTableData,
} from './utils';
import {
  convertDateToHHMMSSFF,
  formatDurationHHMMSSFF,
  getUniqueObjects,
  isJSONArrayEqual,
  openNotification,
  subtractTimes,
  timeToSeconds,
} from 'views/Controls/GLOBALFUNACTION';
import {
  additionalRowInfoEnum,
  bulkInsertPositionEnum,
  droppableIdsEnum,
  featuresEnum,
  ntcDescriptionTypesEnum,
  ntcDurationTypesEnum,
  operationTypesEnum,
  pagesEnum,
  rowDataTypesEnum,
  secondaryTableTypesEnum,
  tableFilterOptionsEnum,
  tableTypesEnum,
} from '../enum';
import { addTimes } from '../components/SchedulingArea/components/Summary/utils';
import { updateStartTimes } from 'views/Scheduling/general';
import {
  getDummyRow,
  getColumnsState,
  getProgramSchedule,
} from '../components/SchedulingArea/utils/utils';
import { useSelector } from 'react-redux';
import { convertDateToYMD } from 'components/validators';
import { CLIENT } from 'views/Controls/clientListEnum';
import { getPromosFromTemplateId, insertPromos } from '../components/SchedulingArea/components/Toolbar/components/AutoShuffleDialog/utils';

const SchedulerContextProvider = ({ children }) => {
  /* REDUX */
  const channel = useSelector((state) => state.locale.selectedChannel);
  const token = useSelector((state) => state.auth.session.token);

  /* STATES */
  const [page, setPage] = useState(null);
  const [date, setDate] = useState(null);
  const [featuresList, setFeaturesList] = useState(null);
  const [activeFeatures, setActiveFeatures] = useState(null);
  /* UNSAVED WORK STATES */
  const [loadUnsavedWork, setLoadUnsavedWork] = useState(false);
  const [unsavedWorkState, setUnsavedWorkState] = useState(null);
  const [updateSchedulerStateInRedux, setUpdateSchedulerStateInRedux] =
    useState(false);
  /* SCHEDULING TABLE STATES */
  const [schedulingTableName, setSchedulingTableName] = useState(null);
  const [schedulingTableData, setSchedulingTableData] = useState([]);
  const [schedulingTableOffset, setSchedulingTableOffset] = useState(0);
  const [schedulingTableManagedColumns, setSchedulingTableManagedColumns] =
    useState({
      originalColumns: [],
      visibleColumns: [],
      removedColumns: [],
    });
  const [schedulingTableSelectedRows, setSchedulingTableSelectedRows] =
    useState([]);
  const [leftClickedSchTableRow, setLeftClickedSchTableRow] = useState(null);
  const [schTableSelectedFilters, setSchTableSelectedFilters] = useState([]);
  /* SECONDARY TABLE STATES */
  const [secondaryTableName, setSecondaryTableName] = useState(null);
  const [secondaryTableType, setSecondaryTableType] = useState(null);
  const [secondaryTableData, setSecondaryTableData] = useState([]);
  const [secondaryTableOffset, setSecondaryTableOffset] = useState(0);
  const [secondaryTableManagedColumns, setSecondaryTableManagedColumns] =
    useState({
      originalColumns: [],
      visibleColumns: [],
      removedColumns: [],
    });
  const [secTableToolbarState, setSecTableToolbarState] = useState(
    DEFAULT_SEC_TABLE_TOOLBAR_STATE,
  );
  const [secondaryTableSelectedRows, setSecondaryTableSelectedRows] = useState(
    [],
  );
  const [leftClickedSecTableRow, setLeftClickedSecTableRow] = useState(null);
  const [secTableSelectedFilters, setSecTableSelectedFilters] = useState([]);
  /* DROP BUCKET STATE */
  const [dropBucket, setDropBucket] = useState([]);
  /* LAST MINUTE SPOTS STATE */
  const [lastMinuteSpots, setLastMinuteSpots] = useState([]);
  /* UNDO/REDO */
  const [undoStack, setUndoStack] = useState([]);
  const [redoStack, setRedoStack] = useState([]);
  /* ROTATION INFO */
  const [rotationInfoTableSelectedRows, setRotationInfoTableSelectedRows] =
    useState([]);

  /* UI STATES */
  const [startTime, setStartTime] = useState('');
  const [showLoader, setShowLoader] = useState(false);
  const [customCellColor, setCustomCellColor] = useState(null);
  const [isScheduleAllowedToEdit, setIsScheduleAllowedToEdit] = useState(null);

  /* SELECTOR OPTIONS */
  const [promoTypeOptions, setPromoTypeOptions] = useState([]);
  const [songTypeOptions, setSongTypeOptions] = useState([]);
  const [ntcTypeOptions, setNtcTypeOptions] = useState([]);

  /* REFS */
  const schedulingTableRef = useRef(null);
  const secondaryTableRef = useRef(null);
  const secondaryAreaZindexRef = useRef({
    [featuresEnum.ROTATION_INFO]: 10,
    [featuresEnum.HOURWISE_INVENTORY]: 10,
    [featuresEnum.SUMMARY]: 10,
    [featuresEnum.RULE_CHECK]: 10,
    [featuresEnum.DURATION]: 10,
  });

  /* CONSTANTS */
  const isChannelForbes = channel.label === CLIENT.USA_Forbes;

  /* MOST IMPORTANT FUNCTIONS */
  async function executeOperation({
    operation,
    dragInfo,
    insertPosition,
    time,
    selectedBreaks,
    selectedRowsToDelete,
    selectedRowsToDrop,
    clickedProgram,
    clickedProgramSchedule,
    newProgramSchedule,
    startTimeValue,
    tableType,
    selectedFilters,
    externalActiveFeatures,
    isHideCommercial,
    isShowProgramBaseTime,
    isShowNTC,
    isFirstLoad = false,
    isLoadUnsavedWork = false,
    isGenerateLog = false,
    customCellColorParam,
    mode = 'Add',
    descriptionType,
    bulkNTCInsDesc,
    durationType,
    bulkNTCInsDuration,
    bulkNTCInsOffsetTime,
    isShowSCTE,
    promoShuffleTemplate
  }) {
    try {
      let operationResult;
      let newStartTime = startTime;
      let newCustomCellColor =
        operation === operationTypesEnum.RESET_CELL_COLOR
          ? null
          : customCellColorParam
            ? customCellColorParam
            : customCellColor;
      /* ADD NEW OPERATIONS HERE, AND GET UPDATED SCHEDULING, SECONDARY AND DROP BUCKET TABLE DATA */
      if (operation === operationTypesEnum.INITIALIZE_SCHEDULER) {
        operationResult = await executeInitializeScheduler(
          isFirstLoad,
          isLoadUnsavedWork,
          isGenerateLog,
          mode,
          operation,
        );
        newStartTime = operationResult.newStartTime;
      } else if (operation === operationTypesEnum.DRAG_ROW) {
        operationResult = executeDragRow(dragInfo);
      } else if (operation === operationTypesEnum.INSERT_ROW) {
        operationResult = executeInsertRow();
      } else if (operation === operationTypesEnum.BULK_INSERT_ROW) {
        operationResult = executeBulkInsert({
          insertPosition,
          time,
          selectedBreaks,
          selectedRows: secondaryTableSelectedRows.map((row) => ({
            ...row,
            VideoID: row.HouseID,
          })),
          descriptionType,
          bulkNTCInsDesc,
          durationType,
          bulkNTCInsDuration,
          bulkNTCInsOffsetTime,
        });
      } else if (operation === operationTypesEnum.SHOW_SCTE) {
        operationResult = executeSCTEInsert(isShowSCTE);
      } else if (operation === operationTypesEnum.REPLACE_ROW) {
        operationResult = executeReplaceRow();
      } else if (operation === operationTypesEnum.REPLACE_ALL_ROW) {
        operationResult = executeReplaceAllRow();
      } else if (operation === operationTypesEnum.DELETE_ROW) {
        operationResult = executeDeleteRow(selectedRowsToDelete);
      } else if (operation === operationTypesEnum.DROP_ROW) {
        operationResult = executeDropRow(selectedRowsToDrop);
      } else if (operation === operationTypesEnum.REPLACE_PROGRAM) {
        operationResult = executeReplaceProgram(
          clickedProgram,
          clickedProgramSchedule,
          newProgramSchedule,
        );
      } else if (operation === operationTypesEnum.MANAGE_START_TIME) {
        newStartTime = startTimeValue;
      } else if (operation === operationTypesEnum.FILTER_ROW) {
        operationResult = executeFilterRow(tableType, selectedFilters);
      } else if (operation === operationTypesEnum.HIDE_COMMERCIAL) {
        operationResult = executeHideCommercial(isHideCommercial, newStartTime);
      } else if (operation === operationTypesEnum.SHOW_PROGRAM_BASE_TIME) {
        operationResult = executeShowProgramBaseTime(
          isShowProgramBaseTime,
          newStartTime,
        );
      } else if (operation === operationTypesEnum.SHOW_NTC) {
        operationResult = executeShowNTC(isShowNTC);
      } else if (operation === operationTypesEnum.INSERT_NTC_BY_START_TIME) {
        operationResult = executeInsertNTCByStartTime();
      } else if (operation === operationTypesEnum.PROMO_AUTO_SHUFFLE) {
        operationResult = await executePromoAutoShuffle(promoShuffleTemplate, time);
      }
      /* EXTRACT NEW DATAs FROM RESULT */
      let newSchedulingTableData = operationResult?.newSchedulingTableData
        ? operationResult.newSchedulingTableData
        : [...schedulingTableData];
      let newSecondaryTableData = operationResult?.newSecondaryTableData
        ? operationResult.newSecondaryTableData
        : [...secondaryTableData];
      let newDropBucket = operationResult?.newDropBucket
        ? operationResult.newDropBucket
        : [...dropBucket];
      let newLastMinuteSpots = operationResult?.newLastMinuteSpots
        ? operationResult.newLastMinuteSpots
        : [...lastMinuteSpots];
      let newActiveFeatures = operationResult?.newActiveFeatures
        ? operationResult.newActiveFeatures
        : externalActiveFeatures
          ? externalActiveFeatures
          : activeFeatures
            ? activeFeatures
            : getDefaultActiveFeatures(page);
      /* AVOID FINALIZE DATA FOR CERTAIN CONDITIONS */
      if (
        operation !== operationTypesEnum.FILTER_ROW &&
        operation !== operationTypesEnum.HIDE_COMMERCIAL &&
        operation !== operationTypesEnum.SHOW_PROGRAM_BASE_TIME &&
        operation !== operationTypesEnum.SHOW_NTC &&
        !isLoadUnsavedWork
      ) {
        const finalizedData = finalizeData({
          schedulingTableData: newSchedulingTableData,
          secondaryTableData: newSecondaryTableData,
          dropBucket: newDropBucket,
          lastMinuteSpots: newLastMinuteSpots,
          startTime: newStartTime,
          newActiveFeatures,
          customCellColor: newCustomCellColor,
          page,
          channel,
        });
        newSchedulingTableData = finalizedData.newSchedulingTableData;
        newSecondaryTableData = finalizedData.newSecondaryTableData;
        newDropBucket = finalizedData.newDropBucket;
        newLastMinuteSpots = finalizedData.newLastMinuteSpots;
      }
      /* UPDATE SCHEDULING TABLE */
      setSchedulingTableData(
        isChannelForbes
          ? newSchedulingTableData.map((row) => ({
            ...row,
            isHidden: row.F_C_S_P === rowDataTypesEnum.SEGMENT && true,
          }))
          : newSchedulingTableData,
      );
      /* UPDATE SECONDARY TABLE */
      setSecondaryTableData(newSecondaryTableData);
      /* UPDATE DROP BUCKET */
      setDropBucket(newDropBucket);
      /* UPDATE LAST MINUTE SPOTS */
      setLastMinuteSpots(newLastMinuteSpots);
      /* UPDATE SCHEDULER STATE IN REDUX */
      setUpdateSchedulerStateInRedux(true);
      /* UPDATE ACTIVE FEATURES */
      setActiveFeatures(newActiveFeatures);
      /* UPDATE CUSTOM CELL COLOR */
      newCustomCellColor = newCustomCellColor
        ? newCustomCellColor
        : getCustomCellColorFromTable(newSchedulingTableData);
      setCustomCellColor(newCustomCellColor);
      if (operation !== operationTypesEnum.INITIALIZE_SCHEDULER) {
        /* UPDATE UNDO REDO STACK */
        updateUndoRedoStacksForNewOperation();
        /* UNSELECT ALL ROWS FROM BOTH TABLE*/
        resetAllSelectedRows();
        /* MAINTAIN SCROLLED OFFSET OF BOTH TABLES */
        maintainScrolledOffsetOfTables();
      }
      return { newSchedulingTableData, newSecondaryTableData, newDropBucket };
    } catch (error) {
      throw error;
    }
  }
  /* =============================================================================== */
  /* WRITE OPERATION FUNCTIONS HERE */
  async function executeInitializeScheduler(
    isFirstLoad,
    isLoadUnsavedWork,
    isGenerateLog,
    mode,
    operation,
  ) {
    try {
      let newSchedulingTableData = [],
        newDropBucket,
        newLastMinuteSpots;
      let newActiveFeatures = getDefaultActiveFeatures(
        page,
        isScheduleAllowedToEdit,
      );
      const featureList = getFeaturesList(page, isScheduleAllowedToEdit);
      if (isFirstLoad && isLoadUnsavedWork) {
        /* GET SCHEDULING TABLE DATA FROM UNSAVED WORK STATE
             AND ADD ROW ACTIONS TO SCHEDULING TABLE DATA */
        newSchedulingTableData = getTableDataWithAdditionalInfo({
          tableData: unsavedWorkState.schedulingTableData,
          tableType: tableTypesEnum.SCHEDULING,
          additionalInfo: [additionalRowInfoEnum.ACTIONS],
          channel,
        });
        /* GET ACTIVE FEATURES FROM UNSAVED STATE */
        newActiveFeatures = unsavedWorkState.activeFeatures;
      } else {
        /* GET SCHEDULING TABLE DATA FROM API */
        newSchedulingTableData = await getSchedulingTableData(
          isGenerateLog,
          mode,
          date,
          page,
          channel,
        );
      }
      /* SET COLUMNS STATE */
      const columnsState = await getColumnsState(
        page,
        newSchedulingTableData,
        token,
        channel,
      );
      setSchedulingTableManagedColumns(columnsState);
      /* ADD MANAGE COLUMNS IN ACTIVE FEATURES */
      if ([featuresEnum.MANAGE_COLUMNS] in featureList) {
        newActiveFeatures = {
          ...newActiveFeatures,
          [featuresEnum.MANAGE_COLUMNS]: {
            isDropdownVisible: false,
            isActive:
              columnsState.removedColumns.length > 0 ||
              isJSONArrayEqual(
                columnsState.originalColumns,
                columnsState.visibleColumns,
              ),
          },
        };
      }
      /* SET NECESSARY STATES */
      setFeaturesList(featureList);
      resetTableStatesForInitialization();
      let newStartTime =
        newSchedulingTableData.length > 0
          ? newSchedulingTableData[1].Tel_Time
          : '';
      /* INITIALIZE DROP BUCKET */
      if (page === pagesEnum.COMMERCIAL || page === pagesEnum.FINAL_LOG) {
        newDropBucket = await getDroppedSpots(
          channel,
          convertDateToYMD(date),
          newSchedulingTableData,
          operation,
        );
        /* INITIALIZE LAST MINUTE SPOTS */
        newLastMinuteSpots = await getLastMinuteSpots(
          channel,
          convertDateToYMD(date),
          newSchedulingTableData,
          [...newDropBucket],
          page,
          operation,
        );
      }
      return {
        newSchedulingTableData,
        newSecondaryTableData: [],
        newDropBucket,
        newLastMinuteSpots,
        newActiveFeatures,
        newStartTime,
      };
    } catch (error) {
      throw error;
    }
  }

  function executeDragRow(dragInfo) {
    try {
      /* GET REQUIRED DATA TO UPDATE SCHEDULING TABLE FOR APPROPRIATE DRAG */
      let newSchedulingTableData = [...schedulingTableData];
      let newSecondaryTableData = [...secondaryTableData];
      let newDropBucket = [...dropBucket];
      let newLastMinuteSpots = [...lastMinuteSpots];
      let sourceDroppableId = dragInfo.source.droppableId;
      let destinationDroppableId = dragInfo.destination.droppableId;
      let sourceIndex =
        sourceDroppableId === droppableIdsEnum.SCHEDULING
          ? dragInfo.source.index
          : secondaryTableData.findIndex(
            (row) => row.rowId === dragInfo.draggableId,
          );
      let sourceRow =
        sourceDroppableId === droppableIdsEnum.SCHEDULING
          ? schedulingTableData[sourceIndex]
          : secondaryTableData[sourceIndex];
      if (!dragInfo.destination)
        return {
          newSchedulingTableData,
          newSecondaryTableData,
          newDropBucket,
          newLastMinuteSpots,
        };
      let destinationIndex = getDestinationIndex(
        sourceIndex,
        sourceRow,
        dragInfo.destination.index,
        sourceDroppableId,
        destinationDroppableId,
      );
      let selectedRows = getDraggedRows(sourceDroppableId, sourceRow);
      let isOperationValid = isDragValid(
        dragInfo,
        sourceDroppableId,
        sourceIndex,
        destinationIndex,
        selectedRows,
      );
      if (!isOperationValid) {
        openNotification('danger', 'Invalid operation');
        return {
          newSchedulingTableData,
          newSecondaryTableData,
          newDropBucket,
          newLastMinuteSpots,
        };
      }
      /* PLACE SELECTED ROWS IN SCHEDULING TABLE */
      if (sourceDroppableId === droppableIdsEnum.SCHEDULING) {
        newSchedulingTableData = executeSchTableDrag(
          selectedRows,
          destinationIndex,
        );
      } else if (
        sourceDroppableId === droppableIdsEnum.SECONDARY &&
        destinationDroppableId === droppableIdsEnum.SECONDARY
      ) {
        newSecondaryTableData = executeSecTableDrag(
          selectedRows,
          destinationIndex,
        );
        if (
          activeFeatures[featuresEnum.INSERT].eventType ===
          secondaryTableTypesEnum.DROPPED_SPOTS
        )
          newDropBucket = [...newSecondaryTableData];
        else if (
          activeFeatures[featuresEnum.INSERT].eventType ===
          secondaryTableTypesEnum.LAST_MINUTE_SPOTS
        )
          newLastMinuteSpots = [...newSecondaryTableData];
      } else if (
        sourceDroppableId === droppableIdsEnum.SECONDARY &&
        destinationDroppableId === droppableIdsEnum.SCHEDULING
      ) {
        const result = executeSecToSchTableDrag(
          selectedRows,
          destinationIndex,
          sourceRow,
        );
        newSchedulingTableData = result.newSchedulingTableData;
        newSecondaryTableData = result.newSecondaryTableData;
        newDropBucket = result.newDropBucket;
        newLastMinuteSpots = result.newLastMinuteSpots;
      }
      return {
        newSchedulingTableData,
        newSecondaryTableData,
        newDropBucket,
        newLastMinuteSpots,
      };
    } catch (error) {
      throw error;
    }
  }

  function executeInsertRow() {
    try {
      let selectedRows = [...secondaryTableSelectedRows];
      let newSchedulingTableData = [...schedulingTableData];
      let newSecondaryTableData = [...secondaryTableData];
      let newDropBucket = [...dropBucket];
      let newLastMinuteSpots = [...lastMinuteSpots];
      let destinationIndex = schedulingTableSelectedRows[0].rowIndex + 1;
      let destinationRow = schedulingTableData[destinationIndex];
      let isRowComm = selectedRows[0].F_C_S_P === rowDataTypesEnum.COMMERCIAL;
      let isRowNTC = selectedRows[0].F_C_S_P === rowDataTypesEnum.NTC;
      let isRowPaidNTC = isAnyNTCPaid(selectedRows);
      /* PLACE SELECTED ROWS IN SCHEDULING TABLE */
      let isRowValidForInsert = true;
      isRowValidForInsert = isDragValidForSourceRow(
        isChannelForbes,
        schedulingTableData,
        destinationIndex,
        selectedRows[0],
      );
      if (isRowComm) {
        isRowValidForInsert = isCommercialInsertValid(
          selectedRows,
          destinationIndex,
          newSchedulingTableData,
        );
      } else if (isRowNTC) {
        isRowValidForInsert = isNTCInsertValid(
          destinationIndex,
          destinationRow,
          selectedRows,
          schedulingTableData,
        );
      }
      if (isRowValidForInsert) {
        newSchedulingTableData.splice(destinationIndex, 0, ...selectedRows);
        if (isRowComm || isRowPaidNTC) {
          if (
            activeFeatures[featuresEnum.INSERT].eventType ===
            secondaryTableTypesEnum.DROPPED_SPOTS
          )
            newDropBucket = removeRowsFromTableData(
              selectedRows,
              newDropBucket,
            );
          else if (
            activeFeatures[featuresEnum.INSERT].eventType ===
            secondaryTableTypesEnum.LAST_MINUTE_SPOTS
          )
            newLastMinuteSpots = removeRowsFromTableData(
              selectedRows,
              newLastMinuteSpots,
            );
        }
      } else {
        openNotification('danger', 'Invalid operation');
      }
      return {
        newSchedulingTableData,
        newSecondaryTableData,
        newDropBucket,
        newLastMinuteSpots,
      };
    } catch (error) {
      throw error;
    }
  }

  function executeBulkInsert({
    insertPosition,
    time,
    selectedBreaks,
    selectedRows,
    descriptionType,
    bulkNTCInsDesc,
    durationType,
    bulkNTCInsDuration,
    bulkNTCInsOffsetTime,
  }) {
    try {
      let newSchedulingTableData = [];
      if (selectedRows[0].F_C_S_P === rowDataTypesEnum.NTC)
        newSchedulingTableData = executeBulkNTCInsert({
          insertPosition,
          time,
          selectedBreaks,
          selectedRows,
          descriptionType,
          bulkNTCInsDesc,
          durationType,
          bulkNTCInsDuration,
          bulkNTCInsOffsetTime,
        });
      else
        newSchedulingTableData = executeBulkRowsInsert(
          insertPosition,
          time,
          selectedBreaks,
          selectedRows,
        );
      return { newSchedulingTableData };
    } catch (error) {
      throw error;
    }
  }

  function executeBulkNTCInsert({
    insertPosition,
    time,
    selectedBreaks,
    selectedRows,
    descriptionType,
    bulkNTCInsDesc,
    durationType,
    bulkNTCInsDuration,
    bulkNTCInsOffsetTime,
  }) {
    try {
      let newSchedulingTableData = [];
      if (isChannelForbes)
        newSchedulingTableData = executeBulkNTCInsertForForbes({
          selectedRows,
          time,
          descriptionType,
          bulkNTCInsDesc,
          durationType,
          bulkNTCInsDuration,
          bulkNTCInsOffsetTime,
        });
      else
        newSchedulingTableData = executeBulkNTCInsertForOthers({
          insertPosition,
          time,
          selectedBreaks,
          selectedRows,
          descriptionType,
          bulkNTCInsDesc,
          durationType,
          bulkNTCInsDuration,
          bulkNTCInsOffsetTime,
        });
      return newSchedulingTableData;
    } catch (error) {
      throw error;
    }
  }

  function executeBulkNTCInsertForForbes({
    selectedRows,
    time,
    descriptionType,
    bulkNTCInsDesc,
    durationType,
    bulkNTCInsDuration,
    bulkNTCInsOffsetTime,
  }) {
    try {
      let newSchedulingTableData = [];
      for (let index = 0; index < schedulingTableData.length; index++) {
        const row = schedulingTableData[index];
        if (
          (row.F_C_S_P === rowDataTypesEnum.PROMO ||
            row.F_C_S_P === rowDataTypesEnum.SONG ||
            row.F_C_S_P === rowDataTypesEnum.LIVE) &&
          isRowBetweenValidTime(row, time)
        ) {
          let updatedSelectedRows = addPropertiesToSelectedNTCs(
            selectedRows,
            row,
            descriptionType,
            bulkNTCInsDesc,
            durationType,
            bulkNTCInsDuration,
            bulkNTCInsOffsetTime,
          );
          newSchedulingTableData.push(row);
          newSchedulingTableData = insertNTCsBelowParent(
            row, // The parent row (segment) for NTC insertion
            newSchedulingTableData.length, // Position to insert
            newSchedulingTableData, // Updated scheduling table
            updatedSelectedRows,
          );
        } else {
          newSchedulingTableData.push(row);
        }
      }
      return newSchedulingTableData;
    } catch (error) {
      throw error;
    }
  }

  function executeBulkNTCInsertForOthers({
    insertPosition,
    time,
    selectedBreaks,
    selectedRows,
    descriptionType,
    bulkNTCInsDesc,
    durationType,
    bulkNTCInsDuration,
    bulkNTCInsOffsetTime,
  }) {
    try {
      let newSchedulingTableData = [];
      let isCurBlockValid = false;
      for (let index = 0; index < schedulingTableData.length; index++) {
        const row = schedulingTableData[index];
        const nextRow = schedulingTableData[index + 1];
        const isRowSegmentOrLive =
          row.F_C_S_P === rowDataTypesEnum.SEGMENT ||
          row.F_C_S_P === rowDataTypesEnum.LIVE;
        // Update the validity of the current segment
        if (row.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION) {
          // Content termination marks the end of a valid segment
          isCurBlockValid = false;
        } else if (isRowSegmentOrLive) {
          // Check if the current segment is valid based on provided criteria
          isCurBlockValid = isSegmentValid(row, time, selectedBreaks);
        }
        // If the current segment is valid, proceed with insertion logic
        if (isCurBlockValid) {
          /* Add appropriate properties to selectedRows before insert*/
          let updatedSelectedRows = addPropertiesToSelectedNTCs(
            selectedRows,
            row,
            descriptionType,
            bulkNTCInsDesc,
            durationType,
            bulkNTCInsDuration,
            bulkNTCInsOffsetTime,
          );
          // Case 1: Insert NTCs at the start of the segment
          if (
            insertPosition === bulkInsertPositionEnum.START &&
            isRowSegmentOrLive
          ) {
            newSchedulingTableData.push(row); // Add the current row (segment)
            newSchedulingTableData = insertNTCsBelowParent(
              row, // The parent row (segment) for NTC insertion
              newSchedulingTableData.length, // Position to insert
              newSchedulingTableData, // Updated scheduling table
              updatedSelectedRows,
            );
            continue; // Skip to the next iteration
          }
          // Case 2: Insert NTCs at the end of the segment
          if (
            insertPosition === bulkInsertPositionEnum.END && // Check if insertion is at the end
            nextRow && // Ensure there is a next row
            (nextRow.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION || // Check if the next row is content termination
              nextRow.F_C_S_P === rowDataTypesEnum.SEGMENT) // Or if it's another segment
          ) {
            // If the current row is a commercial or NTC, find the insertion point
            if (
              row.F_C_S_P === rowDataTypesEnum.COMMERCIAL ||
              row.F_C_S_P === rowDataTypesEnum.NTC ||
              row.F_C_S_P === rowDataTypesEnum.BREAK
            ) {
              // Traverse backward to find the last non-commercial row
              for (let j = newSchedulingTableData.length - 1; j >= 0; j--) {
                if (
                  newSchedulingTableData[j].F_C_S_P !==
                  rowDataTypesEnum.COMMERCIAL &&
                  newSchedulingTableData[j].F_C_S_P !== rowDataTypesEnum.NTC &&
                  newSchedulingTableData[j].F_C_S_P !== rowDataTypesEnum.BREAK
                ) {
                  // Insert NTCs below the identified row
                  newSchedulingTableData = insertNTCsBelowParent(
                    newSchedulingTableData[j], // Parent row
                    j, // Position of the parent row
                    newSchedulingTableData, // Updated scheduling table
                    updatedSelectedRows,
                  );
                  break; // Stop searching once the parent row is found
                }
              }
            } else {
              // Otherwise, add the current row and insert NTCs below it
              newSchedulingTableData.push(row); // Add the current row
              newSchedulingTableData = insertNTCsBelowParent(
                row, // Parent row
                newSchedulingTableData.length, // Current position in the table
                newSchedulingTableData, // Updated scheduling table
                updatedSelectedRows,
              );
              continue; // Skip to the next iteration
            }
          }
        }
        // Default case: Add the current row to the new scheduling table
        newSchedulingTableData.push(row);
      }
      return newSchedulingTableData;
    } catch (error) {
      throw error;
    }
  }

  function addPropertiesToSelectedNTCs(
    selectedRows,
    parentRow,
    descriptionType,
    bulkNTCInsDesc,
    durationType,
    bulkNTCInsDuration,
    bulkNTCInsOffsetTime,
  ) {
    try {
      let updatedSelectedRows = selectedRows.map((curRow) => ({
        ...curRow,
        Description:
          descriptionType === ntcDescriptionTypesEnum.PARENT
            ? parentRow.Event_Name
            : descriptionType === ntcDescriptionTypesEnum.CUSTOM
              ? bulkNTCInsDesc
              : curRow.Description,
        Duration:
          durationType === ntcDurationTypesEnum.PARENT
            ? subtractTimes(parentRow.Duration, bulkNTCInsOffsetTime)
            : durationType === ntcDurationTypesEnum.CUSTOM
              ? bulkNTCInsDuration
              : curRow.Duration,
        OffsetStartTime: bulkNTCInsOffsetTime,
      }));
      return updatedSelectedRows;
    } catch (error) {
      throw error;
    }
  }

  function insertNTCsBelowParent(
    parentRow,
    parentIndex,
    tableData,
    selectedRows,
  ) {
    try {
      let newTableData = [...tableData];
      let insertIndex = parentIndex + 1;
      selectedRows.forEach((selectedRow) => {
        // Insert NTCs that fits within the parent duration
        const ntcStartTime = addTimes(
          parentRow.Start_Time,
          selectedRow.OffsetStartTime,
        );
        const ntcEndTime = addTimes(ntcStartTime, selectedRow.Duration);
        if (ntcEndTime <= addTimes(parentRow.Start_Time, parentRow.Duration)) {
          newTableData.splice(insertIndex, 0, {
            ...selectedRow,
            Start_Time: ntcStartTime,
            Tel_Time: ntcStartTime,
          });
          insertIndex = insertIndex + 1;
        }
      });
      return newTableData;
    } catch (error) {
      throw error;
    }
  }

  function executeBulkRowsInsert(
    insertPosition,
    time,
    selectedBreaks,
    selectedRows,
  ) {
    try {
      let newSchedulingTableData = [];
      let isCurBlockValid = false;
      for (let index = 0; index < schedulingTableData.length; index++) {
        const row = schedulingTableData[index];
        const nextRow = schedulingTableData[index + 1];
        const isRowSegment = row.F_C_S_P === rowDataTypesEnum.SEGMENT;
        const isRowLive = row.F_C_S_P === rowDataTypesEnum.LIVE;
        // Update the validity of the current segment
        if (row.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION) {
          // Mark the segment as invalid if the row is content termination
          isCurBlockValid = false;
        } else if (isRowSegment) {
          // Validate the segment using the given time and selected breaks
          isCurBlockValid = isSegmentValid(row, time, selectedBreaks);
        } else if (isRowLive) {
          // Validate the live row using the given time and selected breaks
          isCurBlockValid =
            isSegmentValid(row, time, selectedBreaks) && !isChannelForbes;
        }
        // Perform insertion logic if the current segment is valid
        if (isCurBlockValid) {
          // Case 1: Insert rows at the start of the segment
          if (insertPosition === bulkInsertPositionEnum.START && isRowSegment) {
            // Add the current row and the secondary table's selected rows
            newSchedulingTableData.push(row, ...selectedRows);
            continue; // Move to the next iteration
          }
          // Case 2: Insert rows at the end of the segment
          if (
            insertPosition === bulkInsertPositionEnum.END && // Check if insertion is at the end
            nextRow && // Ensure there is a next row
            (nextRow.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION || // Check if the next row is content termination
              nextRow.F_C_S_P === rowDataTypesEnum.SEGMENT) // Or if it's another segment
          ) {
            // If the current row is a commercial, find the insertion point
            if (
              row.F_C_S_P === rowDataTypesEnum.COMMERCIAL ||
              row.F_C_S_P === rowDataTypesEnum.BREAK
            ) {
              // Traverse backward to locate the last non-commercial row
              for (let j = newSchedulingTableData.length - 1; j >= 0; j--) {
                if (
                  newSchedulingTableData[j].F_C_S_P !==
                  rowDataTypesEnum.COMMERCIAL &&
                  newSchedulingTableData[j].F_C_S_P !== rowDataTypesEnum.BREAK
                ) {
                  // Insert the secondary table's selected rows after the identified row
                  newSchedulingTableData.splice(
                    j + 1, // Position to insert
                    0,
                    ...selectedRows, // Rows to insert
                  );
                  break; // Stop searching once the insertion point is found
                }
              }
            } else {
              // Otherwise, add the current row and the secondary rows
              newSchedulingTableData.push(row, ...selectedRows);
              continue; // Move to the next iteration
            }
          }
        }
        // Default case: Add the current row to the updated table
        newSchedulingTableData.push(row);
      }
      return newSchedulingTableData;
    } catch (error) {
      throw error;
    }
  }

  function executeSCTEInsert(isShowSCTE) {
    try {
      let newSchedulingTableData = [];
      if (isShowSCTE) {
        let selectedRows = SCTE_ROWS.map((row) => ({
          ...row,
          VideoID: row.HouseID,
        }));
        selectedRows = addPropertiesToSelectedNTCs(
          selectedRows,
          undefined,
          ntcDescriptionTypesEnum.CUSTOM,
          '',
          ntcDurationTypesEnum.CUSTOM,
          '00:00:00:00',
          '00:00:00:00',
        );
        for (let index = 0; index < schedulingTableData.length; index++) {
          const row = schedulingTableData[index];
          if (row.F_C_S_P === rowDataTypesEnum.BREAK) {
            newSchedulingTableData.push(selectedRows[0]);
            newSchedulingTableData.push(row);
            newSchedulingTableData.push(selectedRows[1]);
          } else {
            newSchedulingTableData.push(row);
          }
        }
      } else {
        newSchedulingTableData = schedulingTableData.filter(
          (row) =>
            row.Event_Name !== 'SCTE ON' && row.Event_Name !== 'SCTE OFF',
        );
      }
      return { newSchedulingTableData };
    } catch (error) {
      throw error;
    }
  }

  function executeReplaceRow() {
    try {
      let newSchedulingTableData = [...schedulingTableData];
      let secTableSelectedRow = secondaryTableSelectedRows[0];
      /* PLACE SELECTED ROWS IN SCHEDULING TABLE */
      schedulingTableSelectedRows.forEach((selectedSchRow) => {
        const replacedSchRow = {
          ...selectedSchRow,
          Event_Name: secTableSelectedRow.Event_Name,
          Duration: secTableSelectedRow.Duration,
          VideoID: secTableSelectedRow.HouseID,
          Tape_ID: secTableSelectedRow.Tape_ID,
        };
        if (secTableSelectedRow.F_C_S_P === rowDataTypesEnum.PROMO) {
          replacedSchRow.PromoCode = secTableSelectedRow.PromoCode;
          replacedSchRow.PromoTypeCode = secTableSelectedRow.PromoTypeCode;
        } else if (secTableSelectedRow.F_C_S_P === rowDataTypesEnum.SONG) {
          replacedSchRow.SongCode = secTableSelectedRow.SongCode;
          replacedSchRow.SongTypeCode = secTableSelectedRow.SongTypeCode;
          replacedSchRow.SongCategoryCode =
            secTableSelectedRow.SongCategoryCode;
        }
        newSchedulingTableData[selectedSchRow.rowIndex] = replacedSchRow;
      });
      return {
        newSchedulingTableData,
        newSecondaryTableData: secondaryTableData,
      };
    } catch (error) {
      throw error;
    }
  }

  function executeReplaceAllRow() {
    try {
      let newSchedulingTableData = [...schedulingTableData];
      const schTableSelectedEvents = getUniqueObjects(
        schedulingTableSelectedRows,
        'Event_Name',
      ).map((row) => row.Event_Name);
      const secTableSelectedRow = secondaryTableSelectedRows[0];
      /* PLACE SELECTED ROWS IN SCHEDULING TABLE */
      newSchedulingTableData = newSchedulingTableData.map((row) => {
        const replacedRow = { ...row };
        if (schTableSelectedEvents.includes(row.Event_Name)) {
          replacedRow.Event_Name = secTableSelectedRow.Event_Name;
          replacedRow.Duration = secTableSelectedRow.Duration;
          replacedRow.VideoID = secTableSelectedRow.HouseID;
          replacedRow.Tape_ID = secTableSelectedRow.Tape_ID;
          if (secTableSelectedRow.F_C_S_P === rowDataTypesEnum.PROMO) {
            replacedRow.PromoCode = secTableSelectedRow.PromoCode;
            replacedRow.PromoTypeCode = secTableSelectedRow.PromoTypeCode;
          } else if (secTableSelectedRow.F_C_S_P === rowDataTypesEnum.SONG) {
            replacedRow.SongCode = secTableSelectedRow.SongCode;
            replacedRow.SongTypeCode = secTableSelectedRow.SongTypeCode;
            replacedRow.SongCategoryCode = secTableSelectedRow.SongCategoryCode;
          }
        }
        return replacedRow;
      });
      return {
        newSchedulingTableData,
        newSecondaryTableData: secondaryTableData,
      };
    } catch (error) {
      throw error;
    }
  }

  function executeDeleteRow(selectedRowsToDelete) {
    try {
      let selectedRowsId = selectedRowsToDelete.map((row) => row.rowId);
      let newSchedulingTableData = [...schedulingTableData].filter(
        (row) => !selectedRowsId.includes(row.rowId),
      );
      return {
        newSchedulingTableData,
        newSecondaryTableData: secondaryTableData,
      };
    } catch (error) {
      throw error;
    }
  }

  function executeDropRow(selectedRowsToDrop) {
    try {
      let selectedRowsId = selectedRowsToDrop.map((row) => row.rowId);
      /* REMOVE DROPPED ROW FROM SCHEDULING TABLE */
      let newSchedulingTableData = [...schedulingTableData].filter(
        (row) => !selectedRowsId.includes(row.rowId),
      );
      let newDropBucket, newSecondaryTableData;
      let droppedRows = removeAdditionalInfoFromRows(selectedRowsToDrop);
      /* APPEND DROPPED ROWS TO DROP BUCKET */
      if (Array.isArray(dropBucket) && dropBucket.length > 0) {
        newDropBucket = [...dropBucket, ...droppedRows];
      } else newDropBucket = [getDummyRow(droppedRows[0]), ...droppedRows];
      /* UPDATE SECONDARY TABLE DATA IF INSERT DROPPED SPOTS IS ACTIVE*/
      if (
        activeFeatures[featuresEnum.INSERT]?.isActive &&
        activeFeatures[featuresEnum.INSERT].eventType ===
        secondaryTableTypesEnum.DROPPED_SPOTS
      )
        newSecondaryTableData = [...newDropBucket];
      else newSecondaryTableData = [...secondaryTableData];
      return {
        newSchedulingTableData,
        newSecondaryTableData,
        newDropBucket,
      };
    } catch (error) {
      throw error;
    }
  }

  function executeReplaceProgram(
    clickedProgram,
    clickedProgramSchedule,
    newProgramSchedule,
  ) {
    try {
      const clickedProgramSegmentWiseContent = getSegmentWiseContent(
        clickedProgramSchedule,
      );
      const newProgramWithSegmentContent = getProgramWithSegmentContent(
        newProgramSchedule,
        clickedProgramSegmentWiseContent,
        clickedProgram,
      );
      let newSchedulingTableData = updateProgramInSchedulingTableData(
        clickedProgram,
        newProgramWithSegmentContent,
        schedulingTableData,
      );
      return {
        newSchedulingTableData,
        newSecondaryTableData: secondaryTableData,
      };
    } catch (error) {
      throw error;
    }
  }

  function executeFilterRow(tableType, selectedFilters) {
    try {
      let newSchedulingTableData = [...schedulingTableData];
      let newSecondaryTableData = [...secondaryTableData];
      let newDropBucket = [...dropBucket];
      let newLastMinuteSpots = [...lastMinuteSpots];
      tableType.forEach((curTableType) => {
        if (curTableType === tableTypesEnum.SCHEDULING) {
          newSchedulingTableData = getFilteredTableData(
            newSchedulingTableData,
            selectedFilters,
          );
          if (selectedFilters.length === 0) setSchTableSelectedFilters([]);
        } else {
          newSecondaryTableData = getFilteredTableData(
            newSecondaryTableData,
            selectedFilters,
          );
          if (
            activeFeatures[featuresEnum.INSERT]?.eventType ===
            secondaryTableTypesEnum.DROPPED_SPOTS
          )
            newDropBucket = [...newSecondaryTableData];
          else if (
            activeFeatures[featuresEnum.INSERT]?.eventType ===
            secondaryTableTypesEnum.LAST_MINUTE_SPOTS
          )
            newLastMinuteSpots = [...newSecondaryTableData];
          if (selectedFilters.length === 0) setSecTableSelectedFilters([]);
        }
      });
      return {
        newSchedulingTableData,
        newSecondaryTableData,
        newDropBucket,
        newLastMinuteSpots,
      };
    } catch (error) {
      throw error;
    }
  }

  function executeHideCommercial(isHideCommercial, startTime) {
    try {
      let newSchedulingTableData = getFilteredTableData(
        [...schedulingTableData],
        [
          ...schTableSelectedFilters,
          {
            columnKey: 'F_C_S_P',
            filter: tableFilterOptionsEnum.HIDE_COMMERCIAL,
            searchValue: isHideCommercial.toString(),
          },
        ],
      );
      const dummyRow = newSchedulingTableData.shift();
      newSchedulingTableData = updateStartTimes(
        newSchedulingTableData,
        activeFeatures[featuresEnum.SHOW_PROGRAM_BASE_TIME],
        isHideCommercial,
        undefined,
        startTime,
      );
      return {
        newSchedulingTableData: [dummyRow, ...newSchedulingTableData],
        newSecondaryTableData: [...secondaryTableData],
      };
    } catch (error) {
      throw error;
    }
  }

  function executeShowProgramBaseTime(isShowProgramBaseTime, startTime) {
    try {
      let newSchedulingTableData = [...schedulingTableData];
      const dummyRow = newSchedulingTableData.shift();
      newSchedulingTableData = updateStartTimes(
        newSchedulingTableData,
        isShowProgramBaseTime,
        activeFeatures[featuresEnum.HIDE_COMMERCIALS],
        undefined,
        startTime,
      );
      return {
        newSchedulingTableData: [dummyRow, ...newSchedulingTableData],
        newSecondaryTableData: [...secondaryTableData],
      };
    } catch (error) {
      throw error;
    }
  }

  function executeShowNTC(isShowNTC) {
    try {
      let newSchedulingTableData = getFilteredTableData(
        [...schedulingTableData],
        [
          ...schTableSelectedFilters,
          {
            columnKey: 'F_C_S_P',
            filter: tableFilterOptionsEnum.SHOW_NTC,
            searchValue: isShowNTC.toString(),
          },
        ],
      );
      return {
        newSchedulingTableData,
        newSecondaryTableData: [...secondaryTableData],
      };
    } catch (error) {
      throw error;
    }
  }

  function executeInsertNTCByStartTime() {
    try {
      let newSchedulingTableData = [...schedulingTableData];
      let newSecondaryTableData = [...secondaryTableData];
      const insertTime = secondaryTableSelectedRows[0].Start_Time;
      const endTime = addTimes(
        insertTime,
        secondaryTableSelectedRows[0].Duration,
      );
      const isPaidNTC = secondaryTableSelectedRows[0].BookingDetailID
        ? true
        : false;
      let insertIndex = newSchedulingTableData.findIndex((row, index) => {
        if (index === 0) return false;
        return (
          row.F_C_S_P !== rowDataTypesEnum.CONTENT_TERMINATION &&
          row.F_C_S_P !== rowDataTypesEnum.COMMERCIAL &&
          row.F_C_S_P !== rowDataTypesEnum.NTC &&
          insertTime >= row.Start_Time &&
          endTime <= addTimes(row.Start_Time, row.Duration)
        );
      });
      if (insertIndex === -1) {
        openNotification('danger', 'No valid insertion point found');
        return {
          newSchedulingTableData,
          newSecondaryTableData,
        };
      } else {
        insertIndex = insertIndex + 1;
        let updatedSecTableSelectedRows = [...secondaryTableSelectedRows].map(
          (row) => {
            return updateOffsetStartTime(
              row,
              getNTCParentRow(insertIndex + 1, schedulingTableData),
            );
          },
        );
        newSchedulingTableData.splice(
          insertIndex,
          0,
          ...updatedSecTableSelectedRows,
        );
        if (isPaidNTC) {
          secondaryTableSelectedRows.forEach((selectedRow) => {
            newSecondaryTableData = newSecondaryTableData.filter(
              (row) => row.rowId !== selectedRow.rowId,
            );
          });
          if (newSecondaryTableData.length === 1) newSecondaryTableData = [];
        }
      }
      return {
        newSchedulingTableData,
        newSecondaryTableData,
      };
    } catch (error) {
      throw error;
    }
  }

  const executePromoAutoShuffle = async (promoShuffleTemplate, time) => {
    let newSchedulingTableData = schedulingTableData.map((item) => ({ ...item }));
    let CT_Entries = [];
    let S_Index_Map = new Map();
    let segmentStats = new Map();
    newSchedulingTableData.forEach((item, index) => {
      if (item.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION) {
        CT_Entries.push(index);
        segmentStats.set(index, { count: 0, sumDuration: 0 });
      }
    });
    newSchedulingTableData.forEach((item, index) => {
      if (item.F_C_S_P === rowDataTypesEnum.SEGMENT) {
        for (let i = CT_Entries.length - 1; i >= 0; i--) {
          if (index > CT_Entries[i]) {
            let stats = segmentStats.get(CT_Entries[i]);
            stats.count++;
            stats.sumDuration += timeToSeconds(item.Duration);
            S_Index_Map.set(index, CT_Entries[i]);
            break;
          }
        }
      }
    });
    CT_Entries.forEach(ctIndex => {
      let item = newSchedulingTableData[ctIndex];
      let stats = segmentStats.get(ctIndex);
      item.DurationInSeconds = timeToSeconds(item.FPC_TimeTo + ':00:00') - timeToSeconds(item.FPC_Time + ':00:00');
      item.S_Count = stats.count;
      item.Sum_of_S_Duration = stats.sumDuration;
    });
    newSchedulingTableData.forEach((item, index) => {
      if (item.F_C_S_P === rowDataTypesEnum.SEGMENT && S_Index_Map.has(index)) {
        let ctIndex = S_Index_Map.get(index);
        let CT_Item = newSchedulingTableData[ctIndex];
        item.Calculated_Value = CT_Item.S_Count > 0 ? (CT_Item.DurationInSeconds - CT_Item.Sum_of_S_Duration) / CT_Item.S_Count : 0;
      }
    });
    let lastSIndex = -1;
    newSchedulingTableData.forEach((item, index) => {
      if (item.F_C_S_P === rowDataTypesEnum.SEGMENT) {
        lastSIndex = index;
      } else if (lastSIndex !== -1 && ![rowDataTypesEnum.CONTENT_TERMINATION, rowDataTypesEnum.NTC, rowDataTypesEnum.SEGMENT].includes(item.F_C_S_P)) {
        newSchedulingTableData[lastSIndex].Calculated_Value -= timeToSeconds(item.Duration);
      }
    });
    const promoList = await getPromosFromTemplateId(promoShuffleTemplate.value);
    return { newSchedulingTableData: insertPromos(newSchedulingTableData, promoList, time) };
  };

  /* HELPER FUNCTIONS THAT ARE USING STATE VARIABLES */
  function getDestinationIndex(
    sourceIndex,
    sourceRow,
    destIndex,
    sourceDroppableId,
    destinationDroppableId,
  ) {
    try {
      let destinationIndex = destIndex;
      if (destinationDroppableId === droppableIdsEnum.SCHEDULING) {
        /* DESTINATION INDEX CORRECTION IF FILTER IS ACTIVE */
        if (activeFeatures[featuresEnum.FILTER]) {
          let isFilteredRowFound = false;
          for (let index = destinationIndex; index >= 0; index--) {
            let curIndex = sourceIndex > destinationIndex ? index - 1 : index;
            if (schedulingTableData[curIndex].isFiltered) {
              destinationIndex = index;
              isFilteredRowFound = true;
              break;
            }
          }
          if (!isFilteredRowFound) {
            for (
              let index = destinationIndex;
              index <= schedulingTableData.length;
              index++
            ) {
              if (schedulingTableData[index + 1].isFiltered) {
                destinationIndex = index;
                break;
              }
            }
          }
        }
        if (
          sourceDroppableId === droppableIdsEnum.SCHEDULING &&
          sourceIndex < destinationIndex
        ) {
          /* DESTINATION INDEX CORRECTION IF DRAG IS TOP TO BOTTOM */
          destinationIndex = destinationIndex + 1;
        }
        /* DESTINATION INDEX CORRECTION IF PAGE IS PROMO OR SONG AND DESTINATION INDEX IS BELOW COMMERCIAL */
        if (
          (page === pagesEnum.PROMO || page === pagesEnum.SONG) &&
          schedulingTableData[destinationIndex - 1].F_C_S_P ===
          rowDataTypesEnum.COMMERCIAL
        ) {
          destinationIndex = destinationIndex - 1;
        }
        return sourceRow.F_C_S_P !== rowDataTypesEnum.CONTENT_TERMINATION
          ? destinationIndex > 1
            ? destinationIndex
            : 2
          : destinationIndex;
      } else if (
        sourceDroppableId === droppableIdsEnum.SECONDARY &&
        destinationDroppableId === droppableIdsEnum.SECONDARY
      ) {
        /* DESTINATION INDEX CORRECTION IF FILTER IS ACTIVE */
        if (activeFeatures[featuresEnum.FILTER]) {
          let isFilteredRowFound = false;
          for (let index = destinationIndex; index >= 0; index--) {
            let curIndex = sourceIndex > destinationIndex ? index - 1 : index;
            if (secondaryTableData[curIndex].isFiltered) {
              destinationIndex = index;
              isFilteredRowFound = true;
              break;
            }
          }
          if (!isFilteredRowFound) {
            for (
              let index = destinationIndex;
              index <= secondaryTableData.length;
              index++
            ) {
              if (secondaryTableData[index + 1].isFiltered) {
                destinationIndex = index;
                break;
              }
            }
          }
        }
        if (sourceIndex < destinationIndex) {
          /* DESTINATION INDEX CORRECTION IF DRAG IS TOP TO BOTTOM */
          destinationIndex = destinationIndex + 1;
        }
        return destinationIndex;
      }
    } catch (error) {
      throw error;
    }
  }

  function getDraggedRows(sourceDroppableId, sourceRow) {
    try {
      let draggedRows = [];
      let isClickedRowNTCCompatible =
        sourceRow.F_C_S_P !== rowDataTypesEnum.COMMERCIAL &&
        sourceRow.F_C_S_P !== rowDataTypesEnum.CONTENT_TERMINATION &&
        sourceRow.F_C_S_P !== rowDataTypesEnum.NTC;
      if (sourceDroppableId === droppableIdsEnum.SCHEDULING) {
        if (
          schedulingTableSelectedRows.length === 0 &&
          isClickedRowNTCCompatible
        )
          draggedRows = getRowWithNTC(
            [...schedulingTableSelectedRows, sourceRow],
            schedulingTableData,
          );
        else draggedRows = [...schedulingTableSelectedRows, sourceRow];
      } else draggedRows = [...secondaryTableSelectedRows, sourceRow];
      return getUniqueObjects(draggedRows, 'rowId');
    } catch (error) {
      throw error;
    }
  }

  function isDragValid(
    dragInfo,
    sourceDroppableId,
    sourceIndex,
    destinationIndex,
    draggedRows,
  ) {
    try {
      let destinationDroppableId = dragInfo.destination.droppableId;
      let destination = dragInfo.destination;
      let destinationRow = schedulingTableData[destinationIndex];
      if (
        isBasicDragInvalid(
          sourceIndex,
          sourceDroppableId,
          destination,
          destinationDroppableId,
          destinationIndex,
        )
      ) {
        return false;
      }
      if (sourceDroppableId === droppableIdsEnum.SCHEDULING) {
        let sourceRow = schedulingTableData[sourceIndex];
        // If channel is forbes and destination row is below live and source row is not NTC, return false
        if (
          !isDragValidForSourceRow(
            isChannelForbes,
            schedulingTableData,
            destinationIndex,
            sourceRow,
          )
        )
          return false;
        if (
          isRowDataTypePresentInDraggedRows(
            draggedRows,
            rowDataTypesEnum.COMMERCIAL,
          )
        ) {
          let commercialRows = draggedRows.filter(
            (row) => row.F_C_S_P === rowDataTypesEnum.COMMERCIAL,
          );
          if (
            !isCommercialInsertValid(
              commercialRows,
              destinationIndex,
              schedulingTableData,
            )
          )
            return false;
        } else if (sourceRow.F_C_S_P === rowDataTypesEnum.NTC) {
          let ntcRows = draggedRows.filter(
            (row) => row.F_C_S_P === rowDataTypesEnum.NTC,
          );
          if (
            !isNTCInsertValid(
              destinationIndex,
              destinationRow,
              ntcRows,
              schedulingTableData,
            )
          )
            return false;
        }
      } else if (
        sourceDroppableId === droppableIdsEnum.SECONDARY &&
        destinationDroppableId === droppableIdsEnum.SCHEDULING
      ) {
        // If channel is forbes and destination row is below live and source row is not NTC, return false
        if (
          !isDragValidForSourceRow(
            isChannelForbes,
            schedulingTableData,
            destinationIndex,
            draggedRows[0],
          )
        )
          return false;
        if (
          draggedRows[0].F_C_S_P === rowDataTypesEnum.COMMERCIAL &&
          !isCommercialInsertValid(
            draggedRows,
            destinationIndex,
            schedulingTableData,
          )
        ) {
          return false;
        } else if (
          draggedRows[0].F_C_S_P === rowDataTypesEnum.NTC &&
          !isNTCInsertValid(
            destinationIndex,
            destinationRow,
            draggedRows,
            schedulingTableData,
          )
        ) {
          return false;
        }
      }
      return true;
    } catch (error) {
      openNotification('danger', 'Something went wrong while validating drag');
      console.error(error);
    }
  }

  function executeSchTableDrag(selectedRows, destinationIndex) {
    try {
      let newSchedulingTableData = [...schedulingTableData];
      let selectedRowsWithNewRowId = getTableDataWithAdditionalInfo({
        tableData: selectedRows,
        tableType: tableTypesEnum.SCHEDULING,
        additionalInfo: [additionalRowInfoEnum.ROW_ID],
      });
      newSchedulingTableData.splice(
        destinationIndex,
        0,
        ...selectedRowsWithNewRowId,
      );
      if (activeFeatures[featuresEnum.COPY]) {
        /* AVOID COPYING PAID NTCs and COMMERCIALS */
        selectedRows = selectedRows.filter(
          (row) =>
            row.F_C_S_P === rowDataTypesEnum.COMMERCIAL ||
            (row.F_C_S_P === rowDataTypesEnum.NTC && row.BookingDetailID),
        );
      }
      newSchedulingTableData = removeRowsFromTableData(
        selectedRows,
        newSchedulingTableData,
      );
      return newSchedulingTableData;
    } catch (error) {
      throw error;
    }
  }

  function executeSecTableDrag(selectedRows, destinationIndex) {
    try {
      let newSecTableData = [...secondaryTableData];
      let selectedRowsWithNewRowId = getTableDataWithAdditionalInfo({
        tableData: selectedRows,
        tableType: tableTypesEnum.SCHEDULING,
        additionalInfo: [additionalRowInfoEnum.ROW_ID],
      });
      newSecTableData.splice(destinationIndex, 0, ...selectedRowsWithNewRowId);
      newSecTableData = removeRowsFromTableData(selectedRows, newSecTableData);
      return newSecTableData;
    } catch (error) {
      throw error;
    }
  }

  function executeSecToSchTableDrag(selectedRows, destinationIndex, sourceRow) {
    try {
      let newSchedulingTableData = [...schedulingTableData];
      let newSecondaryTableData = [...secondaryTableData];
      let newDropBucket = [...dropBucket];
      let newLastMinuteSpots = [...lastMinuteSpots];
      let rowsToInsert;
      if (
        sourceRow.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION &&
        activeFeatures[featuresEnum.MANAGE_SEGMENT]
      )
        rowsToInsert = getProgramSchedule(newSecondaryTableData, sourceRow);
      else rowsToInsert = [...selectedRows];
      newSchedulingTableData.splice(destinationIndex, 0, ...rowsToInsert);
      if (
        sourceRow.F_C_S_P === rowDataTypesEnum.COMMERCIAL ||
        isAnyNTCPaid(selectedRows)
      ) {
        if (
          sourceRow.F_C_S_P === rowDataTypesEnum.COMMERCIAL &&
          activeFeatures[featuresEnum.INSERT]?.isActive
        ) {
          if (
            activeFeatures[featuresEnum.INSERT].eventType ===
            secondaryTableTypesEnum.DROPPED_SPOTS
          )
            newDropBucket = removeRowsFromTableData(
              selectedRows,
              newDropBucket,
            );
          else if (
            activeFeatures[featuresEnum.INSERT].eventType ===
            secondaryTableTypesEnum.LAST_MINUTE_SPOTS
          )
            newLastMinuteSpots = removeRowsFromTableData(
              selectedRows,
              newLastMinuteSpots,
            );
        }
      }
      return {
        newSchedulingTableData,
        newSecondaryTableData,
        newDropBucket,
        newLastMinuteSpots,
      };
    } catch (error) {
      throw error;
    }
  }
  /* =================================================================================== */
  /* HELPER FUNCTIONS USING STATES */
  function resetTableStatesForInitialization() {
    try {
      setSchedulingTableOffset(0);
      setCustomCellColor(null);
      resetAllSelectedRows();
      resetSecondaryTableStates();
      resetUndoRedoStacks();
    } catch (error) {
      throw error;
    }
  }

  function resetAllSelectedRows() {
    setSchedulingTableSelectedRows([]);
    setLeftClickedSchTableRow(null);
    setSecondaryTableSelectedRows([]);
    setLeftClickedSecTableRow(null);
  }

  function resetSecondaryTableStates() {
    setSecondaryTableName(null);
    setSecondaryTableType(null);
    setSecondaryTableData([]);
    setSecondaryTableOffset(0);
    setSecondaryTableManagedColumns({
      originalColumns: [],
      visibleColumns: [],
      removedColumns: [],
    });
    setSecTableToolbarState(DEFAULT_SEC_TABLE_TOOLBAR_STATE);
    setSecondaryTableSelectedRows([]);
    setLeftClickedSecTableRow(null);
    setRotationInfoTableSelectedRows([]);
    secondaryTableRef.current = null;
  }

  function resetUndoRedoStacks() {
    setUndoStack([]);
    setRedoStack([]);
  }

  function updateUndoRedoStacksForNewOperation() {
    setUndoStack((prevState) => [
      ...prevState,
      {
        schedulingTableData: [...schedulingTableData],
        secondaryTableData: [...secondaryTableData],
        dropBucket: Array.isArray(dropBucket)
          ? [...dropBucket]
          : prevState.length > 0 && [prevState.length - 1].dropBucket
            ? [prevState.length - 1].dropBucket
            : null,
        schTableSelectedFilters: [...schTableSelectedFilters],
        secTableSelectedFilters: [...secTableSelectedFilters],
        customCellColor: { ...customCellColor },
      },
    ]);
    setRedoStack([]);
  }

  function maintainScrolledOffsetOfTables() {
    try {
      setSchedulingTableOffset(getTableScrolledOffset(schedulingTableRef));
      setSecondaryTableOffset(getTableScrolledOffset(secondaryTableRef));
    } catch (error) {
      throw error;
    }
  }

  function resetPage() {
    setDate(null);
    setFeaturesList(null);
    setActiveFeatures(null);
    /* UNSAVED WORK STATES */
    setLoadUnsavedWork(false);
    setUnsavedWorkState(null);
    setUpdateSchedulerStateInRedux(false);
    /* SCHEDULING TABLE STATES */
    setSchedulingTableName(null);
    setSchedulingTableData([]);
    setSchedulingTableOffset(0);
    setSchedulingTableManagedColumns({
      originalColumns: [],
      visibleColumns: [],
      removedColumns: [],
    });
    setSchedulingTableSelectedRows([]);
    setLeftClickedSchTableRow(null);
    setSchTableSelectedFilters([]);
    /* SECONDARY TABLE STATES */
    setSecondaryTableName(null);
    setSecondaryTableType(null);
    setSecondaryTableData([]);
    setSecondaryTableOffset(0);
    setSecondaryTableManagedColumns({
      originalColumns: [],
      visibleColumns: [],
      removedColumns: [],
    });
    setSecTableToolbarState(DEFAULT_SEC_TABLE_TOOLBAR_STATE);
    setSecondaryTableSelectedRows([]);
    setLeftClickedSecTableRow(null);
    setSecTableSelectedFilters([]);
    /* DROP BUCKET STATE */
    setDropBucket([]);
    /* LAST MINUTE SPOTS STATE */
    setLastMinuteSpots([]);
    /* UNDO/REDO */
    setUndoStack([]);
    setRedoStack([]);
    /* ROTATION INFO */
    setRotationInfoTableSelectedRows([]);
    /* UI STATES */
    setStartTime('');
    setShowLoader(false);
    setCustomCellColor(null);
    schedulingTableRef.current = null;
    secondaryTableRef.current = null;
  }

  /* CONTEXT EXPORT */
  return (
    <SchedulerContext.Provider
      value={{
        page,
        date,
        featuresList,
        activeFeatures,
        loadUnsavedWork,
        unsavedWorkState,
        updateSchedulerStateInRedux,
        schedulingTableName,
        schedulingTableData,
        schedulingTableOffset,
        schedulingTableManagedColumns,
        schedulingTableSelectedRows,
        leftClickedSchTableRow,
        schTableSelectedFilters,
        dropBucket,
        lastMinuteSpots,
        secondaryTableName,
        secondaryTableType,
        secondaryTableData,
        secondaryTableOffset,
        secondaryTableManagedColumns,
        secondaryTableSelectedRows,
        leftClickedSecTableRow,
        secTableSelectedFilters,
        startTime,
        undoStack,
        redoStack,
        schedulingTableRef,
        secondaryTableRef,
        secondaryAreaZindexRef,
        secTableToolbarState,
        rotationInfoTableSelectedRows,
        showLoader,
        customCellColor,
        isScheduleAllowedToEdit,
        promoTypeOptions,
        songTypeOptions,
        ntcTypeOptions,
        setPage,
        setDate,
        setFeaturesList,
        setActiveFeatures,
        setLoadUnsavedWork,
        setUnsavedWorkState,
        setUpdateSchedulerStateInRedux,
        setSchedulingTableName,
        setSchedulingTableData,
        setSchedulingTableOffset,
        setSchedulingTableManagedColumns,
        setSchedulingTableSelectedRows,
        setLeftClickedSchTableRow,
        setSchTableSelectedFilters,
        setSecondaryTableName,
        setSecondaryTableType,
        setSecondaryTableData,
        setSecondaryTableOffset,
        setSecondaryTableManagedColumns,
        setSecondaryTableSelectedRows,
        setLeftClickedSecTableRow,
        setSecTableSelectedFilters,
        setStartTime,
        setDropBucket,
        setLastMinuteSpots,
        setUndoStack,
        setRedoStack,
        setSecTableToolbarState,
        setRotationInfoTableSelectedRows,
        setShowLoader,
        setCustomCellColor,
        setIsScheduleAllowedToEdit,
        setPromoTypeOptions,
        setSongTypeOptions,
        setNtcTypeOptions,
        executeOperation,
        resetAllSelectedRows,
        resetSecondaryTableStates,
        resetUndoRedoStacks,
        maintainScrolledOffsetOfTables,
        resetPage,
      }}
    >
      {children}
    </SchedulerContext.Provider>
  );
};

export default SchedulerContextProvider;
