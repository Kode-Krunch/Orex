import React, { useEffect, useState } from 'react';
import { Button, Dialog, InputGroup, Select, Tooltip } from 'components/ui';
import {
  EMERALD_500_50,
  GRAY_300,
} from 'views/Controls/Dashboard/constants/tw_colors';
import {
  getUniqueObjects,
  isJSONArrayEqual,
  openNotification,
} from 'views/Controls/GLOBALFUNACTION';
import {
  apiTeamMappingCreate,
  apigeneventcontent,
} from 'services/SchedulingService';
import { StickyFooter } from 'components/shared';
import { MdOutlineEdit } from 'react-icons/md';
import WarningDialog from 'views/Controls/WarningDialog';
import { apiCallstoreprocedure } from 'services/CommonService';
import ReportsTable from 'views/Controls/ReportsTable/ReportsTable';
import { apiGetEventMasterDetails } from 'services/ProgrammingService';
import { IoMdTrash } from 'react-icons/io';
import {
  AiOutlinePlusCircle,
  AiOutlineSave,
  AiOutlineTrophy,
} from 'react-icons/ai';
import { VscWand } from 'react-icons/vsc';

/* CONSTANTS */
const TABLE_COLUMNS = [
  {
    header: 'Group',
    accessorKey: 'groupname',
  },
  {
    header: 'Match',
    accessorKey: 'teamname1',
    cell: ({ cell, row }) => {
      return (
        <div className="flex items-center gap-2">
          <img
            src={row.original.Team_Image1}
            style={{ height: '25px', width: 'auto' }}
          ></img>
          {row.original.teamname1}
        </div>
      );
    },
    options: {
      header: {
        style: {
          borderRight: false,
          width: '10%',
        },
      },
      cell: {
        style: {
          borderRight: false,
        },
      },
    },
  },
  {
    header: '',
    id: 'vs',
    cell: () => {
      return <>vs</>;
    },
    options: {
      header: {
        sort: false,
        filter: false,
        style: {
          borderRight: false,
          borderLeft: false,
          width: '0%',
        },
      },
      cell: {
        style: {
          borderRight: false,
          borderLeft: false,
        },
      },
    },
  },
  {
    header: '',
    id: 'team2',
    accessorKey: 'teamname2',
    cell: ({ cell, row }) => {
      return (
        <div className="flex items-center gap-2">
          <img
            src={row.original.Team_Image2}
            style={{ height: '25px', width: 'auto' }}
          ></img>
          {row.original.teamname2}
        </div>
      );
    },
    options: {
      header: {
        sort: false,
        filter: false,
        style: {
          borderLeft: false,
          width: '30%',
        },
      },
      cell: {
        style: {
          borderLeft: false,
        },
      },
    },
  },
];

const TOOLBAR_OPTIONS = { groupBy: true, manageColumns: false };

function TeamMapping({ channel, resetPage, eventDetails, setShowLoader }) {
  /* STATES */
  const [originalTeamMappings, setOriginalTeamMappings] = useState([]);
  const [teamMappings, setTeamMappings] = useState([]);
  const [eventGroupOptions, setEventGroupOptions] = useState([]);
  const [team1SelectorOptions, setTeam1SelectorOptions] = useState([]);


  const [team2SelectorOptions, setTeam2SelectorOptions] = useState([]);
  const [selectedEventGroup, setSelectedEventGroup] = useState(null);
  const [selectedTeam1, setSelectedTeam1] = useState(null);
  const [selectedTeam2, setSelectedTeam2] = useState(null);

  const [selectedRowIndex, setSelectedRowIndex] = useState(null);
  const [selectedRowData, setSelectedRowData] = useState(null);
  const [managedColumns, setManagedColumns] = useState([]);
  const [originalMissedDataColumns] = useState(getTableColumnsWithActions());
  const [dataFetchedFromDB, setDataFetchedFromDB] = useState(false);
  // UI States
  const [isAddNewMatchClicked, setIsAddNewMatchClicked] = useState(false);
  const [isAddEditMatchDialogOpen, setIsAddEditMatchDialogOpen] =
    useState(false);
  const [isAddSameMatchDialogOpen, setIsAddSameMatchDialogOpen] =
    useState(false);
  const [isDeleteMatchDialogOpen, setIsDeleteMatchDialogOpen] = useState(false);
  const [isResetChangesDialogOpen, setIsResetChangesDialogOpen] =
    useState(false);
  const [isGenerateMatchesDialogOpen, setIsGenerateMatchesDialogOpen] =
    useState(false);
  const [stickyFooterBtnState, setStickyFooterState] = useState({
    save: false,
    reset: false,
    generateProgram: false,
  });

  /* USE EFFECTS */
  useEffect(() => {
    (async () => {
      if (eventDetails) {
        setGroupSelectorFromAPI();
        setTeamMappingsFromSP();
      }
    })();
  }, [eventDetails]);

  useEffect(() => {
    try {
      if (!selectedTeam1 || !team1SelectorOptions) return;
      const team2SelectorOptions = [];
      team1SelectorOptions.forEach((curTeam) => {
        if (curTeam.value !== selectedTeam1.value) {
          team2SelectorOptions.push(curTeam);
        }
      });
      setTeam2SelectorOptions(team2SelectorOptions);
      if (selectedTeam1.value === selectedTeam2.value) {
        setSelectedTeam2(null);
      }
    } catch (error) {
      console.error(error);
    }
  }, [selectedTeam1, team1SelectorOptions]);

  useEffect(() => {
    try {
      if (dataFetchedFromDB) {
        if (isJSONArrayEqual(teamMappings, originalTeamMappings)) {
          setStickyFooterState((oldState) => ({
            ...oldState,
            save: false,
            reset: false,
            generateProgram: true,
          }));
        } else {
          setStickyFooterState((oldState) => ({
            ...oldState,
            save: true,
            reset: true,
            generateProgram: false,
          }));
        }
      } else {
        setStickyFooterState((oldState) => ({
          ...oldState,
          save: true,
          reset: true,
          generateProgram: false,
        }));
      }
    } catch (error) {
      console.error(error);
    }
  }, [teamMappings, originalTeamMappings, dataFetchedFromDB]);

  /* EVENT HANDLERS */
  const resetAddEditMatchDialogStates = () => {
    try {
      setSelectedEventGroup(null);
      setSelectedTeam1(null);
      setSelectedTeam2(null);
      setSelectedRowIndex(null);
      setSelectedRowData(null);
      setIsAddNewMatchClicked(false);
      setIsAddEditMatchDialogOpen(false);
    } catch (error) {
      console.error(error);
    }
  };

  const isMatchAlreadyExists = (teamMappings, group, team1, team2) => {
    try {
      for (let index = 0; index < teamMappings.length; index++) {
        const match = teamMappings[index];
        if (
          (match.team1 === team1 &&
            match.team2 === team2 &&
            match.groupCode === group) ||
          (match.team1 === team2 &&
            match.team2 === team1 &&
            match.groupCode === group)
        ) {
          return true;
        }
      }
      return false;
    } catch (error) {
      throw error;
    }
  };

  const onAddEditDialogSubmit = () => {
    if (
      isMatchAlreadyExists(
        teamMappings,
        isAddNewMatchClicked
          ? selectedEventGroup.value
          : selectedRowData.groupCode,
        selectedTeam1.value,
        selectedTeam2.value,
      )
    ) {
      setIsAddSameMatchDialogOpen(true);
    } else {
      addEditMatch();
    }
  };

  const handleRowEditClick = (rowIndex, rowData) => {
    try {
      setSelectedRowIndex(rowIndex);
      setSelectedRowData(rowData);
      setSelectedTeam1({
        label: rowData.teamname1,
        value: rowData.team1,
        teamImage: rowData.Team_Image1,
      });
      setSelectedTeam2({
        label: rowData.teamname2,
        value: rowData.team2,
        teamImage: rowData.Team_Image2,
      });
      setIsAddEditMatchDialogOpen(true);
    } catch (error) {
      console.error(error);
    }
  };

  const handleRowDeleteClick = (rowIndex, rowData) => {
    try {
      setIsDeleteMatchDialogOpen(true);
      setSelectedRowIndex(rowIndex);
      setSelectedRowData(rowData);
    } catch (error) {
      console.error(error);
    }
  };

  const handleDelete = () => {
    try {
      const updatedTeamMappings = [...teamMappings];
      updatedTeamMappings.splice(selectedRowIndex, 1);
      setTeamMappings(updatedTeamMappings);
      handleCloseDeleteDialog();
    } catch (error) {
      console.error(error);
    }
  };

  const handleCloseDeleteDialog = () => {
    try {
      setSelectedRowIndex(null);
      setSelectedRowData(null);
      setIsDeleteMatchDialogOpen(false);
    } catch (error) {
      console.error(error);
    }
  };

  const handleSaveTeamMapping = async () => {
    try {
      setShowLoader(true);
      const data = teamMappings.map((item) => ({
        EventCode: eventDetails.EventCode,
        GroupCode: item.GroupCode,
        Team_1: item.team1,
        Team_2: item.team2,
      }));
      const response = await apiTeamMappingCreate(data);
      if (response.status == 200) {
        openNotification('success', 'Data Saved Successfully.');
        setIsGenerateMatchesDialogOpen(true);
      } else {
        openNotification('danger', 'Something went wrong while saving matches');
      }
      setShowLoader(false);
    } catch (error) {
      openNotification('danger', 'Something went wrong while saving matches');
      setShowLoader(false);
    }
  };

  const handleGenerateProgram = async () => {
    try {
      setShowLoader(true);
      const data = teamMappings.map((item) => ({
        ContentCode: eventDetails.ContentMaster.ContentCode,
        ContentName: `${item.teamname1} vs ${item.teamname2}`,
        EventCode: eventDetails.EventCode,
        IsActive: 1,
        LocationCode: channel.LocationCode,
        ChannelCode: channel.ChannelCode,
      }));
      const resp = await apigeneventcontent(data);
      if (resp.status == 200) {
        openNotification('success', 'Program generated successfully');
        setIsGenerateMatchesDialogOpen(false);
        resetPage();
      } else {
        openNotification(
          'danger',
          `Something went wrong while generating program. Server responded with status code ${resp.status}`,
        );
      }
      setShowLoader(false);
    } catch (error) {
      openNotification(
        'danger',
        'Something went wrong while generating program',
      );
      setShowLoader(false);
    }
  };

  const handleResetChanges = () => {
    try {
      setTeamMappings(originalTeamMappings);
      setIsResetChangesDialogOpen(false);
    } catch (error) {
      console.error(error);
    }
  };

  /* HELPER FUNCTIONS */
  const setGroupSelectorFromAPI = async () => {
    try {
      setShowLoader(true);
      const response = await apiGetEventMasterDetails(eventDetails.EventCode);
      if (response.status === 200) {
        const groupOptions = getUniqueObjects(response.data, 'GroupCode').map(
          (group) => {
            return {
              label: group.GroupName,
              value: group.GroupCode,
            };
          },
        );
        setEventGroupOptions(groupOptions);
      } else if (response.status === 204) {
        setEventGroupOptions([]);
      } else {
        openNotification(
          'danger',
          `Unable to fetch available groups. Server responsed with status code ${response.status}`,
        );
      }
      setShowLoader(false);
    } catch (error) {
      setShowLoader(false);
      throw error;
    }
  };

  const setTeamMappingsFromSP = async () => {
    try {
      setShowLoader(true);
      const response = await apiCallstoreprocedure('USP_Get_ViewMatches', {
        eventcode: eventDetails.EventCode,
      });
      if (response.status === 200) {
        if (response.data.length > 0) {
          setTeamMappings(response.data);
          setOriginalTeamMappings(response.data);
          const team1SelectorOptions = getTeam1SelectorOptions(response.data);
          setTeam1SelectorOptions(team1SelectorOptions);
          setDataFetchedFromDB(true);
        } else {
          setTeamMappingsFromGenerateEventMatchesSP();
        }
      } else if (response.status === 204) {
        setTeamMappingsFromGenerateEventMatchesSP();
      } else {
        openNotification(
          'danger',
          `Unable to fetch matches. Server responded with status code ${response.status}`,
        );
      }
      setShowLoader(false);
    } catch (error) {
      setShowLoader(false);
      throw error;
    }
  };

  const getTeam1SelectorOptions = (teamMappings) => {
    try {
      const team1SelectorOptions = new Map();
      teamMappings.forEach((match) => {
        team1SelectorOptions.set(match.team1, {
          value: match.team1,
          label: match.teamname1,
          teamImage: match.Team_Image1,
        });
        team1SelectorOptions.set(match.team2, {
          value: match.team2,
          label: match.teamname2,
          teamImage: match.Team_Image2,
        });
      });
      return Array.from(team1SelectorOptions.values());
    } catch (error) {
      console.error(error);
    }
  };

  const setTeamMappingsFromGenerateEventMatchesSP = async () => {
    try {
      setShowLoader(true);
      const response = await apiCallstoreprocedure('GenrateEventMatches', {
        eventcode: eventDetails.EventCode,
      });
      if (response.status === 200) {
        setTeamMappings(response.data);
        setOriginalTeamMappings(response.data);
        const team1SelectorOptions = getTeam1SelectorOptions(response.data);
        setTeam1SelectorOptions(team1SelectorOptions);
      } else if (response.status === 204) {
        setTeamMappings([]);
        setOriginalTeamMappings([]);
      } else {
        openNotification(
          'danger',
          `Unable to generate matches. Server responded with status code ${response.status}`,
        );
      }
      setShowLoader(false);
    } catch (error) {
      setShowLoader(false);
      throw error;
    }
  };

  const addEditMatch = () => {
    if (isAddNewMatchClicked) {
      const updatedRow = {
        ...selectedRowData,
        GroupCode: selectedEventGroup.value,
        groupname: selectedEventGroup.label,
        team1: selectedTeam1.value,
        teamname1: selectedTeam1.label,
        Team_Image1: selectedTeam1.teamImage,
        team2: selectedTeam2.value,
        teamname2: selectedTeam2.label,
        Team_Image2: selectedTeam2.teamImage,
        bgColor: EMERALD_500_50,
        fontColor: 'white',
      };
      setTeamMappings([updatedRow, ...teamMappings]);
    } else {
      setTeamMappings((oldState) => {
        const newState = [...oldState];
        if (selectedRowIndex !== undefined && selectedRowData) {
          const updatedRow = {
            ...selectedRowData,
            team1: selectedTeam1.value,
            teamname1: selectedTeam1.label,
            Team_Image1: selectedTeam1.teamImage,
            team2: selectedTeam2.value,
            teamname2: selectedTeam2.label,
            Team_Image2: selectedTeam2.teamImage,
            bgColor: EMERALD_500_50,
            fontColor: 'white',
          };
          newState[selectedRowIndex] = updatedRow;
        }

        return newState;
      });
    }
    resetAddEditMatchDialogStates();
  };

  function getTableColumnsWithActions() {
    try {
      return [
        ...TABLE_COLUMNS,
        {
          header: 'Action',
          accessorKey: 'action',
          actions: [
            {
              action: (rowIndex, rowData) => (
                <Tooltip title="Edit Match" key={rowIndex} wrapperClass="my-1">
                  <Button
                    size="xs"
                    icon={<MdOutlineEdit color={GRAY_300} />}
                    onClick={() => handleRowEditClick(rowIndex, rowData)}
                  />
                </Tooltip>
              ),
            },
            {
              action: (rowIndex, rowData) => (
                <Tooltip
                  title="Remove Match"
                  key={rowIndex}
                  wrapperClass="my-1"
                >
                  <Button
                    size="xs"
                    icon={<IoMdTrash color={GRAY_300} />}
                    onClick={() => handleRowDeleteClick(rowIndex, rowData)}
                  />
                </Tooltip>
              ),
            },
          ],
        },
      ];
    } catch (error) {
      console.error(error);
    }
  }

  return (
    <>
      <div className="mb-4 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <div className="rounded-full h-10 w-10 border-[1.5px] border-gray-600 p-1 flex items-center justify-center bg-gray-700">
            <AiOutlineTrophy size={20} className="text-gray-400" />
          </div>
          <div className="flex flex-col">
            <p className="text-base font-semibold text-gray-300 flex items-center">
              {eventDetails.EventName}
            </p>
            <p>{teamMappings.length} Matches</p>
          </div>
        </div>
        <Button
          size="sm"
          variant="solid"
          icon={<AiOutlinePlusCircle />}
          onClick={() => {
            setIsAddNewMatchClicked(true);
            setIsAddEditMatchDialogOpen(true);
          }}
        >
          Add New Matches
        </Button>
      </div>
      {Array.isArray(teamMappings) && teamMappings.length > 0 ? (
        <ReportsTable
          tableData={teamMappings}
          tableName={'teamMappings'}
          originalColumns={originalMissedDataColumns}
          managedColumns={managedColumns}
          setManagedColumns={setManagedColumns}
          toolbarOptions={TOOLBAR_OPTIONS}
          exportFileName={`${eventDetails.EventName} - Matches`}
        />
      ) : (
        <div className="min-h-full flex justify-center items-center">
          No matches to show
        </div>
      )}
      <Dialog
        isOpen={isAddEditMatchDialogOpen}
        onClose={resetAddEditMatchDialogStates}
        onRequestClose={resetAddEditMatchDialogStates}
      >
        <h5 className="mb-4">
          {isAddNewMatchClicked ? 'New Match' : 'Edit Match'}
        </h5>
        {isAddNewMatchClicked && (
          <div className="flex flex-col gap-1">
            <p className="text-slate-300">
              Event Group <span className="text-red-500">*</span>
            </p>
            <Select
              placeholder="Select"
              size="sm"
              options={eventGroupOptions}
              onChange={(selectedOption) => {
                setSelectedEventGroup(selectedOption);
              }}
            />
          </div>
        )}
        <div className="mt-6 flex flex-col gap-1">
          <p className="text-slate-300">
            Match <span className="text-red-500">*</span>
          </p>
          <InputGroup size="sm">
            <Select
              placeholder="Team 1"
              className="w-full"
              options={team1SelectorOptions}
              value={selectedTeam1 ? selectedTeam1 : ''}
              onChange={(selectedOption) => {
                setSelectedTeam1(selectedOption);
              }}
              isDisabled={isAddNewMatchClicked && !selectedEventGroup}
            />
            <span className="mx-2">vs</span>
            <Select
              placeholder="Team 2"
              className="w-full"
              options={team2SelectorOptions}
              value={selectedTeam2 ? selectedTeam2 : ''}
              onChange={(selectedOption) => {
                setSelectedTeam2(selectedOption);
              }}
              isDisabled={!selectedTeam1}
            />
          </InputGroup>
        </div>
        <div className="text-right mt-8 flex items-center justify-end">
          <Button
            className="ltr:mr-2 rtl:ml-2"
            variant="plain"
            onClick={resetAddEditMatchDialogStates}
          >
            Cancel
          </Button>
          <Button
            variant="solid"
            onClick={onAddEditDialogSubmit}
            disabled={
              isAddNewMatchClicked
                ? !selectedEventGroup || !selectedTeam1 || !selectedTeam2
                : !selectedTeam1 || !selectedTeam2
            }
          >
            {isAddNewMatchClicked ? 'Add' : 'Update'}
          </Button>
        </div>
      </Dialog>
      <StickyFooter
        className="-mx-8 px-8 flex items-center justify-end py-4 mt-4"
        stickyClass="border-t bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700"
      >
        <div className="flex justify-end gap-2">
          {stickyFooterBtnState.reset && (
            <Button
              size="sm"
              variant="plain"
              // onClick={() => setTeamMappings(originalTeamMappings)}
              onClick={() => setIsResetChangesDialogOpen(true)}
            >
              Reset
            </Button>
          )}
          {stickyFooterBtnState.generateProgram && (
            <Button
              size="sm"
              variant="solid"
              onClick={handleGenerateProgram}
              icon={<VscWand />}
            >
              Generate Programs
            </Button>
          )}
          {stickyFooterBtnState.save && (
            <Button
              size="sm"
              variant="solid"
              onClick={handleSaveTeamMapping}
              icon={<AiOutlineSave />}
            >
              Save
            </Button>
          )}
        </div>
      </StickyFooter>
      <WarningDialog
        isDialogOpen={isDeleteMatchDialogOpen}
        title="Delete Match"
        description={`Are you sure you want to delete this match?`}
        submitButtonTitle="Delete"
        handleDialogSubmit={handleDelete}
        handleDialogClose={handleCloseDeleteDialog}
      />
      <WarningDialog
        isDialogOpen={isResetChangesDialogOpen}
        title="Reset Changes"
        description={`Are you sure you want to reset all changes?`}
        submitButtonTitle="Reset"
        handleDialogSubmit={handleResetChanges}
        handleDialogClose={() => setIsResetChangesDialogOpen(false)}
      />
      <WarningDialog
        isDialogOpen={isAddSameMatchDialogOpen}
        title="Match Already Exists"
        description={`Are you sure you want to insert the same match?`}
        submitButtonTitle="Insert"
        handleDialogSubmit={() => {
          addEditMatch();
          setIsAddSameMatchDialogOpen(false);
        }}
        handleDialogClose={() => {
          resetAddEditMatchDialogStates();
          setIsAddSameMatchDialogOpen(false);
        }}
      />
      <WarningDialog
        isDialogOpen={isGenerateMatchesDialogOpen}
        title="Generate Program"
        description={`Do you wish to generate program for all matches?`}
        submitButtonTitle="Generate"
        handleDialogSubmit={handleGenerateProgram}
        handleDialogClose={() => {
          setIsGenerateMatchesDialogOpen(false);
          resetPage();
        }}
      />
    </>
  );
}

export default TeamMapping;
