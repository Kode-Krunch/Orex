import {
  Alert,
  Button,
  Card,
  DatePicker,
  FormContainer,
  FormItem,
  Input,
  Radio,
} from 'components/ui';
import React, { forwardRef, useEffect, useState, useRef } from 'react';
import ChannelSelecttion from 'views/Controls/ChannelSelecttion';
import { StickyFooter } from 'components/shared';
import { PostNTC, PutNTC, apiGetNTCtypedropdown } from 'services/NTCService';
import {
  apiGetChannelmasterdrop,
  apiUSP_GenerateVideoID,
} from 'services/MasterService';
import {
  compareDates,
  formatOnHHMMSSFFBlur,
  handleChangeWithFrameNew,
  openNotification,
} from 'views/Controls/GLOBALFUNACTION';
import { useSelector } from 'react-redux';
import { Toast } from 'primereact/toast';
import { apiGetContentmasterDrop } from 'services/ProgrammingService';
import NTCTypeDrop from 'views/Controls/NTCTypeDrop';
import useTimeOutMessage from 'utils/hooks/useTimeOutMessage';
import { apiGetSongmaster } from 'services/SchedulingService';
import { useNavigate } from 'react-router-dom';
import dayjs from 'dayjs';
import { validate } from 'components/validators';

const NTCMasterEdit = forwardRef((props, ref) => {
  const { Content } = useSelector((state) => state.base.common);
  const Channel = useSelector((state) => state.locale.selectedChannel);
  const navigate = useNavigate();
  const [dateVdaid, setdateVdaid] = useState(true);
  const LoginId = useSelector((state) => state.auth.session.LoginId);
  const token = useSelector((state) => state.auth.session.token);
  const ChannelSetting = useSelector(
    (state) => state.auth.session.ChannelSetting,
  );
  const houseid = async (Id) => {
    // console.log(Object.keys(Channel).length)
    if (Object.keys(Channel).length > 0) {
      if (ChannelSetting[0]?.IsTapeCounterFlag === 1) {
        (async (values) => {
          try {
            const resp = await apiUSP_GenerateVideoID(
              Channel.LocationCode,
              Channel.ChannelCode,
              'NTC Master',
              Id,
              0,
            );
            // console.log(formState.TitleID)
            // console.log(resp.data[0].CommVideoID)
            if (formState.TitleID != resp.data[0].CommVideoID) {
              if (formState.TitleID) {
                setMessage('Title Id Get Changed');
              } else {
                setMessage('Title Id Genrated');
              }
            }
            setFormState((prevFormState) => ({
              ...prevFormState,
              TitleID: resp.data[0].CommVideoID,
            }));
          } catch (error) {
            if (error.response.status == 500) {
              setFormState((prevFormState) => ({
                ...prevFormState,
                TitleID: '',
              }));

              setMessage('Title Id Is Not Config With This Category ');
            }
          }
        })();
      }
    } else {
      setMessage('Please Select Gobal Channal');
    }
  };

  const [formState, setFormState] = useState({
    Layer: Content.Layer ? Content.Layer : '',
    NTCTypeCode: Content.NTCTypeCode ? Number(Content.NTCTypeCode) : null,
    CGType: Content.CGType ? Content.CGType : '',
    SegmentNo: Content.SegmentNo ? Content.SegmentNo : '',
    NTCCaption: Content.NTCCaption ? Content.NTCCaption : '',
    TitleID: Content.TitleID ? Content.TitleID : '',
    NTCDuration: Content.NTCDuration ? Content.NTCDuration : '00:00:00:00',
    NTCDurInSec: Content.NTCDurInSec ? Number(Content.NTCDurInSec) : '',
    StartTime: Content.StartTime ? Content.StartTime : '',
    Synopsis: Content.Synopsis ? Content.Synopsis : '',
    EndTime: Content.EndTime ? Content.EndTime : '',
    Dated: Content.Dated ? Content.Dated : 0,

    KillDate: Content.KillDate ? Content.KillDate : null,
    IS_COMM: Content.IS_COMM ? Content.IS_COMM : null,
    StartDate: Content.StartDate ? Content.StartDate : null,
    CommercialCode: Content.CommercialCode
      ? Number(Content.CommercialCode)
      : null,
    SeasonNo: Content.SeasonNo ? Content.SeasonNo : null,
    EpisodeNo: Content.EpisodeNo ? Content.EpisodeNo : null,
    Contentcode: Content.Contentcode ? Content.Contentcode : null,
    SongCode: Content.SongCode ? Content.SongCode : null,
    IsActive: 1,
  });
  const handleBlur = (event) => {
    const { name, value } = event.target;
    const formattedValue = formatOnHHMMSSFFBlur(value);
    setFormState((prevFormState) => ({
      ...prevFormState,
      [name]: formattedValue,
    }));
  };

  const toast = useRef(null);
  const [NTCtype, setNTCtype] = useState([]);
  const [Songs, setSongs] = useState([]);
  const [ContentList, setContentList] = useState([]);
  const [channelList, setChannelList] = useState([]);
  const [selectedchannel, setSelectedchannel] = useState(
    Content.details
      ? Content.details.map((item, index) => ({
        id: index,
        LocationCode: item.LocationCode,
        ChannelCode: item.ChannelCode,
      }))
      : [Channel].map((item, i) => ({
        id: i,
        LocationCode: item.LocationCode,
        ChannelName: item.label,
        ChannelCode: item.ChannelCode,
      })),
  );
  const [message, setMessage] = useTimeOutMessage();
  const [log, setlog] = useState('');
  const [value, setValue] = useState(
    Content.SongCode > 0 ? 'Song' : Content.Contentcode > 0 ? 'Content' : null,
  );
  const [value2, setValue2] = useState(
    Content.Dated == 1 ? Number(Content.Dated) : 0,
  );
  const [requiredFields, setRequiredFields] = useState({
    NTCTypeCode: (Content.NTCTypeCode && false) || false,
    NTCCaption: false,
    NTCDuration: false,
  });
  const onChange = (val) => {
    setValue(val);

    setFormState((prevFormState) => ({
      ...prevFormState,
      ['FillerTypeCode']: null,
    }));
  };

  const onChange2 = (val, Dated) => {
    setValue2(val);
    setFormState((prevFormState) => ({
      ...prevFormState,
      [Dated]: val == null ? value2 : val,
    }));
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;

    // Check if the length is not more than 5 characters
    if (value.length <= 50) {
      setFormState((prevFormState) => ({
        ...prevFormState,
        [name]: value,
      }));
    }
  };
  const handleInputChange1 = (e) => {
    const { name, value } = e.target;

    // Check if the length is not more than 5 characters
    if (value.length <= 100) {
      setFormState((prevFormState) => ({
        ...prevFormState,
        [name]: value,
      }));
    }
  };
  const dateGap = 30;
  const minDate = dayjs(new Date())
    .subtract(dateGap, 'day')
    .startOf('day')
    .toDate();

  const maxDate = dayjs(new Date()).add(dateGap, 'day').toDate();
  useEffect(() => {
    (async (values) => {
      const NTCtype = await apiGetNTCtypedropdown(values);

      const formattedOptions = NTCtype.data.map((option) => ({
        value: Number(option.NTCTypeCode),
        label: option.NTCTypeName,
      }));
      setNTCtype(formattedOptions);
    })();
    (async (values) => {
      let Parameters = {
        LocationCode: Channel.LocationCode,
        ChannelCode: Channel.ChannelCode,
      };
      const Songs = await apiGetSongmaster(Parameters);
      console.log(Songs);
      const formattedOptions = Songs.data.map((option) => ({
        value: option.SongCode,
        label: option.SongCaption,
      }));
      setSongs(formattedOptions);
    })();
    (async (values) => {
      const Content = await apiGetContentmasterDrop(
        undefined,
        Channel.LocationCode,
        Channel.ChannelCode,
        0,
      );

      const formattedOptions = Content.data.map((option) => ({
        value: option.ContentCode,
        label: option.ContentName,
      }));
      setContentList(formattedOptions);
    })();
    (async (values) => {
      const resp = await apiGetChannelmasterdrop(LoginId);
      // console.log(resp.data)
      const channelsBYID = resp.data.map((channel, index) => ({
        id: index,
        ChannelName: channel.ChannelName,
        ChannelCode: channel.ChannelCode,
        // ColorClass: colorClasses[index % colorClasses.length],
        LocationCode: channel.LocationCode,
        LocationName: channel.LocationName,
      }));
      setChannelList(channelsBYID);
    })();
  }, []);

  const handleInputChange2 = (value, name) => {
    setFormState((prevFormState) => ({
      ...prevFormState,
      [name]: value,
    }));
  };

  const checkFieldsNotEmpty = (formState, requiredFields) => {
    const emptyFields = [];

    for (const field of requiredFields) {
      if (!formState[field]) {
        emptyFields.push(field);
      }
    }

    return emptyFields;
  };
  const apiadd = async () => {
    // console.log(formState.NTCTypeCode);

    seti(2);
    if (selectedchannel.length > 0) {
      const emptyFields = checkFieldsNotEmpty(
        formState,
        Object.keys(requiredFields),
      );
      if (emptyFields.length === 0) {
        console.log('All required fields are not empty.');
        const mergedData = {
          request: {
            LocationCode: Channel.LocationCode,
            ChannelCode: Channel.ChannelCode,
            NTCDuration: formState.NTCDuration,
            Layer: formState.Layer,
            NTCTypeCode: Number(formState.NTCTypeCode),
            CGType: formState.CGType,
            TitleID: formState.TitleID,
            NTCCaption: formState.NTCCaption,
            NTCDurInSec: Number(formState.NTCDurInSec),
            Synopsis: formState.Synopsis,
            StartTime: formState.StartTime,
            EndTime: formState.EndTime,
            Dated: formState.Dated,
            KillDate: formState.KillDate,
            IS_COMM: Number(formState.IS_COMM),
            StartDate: formState.StartDate,
            CommercialCode: 0,
            SeasonNo: formState.SeasonNo,
            EpisodeNo: formState.EpisodeNo,
            SegmentNo: formState.SegmentNo,
            SongCode: Number(formState.SongCode),
            Contentcode: Number(formState.Contentcode),
            IsActive: 1,
          },
          details: selectedchannel.map((item) => ({
            LocationCode: item.LocationCode,
            ChannelCode: item.ChannelCode,
          })),
          genvideoId: {
            LocationCode: Channel.LocationCode,
            ChannelCode: Channel.ChannelCode,
            FormName: 'NTC Master',
            EventTypeCode: Number(formState.NTCTypeCode),
            Mode: 1,
          },
        };

        if (value == 'Song') {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.Contentcode;
          delete mergedData.request.SeasonNo;
          delete mergedData.request.EpisodeNo;
          delete mergedData.request.SegmentNo;
        }
        if (value == 'Content') {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.SongCode;
        }
        if (value == null) {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.Contentcode;
          delete mergedData.request.SeasonNo;
          delete mergedData.request.EpisodeNo;
          delete mergedData.request.SegmentNo;
        }
        if (value2 == 0) {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.StartDate;
          delete mergedData.request.KillDate;
          delete mergedData.request.StartTime;
          delete mergedData.request.EndTime;
        }

        if (value2 == null) {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.StartDate;
          delete mergedData.request.KillDate;
          delete mergedData.request.StartTime;
          delete mergedData.request.EndTime;
        }
        try {
          // console.log('mergedData', mergedData)
          const resp = await PostNTC(mergedData, token);

          // console.log(resp.status);
          if (resp.status == 200) {
            setTimeout(() => navigate('/NTCMaster'), 500);
            setlog('success');

            openNotification('success', 'Data Added Successfully');
          }
          if (resp.status === 204) {
            openNotification('danger', 'Data Already Exists.');
            return;
          }
        } catch (errors) {
          if (errors.response.status == 500) {
            // setTimeout(() => navigate('/NTCMaster'), 500);

            openNotification('danger', 'Server Error.');
          }
        }
      } else {
        console.log('Some required fields are empty:', emptyFields);

        // Display popups for each empty field
        emptyFields.forEach((field) => {
          setRequiredFields((prevRequiredFields) => ({
            ...prevRequiredFields,
            [field]: true,
          }));
        });
      }
    } else {
      // console.log('jjj')
      setlog('danger');
      setMessage('Kindly Select Channel ');
    }
  };
  const apiUpdate = async () => {
    seti(2);

    if (selectedchannel.length > 0) {
      const emptyFields = checkFieldsNotEmpty(
        formState,
        Object.keys(requiredFields),
      );
      if (emptyFields.length === 0) {
        const mergedData = {
          request: {
            LocationCode: Channel.LocationCode,
            ChannelCode: Channel.ChannelCode,
            NTCDuration: formState.NTCDuration,
            Layer: formState.Layer,
            NTCTypeCode: Number(Content.NTCTypeCode),
            CGType: formState.CGType,
            TitleID: formState.TitleID,
            NTCCaption: formState.NTCCaption,
            NTCDurInSec: Number(formState.NTCDurInSec),
            Synopsis: formState.Synopsis,
            StartTime: formState.StartTime,
            EndTime: formState.EndTime,
            Dated: formState.Dated,
            KillDate: formState.KillDate,
            IS_COMM: Number(formState.IS_COMM),
            StartDate: formState.StartDate,
            CommercialCode: 0,
            SeasonNo: formState.SeasonNo,
            EpisodeNo: formState.EpisodeNo,
            SegmentNo: formState.SegmentNo,
            SongCode: Number(formState.SongCode),
            Contentcode: Number(formState.Contentcode),
            IsActive: 1,
          },
          details: selectedchannel.map((item) => ({
            LocationCode: item.LocationCode,
            ChannelCode: item.ChannelCode,
          })),
          genvideoId: {
            LocationCode: Channel.LocationCode,
            ChannelCode: Channel.ChannelCode,
            FormName: 'NTC Master',
            EventTypeCode: Number(formState.NTCTypeCode),
            Mode: 1,
          },
        };
        if (value == 'Song') {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.Contentcode;
          delete mergedData.request.SeasonNo;
          delete mergedData.request.EpisodeNo;
          delete mergedData.request.SegmentNo;
        }
        if (value == 'Content') {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.SongCode;
        }
        if (value == null) {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.Contentcode;
          delete mergedData.request.SeasonNo;
          delete mergedData.request.EpisodeNo;
          delete mergedData.request.SegmentNo;
        }
        if (value2 == 0) {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.StartDate;
          delete mergedData.request.KillDate;
          delete mergedData.request.StartTime;
          delete mergedData.request.EndTime;
        }

        if (value2 == null) {
          // If Rating is blank, remove it from the SongMaster object
          delete mergedData.request.StartDate;
          delete mergedData.request.KillDate;
          delete mergedData.request.StartTime;
          delete mergedData.request.EndTime;
        }
        try {
          const resp = await PutNTC(mergedData, Content.NTCCode, token);
          if (resp.status == 200) {
            setTimeout(() => navigate('/NTCMaster'), 500);
            openNotification('success', 'Data Updated Successfully');
          }
          if (resp.status === 204) {
            openNotification('danger', 'Data Already Exists.');
            return;
          }
        } catch (errors) {
          if (errors.response.status == 500) {
            openNotification('danger', 'Server Error.');
          }
        }
      } else {
        // Display popups for each empty field
        emptyFields.forEach((field) => {
          setRequiredFields((prevRequiredFields) => ({
            ...prevRequiredFields,
            [field]: true,
          }));
        });
      }
    } else {
      setlog('danger');
      setMessage('Kindly Select Channel ');
    }
  };

  const validateFields = () => {
    Object.keys(formState).forEach((field) => {
      setRequiredFields((prevRequiredFields) => ({
        ...prevRequiredFields,
        [field]: !formState[field], // true if the field is empty, false otherwise
      }));
    });
  };

  const [i, seti] = useState(0);
  useEffect(() => {
    if (i > 1) {
      validateFields();
    }
  }, [formState]);
  return (
    <Card header={Content.NTCCode ? 'Edit NTC' : 'Add NTC'}>
      {message && (
        <Alert className="mb-4" type={log} showIcon>
          {message}
        </Alert>
      )}

      <Toast ref={toast} />
      <FormContainer>
        <div className="grid grid-cols-3 gap-4">
          <div className="col-span-2 ">
            <div className="grid grid-cols-9 gap-2 mb-5">
              <div className="col-span-3">
                <FormItem
                  label="NTC Type"
                  asterisk
                  errorMessage={
                    requiredFields.NTCTypeCode ? 'NTCType Required' : null
                  }
                  invalid={
                    requiredFields.NTCTypeCode && requiredFields.NTCTypeCode
                  }
                >
                  <NTCTypeDrop
                    selected={formState.NTCTypeCode}
                    setSelected={setFormState}
                    List={NTCtype}
                    name="NTCTypeCode"
                    handlePromoTypeChange={houseid}
                    disabled={Content.NTCTypeCode > 0 ? true : false}
                  />
                </FormItem>
              </div>
              <div className="col-span-6">
                <FormItem
                  label=" NTC Caption"
                  asterisk
                  errorMessage={
                    requiredFields.NTCCaption ? 'NTC Caption Required' : null
                  }
                  invalid={
                    requiredFields.NTCCaption && requiredFields.NTCCaption
                  }
                >
                  <Input
                    size="sm"
                    placeholder="NTC Caption"
                    name="NTCCaption"
                    maxLength="50"
                    value={formState.NTCCaption}
                    onChange={handleInputChange}
                  />
                </FormItem>
              </div>
              <div className="col-span-3">
                <FormItem label="Title Id" asterisk>
                  <Input
                    size="sm"
                    placeholder="Title Id"
                    name="TitleID"
                    disabled
                    value={formState.TitleID}
                    onChange={handleInputChange}
                  />
                </FormItem>
              </div>
              <div className="col-span-3">
                <FormItem
                  label="Duration"
                  asterisk
                  errorMessage={
                    requiredFields.NTCDuration ? 'NTC Duration Required' : null
                  }
                  invalid={
                    requiredFields.NTCDuration && requiredFields.NTCDuration
                  }
                >
                  <Input
                    size="sm"
                    placeholder="Duration"
                    name="NTCDuration"
                    value={formState.NTCDuration}
                    onChange={(e) => handleChangeWithFrameNew(e, setFormState)}
                    onBlur={handleBlur}
                  />
                </FormItem>
              </div>

              <div className="col-span-3">
                <FormItem label="Description">
                  <Input
                    size="sm"
                    name="Synopsis"
                    maxLength="100"
                    value={formState.Synopsis}
                    onChange={handleInputChange1}
                  />
                </FormItem>
              </div>

              <div className="col-span-3">
                <Radio.Group
                  className="mt-5"
                  value={value}
                  onChange={(e) => onChange(e)}
                >
                  <Radio value={'Song'}>Song</Radio>
                  <Radio value={'Content'}>Content</Radio>
                  <Radio value={null}>Blank</Radio>
                </Radio.Group>
              </div>
              {value === 'Song' ? (
                <div className="col-span-6">
                  <FormItem label="Song" asterisk>
                    <NTCTypeDrop
                      selected={formState.SongCode}
                      setSelected={setFormState}
                      List={Songs}
                      name="SongCode"
                    />
                  </FormItem>
                </div>
              ) : value === 'Content' ? (
                <div className="col-span-6">
                  <FormItem label="Content" asterisk>
                    <NTCTypeDrop
                      selected={formState.Contentcode}
                      setSelected={setFormState}
                      List={ContentList}
                      name="Contentcode"
                    />
                  </FormItem>
                </div>
              ) : null}

              {value === 'Song' ? null : value === 'Content' ? (
                <>
                  <div className="col-span-3">
                    <FormItem label="Season No" asterisk>
                      <Input
                        size="sm"
                        placeholder="Season No"
                        type="number"
                        name="SeasonNo"
                        value={formState.SeasonNo}
                        onChange={handleInputChange}
                      />
                    </FormItem>
                  </div>
                  <div className="col-span-3">
                    <FormItem label="Segment No" asterisk>
                      <Input
                        size="sm"
                        placeholder="Segment No"
                        type="number"
                        name="SegmentNo"
                        value={formState.SegmentNo}
                        onChange={handleInputChange}
                      />
                    </FormItem>
                  </div>
                  <div className="col-span-3">
                    <FormItem label="Episode No " asterisk>
                      <Input
                        size="sm"
                        placeholder="Episode No"
                        type="number"
                        name="EpisodeNo"
                        value={formState.EpisodeNo}
                        onChange={handleInputChange}
                      />
                    </FormItem>
                  </div>
                </>
              ) : null}
            </div>
            <Card>
              <div className="grid grid-cols-4 gap-4">
                <div className="col-span-4 ">
                  <Radio.Group
                    className="mt-5"
                    value={value2}
                    onChange={(e) => onChange2(e, 'Dated')}
                  >
                    <Radio value={0}>Non Dated</Radio>
                    <Radio value={1}>Dated</Radio>
                  </Radio.Group>
                </div>
                {value2 == 1 ? (
                  <>
                    <div className="col-span-1 ">
                      <FormItem label="Start Date">
                        <DatePicker
                          size="sm"
                          minDate={minDate}
                          maxDate={maxDate}
                          value={
                            validate(formState.StartDate)
                              ? new Date(formState.StartDate)
                              : formState.StartDate == null
                                ? null
                                : null
                          }
                          onChange={(e) => {
                            handleInputChange2(e, 'StartDate');
                            if (formState.KillDate != null) {
                              const res = compareDates(e, formState.KillDate);
                              setdateVdaid(res);
                              console.log(res);
                            }
                          }}

                        // onBlur={() => compareDatesV()}
                        />
                      </FormItem>
                    </div>
                    <div className="col-span-1 ">
                      <FormItem label="Kill Date">
                        <DatePicker
                          size="sm"
                          value={
                            validate(formState.KillDate)
                              ? new Date(formState.KillDate)
                              : formState.KillDate == null
                                ? null
                                : null
                          }
                          minDate={dayjs(new Date(formState.StartDate))
                            .subtract(0, 'day')
                            .startOf('day')
                            .toDate()}
                          maxDate={maxDate}
                          onChange={(e) => {
                            handleInputChange2(e, 'KillDate');
                            if (formState.StartDate != null) {
                              const res = compareDates(formState.StartDate, e);
                              setdateVdaid(res);
                              console.log(res);
                            }
                          }}
                        // onBlur={() => compareDatesV()}
                        />
                      </FormItem>
                    </div>

                    <div className="col-span-1 ">
                      <FormItem label="Start Time">
                        <Input
                          size="sm"
                          name="StartTime"
                          value={formState.StartTime}
                          onChange={(e) =>
                            handleChangeWithFrameNew(e, setFormState)
                          }
                          onBlur={handleBlur}
                        />
                      </FormItem>
                    </div>
                    <div className="col-span-1 ">
                      <FormItem label="End Time">
                        <Input
                          size="sm"
                          value={formState.EndTime}
                          name="EndTime"
                          onChange={(e) =>
                            handleChangeWithFrameNew(e, setFormState)
                          }
                          onBlur={handleBlur}
                        />
                      </FormItem>
                    </div>
                  </>
                ) : null}
              </div>
            </Card>
          </div>
          <div className="col-span-1">
            <Card>
              <ChannelSelecttion
                List={channelList}
                selectedList={selectedchannel}
                setSelectedList={setSelectedchannel}
              />
            </Card>
          </div>
        </div>
      </FormContainer>
      <StickyFooter
        className="-mx-8 px-8 flex items-center justify-between py-4"
        stickyClass="border-t bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700"
      >
        <div className="md:flex items-center flex">
          {Content.NTCCode ? (
            <Button variant="solid" type="submit" onClick={() => apiUpdate()}>
              Update
            </Button>
          ) : (
            <Button variant="solid" type="submit" onClick={() => apiadd()}>
              Submit
            </Button>
          )}
        </div>
      </StickyFooter>
    </Card>
  );
});

export default NTCMasterEdit;
