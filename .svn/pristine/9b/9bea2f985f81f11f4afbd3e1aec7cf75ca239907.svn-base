import {
  bulkInsertPositionEnum,
  pagesEnum,
  rowDataTypesEnum,
} from 'views/Scheduling/Scheduler/enum';
import { isRowLastSegment, isSegmentValid } from '../../utils';
import { CLIENT } from 'views/Controls/clientListEnum';

function executePromoBulkInsert(
  insertPosition,
  time,
  selectedBreaks,
  isSkipLastBreak,
  selectedRows,
  schedulingTableData,
  channel,
  page,
) {
  let isChannelForbes = channel === CLIENT.USA_Forbes;
  let newSchedulingTableData = [];
  let isCurBlockValid = false;
  for (let index = 0; index < schedulingTableData.length; index++) {
    const row = schedulingTableData[index];
    const nextRow = schedulingTableData[index + 1];
    const isRowSegment = row.F_C_S_P === rowDataTypesEnum.SEGMENT;
    const isRowLive = row.F_C_S_P === rowDataTypesEnum.LIVE;
    // Update the validity of the current segment
    if (row.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION) {
      // Mark the segment as invalid if the row is content termination
      isCurBlockValid = false;
    } else if (isRowSegment) {
      // Validate the segment using the given time and selected breaks
      isCurBlockValid = isSegmentValid(row, time, selectedBreaks);
    } else if (isRowLive) {
      // Validate the live row using the given time and selected breaks
      isCurBlockValid =
        isSegmentValid(row, time, selectedBreaks) && !isChannelForbes;
    }
    // Mark the segment as invalid if isSkipLastBreak === true and row is last segment
    if (isCurBlockValid && isSkipLastBreak)
      isCurBlockValid = !isRowLastSegment(row, schedulingTableData);
    // Perform insertion logic if the current segment is valid
    if (isCurBlockValid) {
      // Case 1: Insert rows at the start of the segment
      if (insertPosition === bulkInsertPositionEnum.START && isRowSegment) {
        // Add the current row and the secondary table's selected rows
        newSchedulingTableData.push(row, ...selectedRows);
        continue; // Move to the next iteration
      }
      // Case 2: Insert rows at the end of the segment
      if (
        insertPosition === bulkInsertPositionEnum.END && // Check if insertion is at the end
        nextRow && // Ensure there is a next row
        (nextRow.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION || // Check if the next row is content termination
          nextRow.F_C_S_P === rowDataTypesEnum.SEGMENT) // Or if it's another segment
      ) {
        // If the current row is a commercial, find the insertion point
        if (
          page === pagesEnum.PROMO &&
          (row.F_C_S_P === rowDataTypesEnum.COMMERCIAL ||
            row.F_C_S_P === rowDataTypesEnum.BREAK)
        ) {
          // Traverse backward to locate the last non-commercial row
          for (let j = newSchedulingTableData.length - 1; j >= 0; j--) {
            if (
              newSchedulingTableData[j].F_C_S_P !==
                rowDataTypesEnum.COMMERCIAL &&
              newSchedulingTableData[j].F_C_S_P !== rowDataTypesEnum.BREAK
            ) {
              // Insert the secondary table's selected rows after the identified row
              newSchedulingTableData.splice(
                j + 1, // Position to insert
                0,
                ...selectedRows, // Rows to insert
              );
              break; // Stop searching once the insertion point is found
            }
          }
        } else {
          // Otherwise, add the current row and the selected rows
          newSchedulingTableData.push(row, ...selectedRows);
          continue; // Move to the next iteration
        }
      }
    }
    // Default case: Add the current row to the updated table
    newSchedulingTableData.push(row);
  }
  return newSchedulingTableData;
}

export { executePromoBulkInsert };
