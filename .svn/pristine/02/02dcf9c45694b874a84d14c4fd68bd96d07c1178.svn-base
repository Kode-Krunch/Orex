import { getDummyRow } from 'views/Scheduling/Scheduler/components/SchedulingArea/utils/utils';
import {
  droppableIdsEnum,
  featuresEnum,
  IS_BACKDATED_FPC_ALLOWED_TO_EDIT,
  secTableBottomToolbarFeaturesEnum,
} from '../../enums';
import { v4 as uuid } from 'uuid';
import { apiGETColumnSetting } from 'services/ControlsService';
import {
  isDateBackDate,
  openNotification,
} from 'views/Controls/GLOBALFUNACTION';
import { isFeatureAllowedForChannel } from './renderingUtils';

const isAnyRHSFeatureActive = (activeFeatures) => {
  try {
    return Object.keys(activeFeatures).filter(
      (feature) =>
        (feature === featuresEnum.ROTATION_INFO ||
          feature === featuresEnum.INSERT) &&
        activeFeatures[feature],
    )[0]
      ? true
      : false;
  } catch (error) {
    throw error;
  }
};

function getDestinationIndex(
  sourceIndex,
  destIndex,
  sourceDroppableId,
  destinationDroppableId,
) {
  try {
    let destinationIndex = destIndex;
    if (destinationDroppableId === droppableIdsEnum.PRIMARY) {
      if (
        sourceDroppableId === droppableIdsEnum.PRIMARY &&
        sourceIndex < destinationIndex
      ) {
        /* DESTINATION INDEX CORRECTION IF DRAG IS TOP TO BOTTOM */
        destinationIndex = destinationIndex + 1;
      }
    } else if (
      sourceDroppableId === droppableIdsEnum.PROGRAMS &&
      destinationDroppableId === droppableIdsEnum.PROGRAMS
    ) {
      if (sourceIndex < destinationIndex) {
        /* DESTINATION INDEX CORRECTION IF DRAG IS TOP TO BOTTOM */
        destinationIndex = destinationIndex + 1;
      }
    }
    return destinationIndex;
  } catch (error) {
    throw error;
  }
}

const classNames = require('classnames');

const getClassNames = (isFeatureActive) => {
  try {
    return classNames(
      isFeatureActive
        ? '!bg-teal-700 hover:!bg-teal-700'
        : 'hover:!bg-teal-800',
      'transition-all !h-8 !w-8',
    );
  } catch (error) {
    console.error(error);
  }
};

const isFeatureDisabled = ({
  primaryTableSelectedRows,
  secTableSelectedRows,
  feature,
}) => {
  try {
    switch (feature) {
      case secTableBottomToolbarFeaturesEnum.INSERT:
        return secTableSelectedRows.length !== 1;
      case secTableBottomToolbarFeaturesEnum.REPLACE:
        return !(
          primaryTableSelectedRows.length === 1 &&
          secTableSelectedRows.length === 1
        );
      default:
        return false;
    }
  } catch (error) {
    console.error(error);
  }
};

function calculateEndTime(startTime, slotDuration) {
  const [hours, minutes] = startTime.split(':').map(Number);
  const totalMinutes = hours * 60 + minutes + slotDuration;
  const newHours = Math.floor(totalMinutes / 60) % 24; // Wrap around after 24 hours
  const newMinutes = totalMinutes % 60;
  return `${newHours.toString().padStart(2, '0')}:${newMinutes
    .toString()
    .padStart(2, '0')}`;
}

function handleStartTimeChange(index, newStartTime, tableData) {
  let newTableData = [...tableData];
  const updatedData = [
    ...newTableData.sort((a, b) => a.RowNumber - b.RowNumber),
  ];
  updatedData[index].StartTime = newStartTime;
  const slotDuration = parseInt(updatedData[index].SlotDuration, 10);
  const startTime = updatedData[index].StartTime;
  const endTime = calculateEndTime(startTime, slotDuration);
  updatedData[index].EndTime = endTime;
  for (let i = index + 1; i < updatedData.length; i++) {
    if (updatedData[i].StartTime !== null && updatedData[i].StartTime !== '') {
      // Calculate the new end time based on the slot duration
      const slotDuration = parseInt(updatedData[i].SlotDuration, 10);
      let startTime = '';
      startTime = updatedData[i - 1].EndTime;
      const endTime = calculateEndTime(startTime, slotDuration);
      // Update the start time and end time
      updatedData[i].StartTime = startTime;
      updatedData[i].EndTime = endTime;
    }
  }
  return updatedData; // Add this line to return the updatedData array
}

const getRowId = (tableName, row, uniqueKey) =>
  `${tableName}-row-id-${row[uniqueKey]}-${uuid()}`;

const getCellClassNames = (row, arr, ignoreSelectedRow) => {
  let cellClassNames = '!text-black !border-gray-200';
  if (row.ContentTypeCode === 14)
    cellClassNames = cellClassNames + ' !bg-green-300';
  else {
    if (row.IsRecorded === 1 && row.status == 'ORG')
      cellClassNames = cellClassNames + ` !bg-yellow-300`;
    // if (typeof ignoreSelectedRow === 'boolean' && !ignoreSelectedRow)
    //   cellClassNames = cellClassNames + ` !bg-blue-400`;
    const result = arr.filter((item) => item.ShortName == row.status);
    cellClassNames = cellClassNames + ` !bg-${result[0]?.NewColourCode}`;
  }
  return cellClassNames;
};

const getTableScrolledOffset = (tableRef) => {
  if (tableRef.current) {
    return tableRef.current.state.scrollOffset;
  }
  return 0;
};

function maintainScrolledOffsetOfTables(
  setPrimaryTableScrolledOffset,
  setSecTableScrolledOffset,
  primaryTableRef,
  secTableRef,
) {
  setPrimaryTableScrolledOffset(getTableScrolledOffset(primaryTableRef));
  setSecTableScrolledOffset(getTableScrolledOffset(secTableRef));
}

function getTranslatedSelectedRows(
  selectedRows,
  SelectedDate,
  BreakPattSelect,
  channel,
) {
  try {
    let selectedRowsToInsert = selectedRows.map((row) => ({
      ...row,
      StartTime: '00:00',
      EndTime: '00:00',
      status: row.OriginalRepeatCode,
      IsRecorded: 0,
      TimeCategoryStartTime: '00:00:00:00',
      TimeCategoryEndTime: '00:00:00:00',
      TelecastDate: SelectedDate,
      SlotDuration: row.SlotDuration.toString(),
      OriginalRepeatCode: row.OriginalRepeatCode === 'REP' ? 2 : 1,
      EpisodeNo: row.EpisodeNo,
      ActualDuration: row.SlotDuration.toString(),
      SeasonNo: row.SeasonNo,
      BreakPattern: BreakPattSelect ? BreakPattSelect.label : '',
      BreakPatternCode: BreakPattSelect ? BreakPattSelect.value : 0,
      ChannelTimeDescription: 'General',
      MinDiff: 1440,
      Consumption: 0,
      LocationCode: channel.LocationCode,
      ChannelCode: channel.ChannelCode,
      rowId: getRowId('primary', row, 'ContentCode'),
    }));
    return selectedRowsToInsert;
  } catch (error) {
    throw error;
  }
}

function executeProgToPriTableInsert(
  selectedRows,
  SelectedDate,
  BreakPattSelect,
  channel,
  data10,
  destinationIndex,
) {
  try {
    const translatedSelectedRows = getTranslatedSelectedRows(
      selectedRows,
      SelectedDate,
      BreakPattSelect,
      channel,
    );
    let newPrimaryTableData = [...data10];
    newPrimaryTableData.splice(destinationIndex, 0, ...translatedSelectedRows);
    return newPrimaryTableData;
  } catch (error) {
    throw error;
  }
}

function finalizeInsert({
  tableData,
  channelStartTime,
  setdata10,
  arr,
  setPrimaryTableScrolledOffset,
  setSecTableScrolledOffset,
  primaryTableRef,
  secTableRef,
}) {
  try {
    let newTableData = tableData.map((row, index) => ({
      ...row,
      RowNumber: index + 1,
    }));
    newTableData = handleStartTimeChange(
      0,
      channelStartTime,
      newTableData.length > 1 ? newTableData.slice(1) : newTableData,
    );
    newTableData = [getDummyRow(newTableData[0]), ...newTableData].map(
      (row, index) => ({
        ...row,
        rowId: getRowId('primary', row, 'ContentCode'),
        rowIndex: index,
        cellClassNames: getCellClassNames(row, arr, true),
        verify: false,
      }),
    );
    maintainScrolledOffsetOfTables(
      setPrimaryTableScrolledOffset,
      setSecTableScrolledOffset,
      primaryTableRef,
      secTableRef,
    );
    setdata10(newTableData);
    return newTableData;
  } catch (error) {
    throw error;
  }
}

const getColumnsState = async (tableData, tableName, token, channel) => {
  try {
    const { visibleColumns, removedColumns } = await getColumnSettingsFromAPI(
      tableName,
      tableData,
      token,
      channel,
    );
    const columnsState = {
      originalColumns: getAllColumnsOfTable(tableData),
      visibleColumns,
      removedColumns,
      channel,
    };
    return columnsState;
  } catch (error) {
    throw error;
  }
};

const getColumnSettingsFromAPI = async (
  tableName,
  tableData,
  token,
  channel,
) => {
  try {
    let visibleColumns = [],
      removedColumns = [];
    const response = await apiGETColumnSetting(tableName, token);
    if (response.status === 200) {
      if (response.data.length === 0) {
        visibleColumns = getAllColumnsOfTable(tableData, channel);
      } else {
        const sortedColumnSetting = response.data.sort(
          (a, b) => a.SequenceNo - b.SequenceNo,
        );
        sortedColumnSetting.forEach((columnSetting) => {
          if (columnSetting.IsVisible) {
            visibleColumns.push({
              header: columnSetting.Header,
              accessorKey: columnSetting.ColumnName,
              style: { width: columnSetting.ColumnWidht },
              id: columnSetting.ColumnName,
            });
          } else {
            removedColumns.push({
              header: columnSetting.Header,
              accessorKey: columnSetting.ColumnName,
              style: { width: columnSetting.ColumnWidht },
              id: columnSetting.ColumnName,
            });
          }
        });
        /* Attach all columns that are missing in response to removed columns list */
        const allColumnsName = getAllColumnsOfTable(tableData, channel).map(
          (column) => column.accessorKey,
        );
        const sortedColumnsName = sortedColumnSetting.map(
          (columnSetting) => columnSetting.ColumnName,
        );
        const missingColumnsName = allColumnsName.filter(
          (column) => !sortedColumnsName.includes(column),
        );
        missingColumnsName.forEach((columnName) => {
          removedColumns.push({
            header: columnName,
            accessorKey: columnName,
            style: { width: 12 },
            id: columnName,
          });
        });
      }
    } else if (response.status === 204) {
      visibleColumns = getAllColumnsOfTable(tableData, channel);
    } else {
      openNotification(
        'danger',
        'Something went wrong while fetching saved column settings',
      );
      console.error(
        `Something went wrong while fetching saved column settings. Server responded with status code: ${response.status}`,
      );
      visibleColumns = getAllColumnsOfTable(tableData, channel);
    }
    return { visibleColumns, removedColumns };
  } catch (error) {
    openNotification(
      'danger',
      'Something went wrong while fetching saved column settings',
    );
    throw error;
  }
};

const isFPCAllowedToEditFn = async (date, isTrafficDayOpen) => {
  try {
    const result =
      (isDateBackDate(date) && isTrafficDayOpen) ||
      (isDateBackDate(date) && IS_BACKDATED_FPC_ALLOWED_TO_EDIT) ||
      !isDateBackDate(date);
    return result;
  } catch (error) {
    console.error(error);
    return false;
  }
};
const isFPCAllowedToSaveFn = async (
  date,
  data10,
  isTrafficDayOpen,
  channel,
) => {
  try {
    const result =
      (isDateBackDate(date) && isTrafficDayOpen) ||
      (isDateBackDate(date) && IS_BACKDATED_FPC_ALLOWED_TO_EDIT) ||
      (!isDateBackDate(date) &&
        (isFeatureAllowedForChannel({ channel })
          ? true
          : data10.filter((row) => row.ContentStatus).length == 0 &&
            data10[1]?.verify));
    return result;
  } catch (error) {
    console.error(error);
    return false;
  }
};
const getAllColumnsOfTable = (tableData, channel) => {
  try {
    let columns = [];
    if (tableData.length > 0) {
      const rowKeys = Object.keys(tableData[0]);
      if (rowKeys) {
        rowKeys.forEach((key) => {
          if (
            key !== 'RowNumber' &&
            key !== 'Id' &&
            key !== 'cellClassNames' &&
            key !== 'rowId' &&
            key !== 'rowIndex' &&
            key !== 'Colorcode'
          ) {
            columns.push({
              header: key,
              accessorKey: key,
              style: { width: 12 },
              id: key,
            });
          }
        });
      }
      columns.push({
        header: 'SeasonAndEpisode',
        accessorKey: 'SeasonAndEpisode',
        style: { width: 12 },
        id: 'SeasonAndEpisode',
      });
      columns.push({
        header: 'Action',
        accessorKey: 'Action',
        style: { width: 12 },
        id: 'Action',
      });
    }

    return columns;
  } catch (error) {
    throw error;
  }
};

export {
  isAnyRHSFeatureActive,
  getDestinationIndex,
  getClassNames,
  isFeatureDisabled,
  handleStartTimeChange,
  getRowId,
  getCellClassNames,
  maintainScrolledOffsetOfTables,
  getTranslatedSelectedRows,
  executeProgToPriTableInsert,
  finalizeInsert,
  getColumnsState,
  isFPCAllowedToEditFn,
  isFPCAllowedToSaveFn,
};
