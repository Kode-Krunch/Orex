// NOTE: This file contains utility functions for the Scheduling Operations
// Write Pure Functions Here.
import {
  convertDateToHHMMSSFF,
  openNotification,
  subtractTimes,
} from 'views/Controls/GLOBALFUNACTION';
import {
  getDummyRow,
  getRowId,
} from '../components/SchedulingArea/utils/utils';
import {
  BACK_TO_BACK_COMM_WARNING_CELLS_WITH_COLORS,
  BACK_TO_BACK_NON_COMM_WARNING_CELLS_WITH_COLORS,
  COMMERCIAL_FEATURES,
  DEFAULT_COMMERCIAL_ACTIVE_FEATURES,
  DEFAULT_FINAL_LOG_ACTIVE_FEATURES,
  DEFAULT_NTC_ACTIVE_FEATURES,
  DEFAULT_PROMO_ACTIVE_FEATURES,
  DEFAULT_SONG_ACTIVE_FEATURES,
  FINAL_LOG_FEATURES,
  MULTI_SPOT_CELL_WARNING_PROPERTIES,
  NTC_FEATURES,
  PROMO_FEATURES,
  ROW_ACTIONS,
  SONG_FEATURES,
} from '../constants';
import {
  additionalRowInfoEnum,
  cellWarningTypesEnum,
  droppableIdsEnum,
  featuresEnum,
  operationTypesEnum,
  pagesEnum,
  rowDataTypesEnum,
  tableFilterOptionsEnum,
  tableTypesEnum,
} from '../enum';
import { addTimes } from '../components/SchedulingArea/components/Summary/utils';
import { convertDateToYMD } from 'components/validators';
import {
  apiGetNTCScheduling,
  apiGetPromoScheduling,
  apiGetSongSchedulingData,
  apiGettransmissionlog,
} from 'services/SchedulingService';
import { apiCallstoreprocedure } from 'services/CommonService';
import { updateStartTimes } from 'views/Scheduling/general';
import { CLIENT } from 'views/Controls/clientListEnum';

const getDefaultActiveFeatures = (page, isScheduleAllowedToEdit) => {
  try {
    let defaultActiveFeatures = {};
    if (page === pagesEnum.PROMO) {
      defaultActiveFeatures = DEFAULT_PROMO_ACTIVE_FEATURES;
    } else if (page === pagesEnum.SONG) {
      defaultActiveFeatures = DEFAULT_SONG_ACTIVE_FEATURES;
    } else if (page === pagesEnum.COMMERCIAL) {
      defaultActiveFeatures = DEFAULT_COMMERCIAL_ACTIVE_FEATURES;
    } else if (page === pagesEnum.NTC) {
      defaultActiveFeatures = DEFAULT_NTC_ACTIVE_FEATURES;
    } else if (page === pagesEnum.FINAL_LOG) {
      defaultActiveFeatures = DEFAULT_FINAL_LOG_ACTIVE_FEATURES;
    }
    if (!isScheduleAllowedToEdit)
      defaultActiveFeatures = removeBackdateFeatures(defaultActiveFeatures);
    return defaultActiveFeatures;
  } catch (error) {
    throw error;
  }
};

function getFeaturesList(page, isScheduleAllowedToEdit) {
  try {
    let feature = {};
    if (page === pagesEnum.PROMO) {
      feature = PROMO_FEATURES;
    } else if (page === pagesEnum.SONG) {
      feature = SONG_FEATURES;
    } else if (page === pagesEnum.COMMERCIAL) {
      feature = COMMERCIAL_FEATURES;
    } else if (page === pagesEnum.NTC) {
      feature = NTC_FEATURES;
    } else if (page === pagesEnum.FINAL_LOG) {
      feature = FINAL_LOG_FEATURES;
    }
    if (!isScheduleAllowedToEdit) feature = removeBackdateFeatures(feature);
    return feature;
  } catch (error) {
    throw error;
  }
}

function removeBackdateFeatures(feature) {
  let newFeature = { ...feature };
  delete newFeature[featuresEnum.UNDO];
  delete newFeature[featuresEnum.REDO];
  delete newFeature[featuresEnum.COPY];
  delete newFeature[featuresEnum.GENERATE_LOG];
  delete newFeature[featuresEnum.FINALIZE];
  delete newFeature[featuresEnum.RESTORE_SAVED_WORK];
  delete newFeature[featuresEnum.REFRESH_DURATION];
  delete newFeature[featuresEnum.INSERT];
  delete newFeature[featuresEnum.AUTO_SHUFFLE];
  delete newFeature[featuresEnum.CHANGE_PROGRAM];
  delete newFeature[featuresEnum.MANAGE_SEGMENT];
  delete newFeature[featuresEnum.MANAGE_START_TIME];
  delete newFeature[featuresEnum.SMART_SHUFFLE];
  delete newFeature[featuresEnum.IMPORT_SEQUENECE];
  return newFeature;
}

function groupNTCBasedOnNTCGroupCode(tableData) {
  // group ntcs in ascending order of ntc group code
  let newTableData = [];
  for (let index = 0; index < tableData.length; index++) {
    let curRow = tableData[index];
    let childNTCs = getRowWithNTC([curRow], tableData, false);
    newTableData.push(curRow);
    if (childNTCs.length > 0) {
      childNTCs.sort((a, b) => a.NTCGroupCode - b.NTCGroupCode);
      const groupedNTCs = {};
      const newChildNTCs = [];
      childNTCs.forEach((row) => {
        if (!groupedNTCs[row.NTCGroupCode]) {
          groupedNTCs[row.NTCGroupCode] = [];
        }
        groupedNTCs[row.NTCGroupCode].push(row);
      });
      Object.keys(groupedNTCs).forEach((ntcType) => {
        const sortedNTCGroup = groupedNTCs[ntcType].sort((a, b) =>
          a.Tel_Time.localeCompare(b.Tel_Time),
        );
        newChildNTCs.push(...sortedNTCGroup);
      });
      newTableData.push(...newChildNTCs);
      index = index + newChildNTCs.length;
    }
  }
  return newTableData;
}

function getTableDataWithAdditionalInfo({
  tableData,
  tableType,
  additionalInfo = [
    additionalRowInfoEnum.CELL_WARNING,
    additionalRowInfoEnum.REFERENCE_INFO,
    additionalRowInfoEnum.ROW_ID,
    additionalRowInfoEnum.ROW_INDEX,
    additionalRowInfoEnum.SEQUENCE_NO,
    additionalRowInfoEnum.ACTIONS,
    additionalRowInfoEnum.CUSTOM_CELL_COLOR,
  ],
  customCellColor,
  channel,
}) {
  try {
    let newTableData = [];
    let segmentStartIndex = null;
    let segmentEndIndex = null;
    let referenceRow = null;
    for (let index = 0; index < tableData.length; index++) {
      let newRow = { ...tableData[index] };
      if (newRow.F_C_S_P) {
        if (
          newRow.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION ||
          newRow.F_C_S_P === rowDataTypesEnum.SEGMENT
        ) {
          segmentStartIndex = index + 1;
          segmentEndIndex = getSegmentEndIndex(tableData, segmentStartIndex);
          referenceRow = newRow;
        } else {
          /* ADD CELL WARNINGS */
          if (additionalInfo.includes(additionalRowInfoEnum.CELL_WARNING))
            newRow = getRowWithCellWarnings(
              newRow,
              tableData,
              index,
              segmentStartIndex,
              segmentEndIndex,
            );
        }
      }
      /* ADD REFERENCE ROW INFO */
      if (
        referenceRow &&
        additionalInfo.includes(additionalRowInfoEnum.REFERENCE_INFO)
      )
        newRow = getRowWithReferenceInfo(newRow, referenceRow);
      /* ADD UNIQUE ROW ID */
      if (additionalInfo.includes(additionalRowInfoEnum.ROW_ID))
        newRow.rowId = getRowId(tableType, newRow);
      /* ADD ROW INDEX */
      if (additionalInfo.includes(additionalRowInfoEnum.ROW_INDEX))
        newRow.rowIndex = index;
      /* ADD SEQUENCE NO */
      if (additionalInfo.includes(additionalRowInfoEnum.SEQUENCE_NO))
        newRow.SequenceNo = newRow.SequenceNo ? newRow.SequenceNo : index;
      /* ADD ACTIONS */
      if (additionalInfo.includes(additionalRowInfoEnum.ACTIONS))
        newRow = getRowWithActions(newRow, channel);
      /* ADD CUSTOM CELL COLOR */
      if (additionalInfo.includes(additionalRowInfoEnum.CUSTOM_CELL_COLOR))
        newRow = getRowWithCustomCellColor(newRow, customCellColor);
      newTableData.push(newRow);
    }
    return newTableData;
  } catch (error) {
    throw error;
  }
}

async function getSchedulingTableData(
  isGenerateLog,
  mode,
  date,
  page,
  channel,
) {
  try {
    let telecastDate = convertDateToYMD(date);
    let newSchedulingTableData = [];
    let response = null;
    if (page === pagesEnum.PROMO) {
      response = await apiGetPromoScheduling(channel, telecastDate, mode);
    } else if (page === pagesEnum.SONG) {
      response = await apiGetSongSchedulingData(channel, telecastDate, mode);
    } else if (page === pagesEnum.COMMERCIAL) {
      let param = {
        ChannelCode: channel.ChannelCode,
        LocationCode: channel.LocationCode,
        TelecastDate: telecastDate,
        Mode: 'S',
      };
      response = await apiCallstoreprocedure(
        'USP_Sch_Commercial_scheduling',
        param,
      );
    } else if (page === pagesEnum.NTC) {
      response = await apiGetNTCScheduling(channel, telecastDate, mode);
    } else if (page === pagesEnum.FINAL_LOG) {
      response = await apiGettransmissionlog(
        channel,
        telecastDate,
        isGenerateLog ? 'GEN' : 'Edit',
      );
    }
    if (response) {
      if (response.status === 200) {
        if (response.data.length === 0) {
          openNotification('info', 'No programs found');
        } else {
          newSchedulingTableData = response.data.map((row) =>
            row.BreakNumber
              ? { ...row, isFiltered: true }
              : { ...row, BreakNumber: '0', isFiltered: true },
          );
          newSchedulingTableData.unshift(
            getDummyRow(newSchedulingTableData[0]),
          );
        }
      } else if (response.status !== 204) {
        openNotification('info', 'No programs found');
      } else {
        openNotification(
          'danger',
          `Something went wrong while fetching schedule. Server responded with status code ${response.status}`,
        );
      }
    }
    return newSchedulingTableData;
  } catch (error) {
    throw error;
  }
}

async function getDroppedSpots(channel, date, schedulingTableData, operation) {
  try {
    let droppedSpots = [];
    let isOperationInitializeScheduler =
      operation === operationTypesEnum.INITIALIZE_SCHEDULER;
    const response = await apiCallstoreprocedure(
      'USP_Sch_Commercial_scheduling',
      {
        ChannelCode: channel.ChannelCode,
        LocationCode: channel.LocationCode,
        TelecastDate: date,
        Mode: 'D',
      },
    );
    if (response.status === 200) {
      if (response.data.length === 0) {
        !isOperationInitializeScheduler &&
          openNotification('info', 'No dropped spots found');
      } else {
        droppedSpots = removeSpotsPresentInSchTable(
          response.data,
          schedulingTableData,
        );
        if (droppedSpots.length > 0) {
          droppedSpots = [getDummyRow(response.data[0]), ...droppedSpots];
        }
      }
    } else if (response.status === 204) {
      !isOperationInitializeScheduler &&
        openNotification('info', 'No dropped spots found');
    } else {
      !isOperationInitializeScheduler &&
        openNotification(
          'danger',
          `Something went wrong while fetching dropped spots. Server responded with status code ${response.status}`,
        );
    }
    return droppedSpots;
  } catch (error) {
    throw error;
  }
}

function removeSpotsPresentInSchTable(droppedSpots, schedulingTableData) {
  try {
    const bookingDetailIds = new Set(
      schedulingTableData.map((row) => row.BookingDetailID),
    );
    bookingDetailIds.delete(null);
    const filteredSpots = droppedSpots.filter(
      (spot) => !bookingDetailIds.has(spot.BookingDetailID),
    );
    return filteredSpots;
  } catch (error) {
    throw error;
  }
}

async function getLastMinuteSpots(
  channel,
  date,
  schedulingTableData,
  dropBucket,
  page,
  operation,
) {
  try {
    let lastMinuteSpots = [];
    let isOperationInitializeScheduler =
      operation === operationTypesEnum.INITIALIZE_SCHEDULER;
    const response = await apiCallstoreprocedure(
      'USP_Sch_Commercial_scheduling',
      {
        ChannelCode: channel.ChannelCode,
        LocationCode: channel.LocationCode,
        TelecastDate: date,
        Mode: page === pagesEnum.COMMERCIAL ? 'N' : 'NF',
      },
    );
    if (response.status === 200) {
      if (response.data.length === 0) {
        !isOperationInitializeScheduler &&
          openNotification('info', 'No last minute spots found');
      } else {
        lastMinuteSpots = removeSpotsPresentInTable2(
          response.data,
          schedulingTableData,
        );
        lastMinuteSpots = removeSpotsPresentInTable2(
          lastMinuteSpots,
          [...dropBucket].splice(1),
        );
        if (lastMinuteSpots.length > 0) {
          lastMinuteSpots = [getDummyRow(response.data[0]), ...lastMinuteSpots];
        }
      }
    } else if (response.status === 204) {
      !isOperationInitializeScheduler &&
        openNotification('info', 'No last minute spots found');
    } else {
      !isOperationInitializeScheduler &&
        openNotification(
          'danger',
          `Something went wrong while fetching last minute spots. Server responded with status code ${response.status}`,
        );
    }
    return lastMinuteSpots;
  } catch (error) {
    throw error;
  }
}

function removeSpotsPresentInTable2(table1, table2) {
  try {
    const bookingDetailIds = new Set(table2.map((row) => row.BookingDetailID));
    bookingDetailIds.delete(null);
    const filteredSpots = table1.filter(
      (spot) => !bookingDetailIds.has(spot.BookingDetailID),
    );
    return filteredSpots;
  } catch (error) {
    throw error;
  }
}

function getRowWithNTC(
  draggedRows,
  schedulingTableData,
  includeParentRow = true,
) {
  try {
    let rowWithNTC = [];
    [...draggedRows].forEach((row) => {
      if (includeParentRow) rowWithNTC.push(row);
      let index = row.rowIndex + 1;
      while (schedulingTableData[index]?.F_C_S_P === rowDataTypesEnum.NTC) {
        rowWithNTC.push(schedulingTableData[index]);
        index++;
      }
    });
    return rowWithNTC;
  } catch (error) {
    throw error;
  }
}

function isBasicDragValid(dragInfo, destIndex) {
  const sourceDroppableId = dragInfo.source.droppableId;
  const destinationDroppableId = dragInfo.destination.droppableId;
  return (
    dragInfo.destination &&
    ((sourceDroppableId === droppableIdsEnum.SECONDARY &&
      destinationDroppableId === droppableIdsEnum.SCHEDULING) ||
      (sourceDroppableId === destinationDroppableId &&
        dragInfo.source.index !== destIndex))
  );
}

function isDragValidForSourceRow(
  isChannelForbes,
  schedulingTableData,
  destinationIndex,
  sourceRow,
) {
  return isChannelForbes &&
    schedulingTableData[destinationIndex - 1].F_C_S_P === rowDataTypesEnum.LIVE
    ? sourceRow.F_C_S_P === rowDataTypesEnum.NTC
    : true;
}

function isRowDataTypePresentInDraggedRows(draggedRows, rowDataType) {
  return draggedRows.filter((row) => row.F_C_S_P === rowDataType).length > 0;
}

function getSegmentEndIndex(tableData, segmentStartIndex) {
  try {
    for (let index = segmentStartIndex; index < tableData.length; index++) {
      if (tableData[index].F_C_S_P === rowDataTypesEnum.SEGMENT) {
        return index - 1;
      }
      if (index === tableData.length - 1) {
        return index;
      }
    }
  } catch (error) {
    throw error;
  }
}

function getRowWithCellWarnings(
  row,
  tableData,
  index,
  segmentStartIndex,
  segmentEndIndex,
) {
  try {
    /* Apply back to back warning */
    let { rowWithCellWarnings, isBackToBackCellWarningAdded } =
      addBackToBackCellWarning(row, tableData, index);
    /* If back to back warning not applied on current iteration, remove back to back warning if any */
    if (
      !isBackToBackCellWarningAdded &&
      Array.isArray(rowWithCellWarnings.cellWarning)
    ) {
      delete rowWithCellWarnings.cellWarning;
    }
    /* If current row is commercial, apply Out Of Timeband and Multi Spot cell warning */
    if (row.F_C_S_P === rowDataTypesEnum.COMMERCIAL) {
      /* Apply Out Of Timeband cell warning*/
      rowWithCellWarnings = addOutOfTimebandCellWarning(rowWithCellWarnings);
      /* Apply Multi Spot cell warning */
      rowWithCellWarnings = addMultiSpotCellWarning(
        tableData,
        segmentStartIndex,
        segmentEndIndex,
        rowWithCellWarnings,
      );
    }
    return rowWithCellWarnings;
  } catch (error) {
    throw error;
  }
}

function addBackToBackCellWarning(row, tableData, tableIndex) {
  try {
    let rowWithCellWarnings = { ...row };
    let backToBackWarningCellsWithColor;
    let isBackToBackCellWarningAdded = false;
    if (row.F_C_S_P === rowDataTypesEnum.COMMERCIAL) {
      backToBackWarningCellsWithColor =
        BACK_TO_BACK_COMM_WARNING_CELLS_WITH_COLORS;
    } else {
      backToBackWarningCellsWithColor =
        BACK_TO_BACK_NON_COMM_WARNING_CELLS_WITH_COLORS;
    }
    const backToBackWarningCells = Object.keys(backToBackWarningCellsWithColor);
    for (let index = 0; index < backToBackWarningCells.length; index++) {
      const column = backToBackWarningCells[index];
      const prevRow = tableData[tableIndex - 1];
      const nextRow = tableData[tableIndex + 1];
      if (
        (prevRow &&
          prevRow.F_C_S_P === row.F_C_S_P &&
          prevRow[column] &&
          row[column] &&
          prevRow[column] === row[column]) ||
        (nextRow &&
          nextRow.F_C_S_P === row.F_C_S_P &&
          row[column] &&
          nextRow[column] &&
          row[column] === nextRow[column])
      ) {
        rowWithCellWarnings = {
          ...row,
          cellWarning: [
            {
              cell: column,
              bgColor: backToBackWarningCellsWithColor[column].bgColor,
              fontColor: backToBackWarningCellsWithColor[column].fontColor,
              warningType: cellWarningTypesEnum.BACK_TO_BACK,
            },
          ],
        };
        isBackToBackCellWarningAdded = true;
        break;
      }
    }
    return {
      rowWithCellWarnings,
      isBackToBackCellWarningAdded,
    };
  } catch (error) {
    throw error;
  }
}

function addOutOfTimebandCellWarning(row) {
  try {
    let rowWithOutOfTimebandWarning = { ...row };
    if (row.SpotStartTime && row.SpotEndTime) {
      const spotStartTime =
        row.SpotStartTime.length < 8
          ? `${row.SpotStartTime}:00`
          : row.SpotStartTime;
      const spotEndTime =
        row.SpotEndTime.length < 8 ? `${row.SpotEndTime}:00` : row.SpotEndTime;
      if (!(row.Tel_Time >= spotStartTime && row.Tel_Time < spotEndTime)) {
        const cellWarning = {
          cell: 'Event_Name',
          bgColor: 'rgb(185 28 28)',
          fontColor: 'white',
          warningType: cellWarningTypesEnum.OUT_OF_TIMEBAND,
        };
        if (!rowWithOutOfTimebandWarning.cellWarning) {
          rowWithOutOfTimebandWarning = {
            ...rowWithOutOfTimebandWarning,
            cellWarning: [cellWarning],
          };
        } else if (Array.isArray(rowWithOutOfTimebandWarning.cellWarning)) {
          rowWithOutOfTimebandWarning = {
            ...rowWithOutOfTimebandWarning,
            cellWarning: [
              ...rowWithOutOfTimebandWarning.cellWarning,
              {
                ...cellWarning,
              },
            ],
          };
        }
      }
    }
    return rowWithOutOfTimebandWarning;
  } catch (error) {
    throw error;
  }
}

function addMultiSpotCellWarning(
  tableData,
  segmentStartIndex,
  segmentEndIndex,
  rowWithCellWarnings,
) {
  try {
    let rowWithMultiSpotWarning = { ...rowWithCellWarnings };
    if (
      isMultiSpotPresentForCurCommercial(
        tableData,
        segmentStartIndex,
        segmentEndIndex,
        rowWithMultiSpotWarning,
      )
    ) {
      if (!rowWithMultiSpotWarning.cellWarning) {
        rowWithMultiSpotWarning = {
          ...rowWithMultiSpotWarning,
          cellWarning: [
            {
              cell: MULTI_SPOT_CELL_WARNING_PROPERTIES.cell,
              bgColor: MULTI_SPOT_CELL_WARNING_PROPERTIES.bgColor,
              fontColor: MULTI_SPOT_CELL_WARNING_PROPERTIES.fontColor,
              warningType: cellWarningTypesEnum.MULTI_SPOT,
            },
          ],
        };
      } else if (
        (Array.isArray(rowWithMultiSpotWarning.cellWarning) &&
          rowWithMultiSpotWarning.cellWarning[
            rowWithMultiSpotWarning.cellWarning.length - 1
          ].cell !== 'Event_Name') ||
        (Array.isArray(rowWithMultiSpotWarning.cellWarning) &&
          rowWithMultiSpotWarning.cellWarning[
            rowWithMultiSpotWarning.cellWarning.length - 1
          ].cell === 'Event_Name' &&
          rowWithMultiSpotWarning.cellWarning[
            rowWithMultiSpotWarning.cellWarning.length - 1
          ].warningType !== cellWarningTypesEnum.BACK_TO_BACK)
      ) {
        rowWithMultiSpotWarning = {
          ...rowWithMultiSpotWarning,
          cellWarning: [
            ...rowWithMultiSpotWarning.cellWarning,
            {
              cell: MULTI_SPOT_CELL_WARNING_PROPERTIES.cell,
              bgColor: MULTI_SPOT_CELL_WARNING_PROPERTIES.bgColor,
              fontColor: MULTI_SPOT_CELL_WARNING_PROPERTIES.fontColor,
              warningType: cellWarningTypesEnum.MULTI_SPOT,
            },
          ],
        };
      }
    }
    return rowWithMultiSpotWarning;
  } catch (error) {
    throw error;
  }
}

function isMultiSpotPresentForCurCommercial(
  tableData,
  segmentStartIndex,
  segmentEndIndex,
  commercialRow,
) {
  try {
    for (let index = segmentStartIndex; index <= segmentEndIndex; index++) {
      if (
        tableData[index].F_C_S_P === rowDataTypesEnum.COMMERCIAL &&
        commercialRow.BookingDetailID !== tableData[index].BookingDetailID &&
        commercialRow.Event_Name === tableData[index].Event_Name
      ) {
        return true;
      }
    }
    return false;
  } catch (error) {
    throw error;
  }
}

function getRowWithReferenceInfo(row, referenceRow) {
  try {
    let newRow = { ...row };
    if (
      newRow.F_C_S_P === rowDataTypesEnum.SEGMENT ||
      newRow.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION
    ) {
      return newRow;
    }
    if (newRow.F_C_S_P === 'NTC') {
      newRow.PrimaryID = referenceRow.PrimaryID;
    } else if (newRow.F_C_S_P === 'CM') {
      newRow.PrimaryID = referenceRow.PrimaryID;
      newRow.ScheduleTime = referenceRow.ScheduleTime;
    }
    newRow.SeasonNo = referenceRow.SeasonNo;
    newRow.Ep_No = referenceRow.Ep_No;
    newRow.ContentCode = referenceRow.ContentCode;
    newRow.BreakNumber = referenceRow.BreakNumber;
    newRow.FPC_ID = referenceRow.FPC_ID;
    newRow.SequenceNo = referenceRow.SequenceNo;
    return newRow;
  } catch (error) {
    throw error;
  }
}

function getRowWithActions(row, channel) {
  try {
    if (
      row.F_C_S_P === rowDataTypesEnum.PROMO ||
      row.F_C_S_P === rowDataTypesEnum.SONG
    )
      return {
        ...row,
        actions: [ROW_ACTIONS.DELETE, ROW_ACTIONS.ROTATION_INFO],
      };
    else if (row.F_C_S_P === rowDataTypesEnum.COMMERCIAL)
      return {
        ...row,
        actions: [ROW_ACTIONS.DROP_SPOTS, ROW_ACTIONS.ROTATION_INFO],
      };
    else if (
      row.F_C_S_P === rowDataTypesEnum.NTC &&
      (!('BookingDetailID' in row) || !row.BookingDetailID)
    ) {
      if (channel.label === CLIENT.USA_Forbes)
        return {
          ...row,
          actions: [ROW_ACTIONS.DELETE, ROW_ACTIONS.EDIT_ROW],
        };
      else {
        if (row.NTCGroupCode !== 999)
          return {
            ...row,
            actions: [
              ROW_ACTIONS.DELETE,
              ROW_ACTIONS.ROTATION_INFO,
              ROW_ACTIONS.EDIT_ROW,
            ],
          };
        else
          return {
            ...row,
            actions: [ROW_ACTIONS.DELETE, ROW_ACTIONS.ROTATION_INFO],
          };
      }
    } else if (row.F_C_S_P === rowDataTypesEnum.LIVE)
      return {
        ...row,
        actions: [ROW_ACTIONS.DELETE, ROW_ACTIONS.EDIT_ROW],
      };
    else return row;
  } catch (error) {
    throw error;
  }
}

function getRowWithCustomCellColor(row, customCellColor) {
  try {
    let newRow = { ...row };
    let newCustomCellColor = {};
    if (!customCellColor) {
      /* ADD DEFAULT ROW COLOR TO EACH CELL*/
      Object.keys(row).forEach(
        (key) => (newCustomCellColor[key] = row.EventDefaultBackColor),
      );
    } else {
      Object.keys(newRow).forEach((cellType) => {
        /* GET CELL COLOR IF PRESENT IN customCellColor STATE */
        if (
          cellType in customCellColor &&
          row[cellType] in customCellColor[cellType]
        ) {
          newCustomCellColor[cellType] =
            customCellColor[cellType][row[cellType]];
        } else {
          /* ASSIGN DEFAULT CELL COLOR TO CELL TYPE */
          newCustomCellColor[cellType] = row.EventDefaultBackColor;
        }
      });
    }
    newRow = { ...newRow, customCellColor: newCustomCellColor };
    return newRow;
  } catch (error) {
    throw error;
  }
}

function isCommercialInsertValid(draggedRows, destinationIndex, tableData) {
  try {
    let destinationRow = tableData[destinationIndex];
    for (let index = destinationIndex; index > 0; index--) {
      if (
        tableData[index].F_C_S_P !== rowDataTypesEnum.NTC &&
        destinationRow.rowId !== tableData[index].rowId
      ) {
        destinationRow = tableData[index];
        break;
      }
    }
    let result = isSelectedRowsBetweenStartAndEndTime(
      draggedRows,
      destinationRow,
    );
    if (!result) {
      openNotification(
        'danger',
        draggedRows.length === 1
          ? 'Commercial out of its valid timeband'
          : 'One or more commercials out of its timeband',
      );
    }
    return result;
  } catch (error) {
    throw error;
  }
}

function isSelectedRowsBetweenStartAndEndTime(draggedRows, destinationRow) {
  try {
    let result = false;
    for (let index = 0; index < draggedRows.length; index++) {
      result = isTelTimeBetweenStartAndEndTime(
        destinationRow,
        draggedRows[index],
      );
      if (!result) break;
    }
    return result;
  } catch (error) {
    throw error;
  }
}

function isTelTimeBetweenStartAndEndTime(destinationRow, draggedRow) {
  return (
    destinationRow.Tel_Time >= draggedRow.SpotStartTime &&
    destinationRow.Tel_Time <= draggedRow.SpotEndTime
  );
}

function isNTCInsertValid(
  destinationIndex,
  destinationRow,
  draggedRows,
  schedulingTableData,
) {
  try {
    let isDragValid = true;
    let ntcParentRow = getNTCParentRow(destinationIndex, schedulingTableData);
    let isPaidNTC = isAnyNTCPaid(draggedRows);
    /* --------------------- GAURD CLAUSES ----------------------------- */
    /* CLAUSE 1 */
    if (isNTCPlacedBelowCMOrCT(destinationIndex, schedulingTableData))
      isDragValid = false;
    /* CLAUSE 2 */ else if (isNTCEndingAfterDuration(draggedRows, ntcParentRow))
      isDragValid = false;
    /* CLAUSE 3 */ else if (isPaidNTC) {
      isDragValid = isPaidNTCInsertValid(draggedRows, destinationRow);
    }
    return isDragValid;
  } catch (error) {
    throw error;
  }
}

function getNTCParentRow(destinationIndex, schedulingTableData) {
  try {
    for (let index = destinationIndex - 1; index > 0; index--) {
      if (
        schedulingTableData[index].F_C_S_P === rowDataTypesEnum.SEGMENT ||
        schedulingTableData[index].F_C_S_P === rowDataTypesEnum.PROMO ||
        schedulingTableData[index].F_C_S_P === rowDataTypesEnum.SONG ||
        schedulingTableData[index].F_C_S_P === rowDataTypesEnum.LIVE
      ) {
        return schedulingTableData[index];
      }
    }
  } catch (error) {
    throw error;
  }
}

function isAnyNTCPaid(selectedRows) {
  try {
    let result = false;
    for (let index = 0; index < selectedRows.length; index++) {
      if (
        selectedRows[index].F_C_S_P === rowDataTypesEnum.NTC &&
        selectedRows[index].BookingDetailID
      ) {
        result = true;
        break;
      }
    }
    return result;
  } catch (error) {
    throw error;
  }
}

function isNTCPlacedBelowCMOrCT(destinationIndex, schedulingTableData) {
  try {
    let result = false;
    let rowBeforeDestination = schedulingTableData[destinationIndex - 1];
    if (rowBeforeDestination.F_C_S_P === rowDataTypesEnum.COMMERCIAL) {
      result = true;
      openNotification('danger', 'NTC cannot be placed after a commercial');
    } else if (
      rowBeforeDestination.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION
    ) {
      result = true;
      openNotification(
        'danger',
        'NTC cannot be placed after a content termination',
      );
    }
    return result;
  } catch (error) {
    throw error;
  }
}

function isNTCEndingAfterDuration(draggedRows, ntcParentRow) {
  try {
    let result = false;
    for (let index = 0; index < draggedRows.length; index++) {
      const curRow = draggedRows[index];
      const offsetStartTime = addTimes(
        ntcParentRow.Start_Time,
        curRow.OffsetStartTime,
      );
      const ntcEndTime = addTimes(offsetStartTime, curRow.Duration);
      result =
        ntcEndTime > addTimes(ntcParentRow.Start_Time, ntcParentRow.Duration);
      if (result) break;
    }
    if (result) {
      const parentEventType =
        ntcParentRow.F_C_S_P === rowDataTypesEnum.SEGMENT
          ? 'segment'
          : ntcParentRow.F_C_S_P === rowDataTypesEnum.PROMO
            ? 'promo'
            : 'song';
      openNotification(
        'danger',
        draggedRows.length === 1
          ? `End time of an NTC cannot be greater than ${parentEventType} end time`
          : `One or more NTC have end time greater than ${parentEventType} end time`,
      );
    }
    return result;
  } catch (error) {
    throw error;
  }
}

function isPaidNTCInsertValid(draggedRows, destinationRow) {
  try {
    let result = isSelectedRowsBetweenStartAndEndTime(
      draggedRows,
      destinationRow,
    );
    if (!result) {
      openNotification(
        'danger',
        draggedRows.length === 1
          ? 'Paid NTC cannot be out of its timeband'
          : 'One or more paid NTCs out of its timeband',
      );
    }
    return result;
  } catch (error) {
    throw error;
  }
}

function removeRowsFromTableData(rows, tableData) {
  let rowsId = rows.map((row) => row.rowId);
  return [...tableData].filter((row) => !rowsId.includes(row.rowId));
}

function isSegmentValid(row, time, selectedBreaks) {
  try {
    const segStartTime = row.Start_Time;
    const insertStartTime = convertDateToHHMMSSFF(time.start);
    const insertEndTime = convertDateToHHMMSSFF(time.end);
    if (
      segStartTime >= insertStartTime &&
      segStartTime <= insertEndTime &&
      selectedBreaks.includes(Number(row.BreakNumber))
    )
      return (
        segStartTime >= insertStartTime &&
        segStartTime <= insertEndTime &&
        selectedBreaks.includes(Number(row.BreakNumber))
      );
  } catch (error) {
    throw error;
  }
}

function isRowLastSegment(row, tableData) {
  let result = false;
  for (let index = row.rowIndex + 1; index < tableData.length; index++) {
    const curRow = tableData[index];
    if (!curRow) {
      result = true;
      break;
    }
    if (
      curRow.F_C_S_P === rowDataTypesEnum.SEGMENT ||
      curRow.F_C_S_P === rowDataTypesEnum.LIVE
    ) {
      result = false;
      break;
    } else if (curRow.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION) {
      result = true;
      break;
    }
  }
  return result;
}

function isRowBetweenValidTime(row, time) {
  try {
    const segStartTime = row.Start_Time;
    const insertStartTime = convertDateToHHMMSSFF(time.start);
    const insertEndTime = convertDateToHHMMSSFF(time.end);
    return segStartTime >= insertStartTime && segStartTime <= insertEndTime;
  } catch (error) {
    throw error;
  }
}

function removeAdditionalInfoFromRows(rows) {
  return rows.map((row) => {
    let newRow = { ...row };
    delete newRow.rowId;
    delete newRow.rowIndex;
    delete newRow.actions;
    delete newRow.SequenceNo;
    delete newRow.cellWarning;
    return newRow;
  });
}

function getSegmentWiseContent(clickedProgramSchedule) {
  try {
    let segmentContents = [];
    let isSegmentInfoFound = false;
    let curSegmentContents = [];
    for (let index = 0; index < clickedProgramSchedule.length; index++) {
      if (isSegmentInfoFound) {
        curSegmentContents.push(clickedProgramSchedule[index]);
      }
      if (clickedProgramSchedule[index].F_C_S_P === rowDataTypesEnum.SEGMENT) {
        isSegmentInfoFound = true;
      }
      if (
        clickedProgramSchedule[index].F_C_S_P !==
        rowDataTypesEnum.CONTENT_TERMINATION
      ) {
        if (clickedProgramSchedule[index + 1]) {
          if (
            clickedProgramSchedule[index + 1].F_C_S_P ===
            rowDataTypesEnum.SEGMENT
          ) {
            segmentContents.push(curSegmentContents);
            curSegmentContents = [];
            isSegmentInfoFound = false;
          }
        } else {
          segmentContents.push(curSegmentContents);
        }
      }
    }
    return segmentContents;
  } catch (error) {
    throw error;
  }
}

function getProgramWithSegmentContent(
  schedule,
  segmentWiseContent,
  clickedProgram,
) {
  try {
    let programWithSegmentWiseContent = [];
    let updatedSegmentWiseContent = [...segmentWiseContent];
    schedule.forEach((row, index) => {
      if (row.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION) {
        const rowWithOriginalCTColor = {
          ...row,
          EventDefaultBackColor: clickedProgram.EventDefaultBackColor,
          EventDefaultFrontColor: clickedProgram.EventDefaultFrontColor,
        };
        programWithSegmentWiseContent.push(rowWithOriginalCTColor);
      } else if (row.F_C_S_P === rowDataTypesEnum.SEGMENT) {
        programWithSegmentWiseContent.push(row);
        if (schedule[index + 1]) {
          if (updatedSegmentWiseContent[0]) {
            programWithSegmentWiseContent.push(...updatedSegmentWiseContent[0]);
            updatedSegmentWiseContent.shift();
          }
        } else {
          if (updatedSegmentWiseContent.length > 0) {
            programWithSegmentWiseContent.push(
              ...updatedSegmentWiseContent.flat(),
            );
          }
        }
      }
    });
    return programWithSegmentWiseContent;
  } catch (error) {
    throw error;
  }
}

function updateProgramInSchedulingTableData(
  clickedProgram,
  newProgramWithSegmentContent,
  schedulingTableData,
) {
  try {
    let updatedSchedulingTableData = [...schedulingTableData];
    updatedSchedulingTableData.splice(clickedProgram.rowIndex, 1);
    while (
      updatedSchedulingTableData[clickedProgram.rowIndex].F_C_S_P !==
      rowDataTypesEnum.CONTENT_TERMINATION
    ) {
      updatedSchedulingTableData.splice(clickedProgram.rowIndex, 1);
    }
    updatedSchedulingTableData.splice(
      clickedProgram.rowIndex,
      0,
      ...newProgramWithSegmentContent,
    );
    return updatedSchedulingTableData;
  } catch (error) {
    throw error;
  }
}

function getFilteredTableData(tableData, selectedFilters) {
  try {
    let filteredTableData = [...tableData];
    /* IF NO FILTER IS SELECTED, SET MAKE EVERY ROW VISIBLE */
    if (selectedFilters.length === 0)
      return filteredTableData.map((row) => ({ ...row, isFiltered: true }));
    /* APPLY ALL FILTERS ONE BY ONE */
    selectedFilters.forEach((curFilter, filterIndex) => {
      const columnKey = curFilter.columnKey;
      const filter = curFilter.filter;
      const searchValue = curFilter.searchValue.toLowerCase();
      filteredTableData = filteredTableData.map((row, index) => {
        if (index === 0) return row;
        const cellValue = row[columnKey]
          ? row[columnKey].toString().toLowerCase()
          : '';
        switch (filter) {
          case tableFilterOptionsEnum.STARTS_WITH: {
            const isFiltered = cellValue.startsWith(searchValue);
            return filterIndex === 0
              ? { ...row, isFiltered }
              : { ...row, isFiltered: row.isFiltered && isFiltered };
          }
          case tableFilterOptionsEnum.CONTAINS: {
            const isFiltered = cellValue.includes(searchValue);
            return filterIndex === 0
              ? { ...row, isFiltered }
              : { ...row, isFiltered: row.isFiltered && isFiltered };
          }
          case tableFilterOptionsEnum.NOT_CONTAINS: {
            const isFiltered = !cellValue.includes(searchValue);
            return filterIndex === 0
              ? { ...row, isFiltered }
              : { ...row, isFiltered: row.isFiltered && isFiltered };
          }
          case tableFilterOptionsEnum.ENDS_WITH: {
            const isFiltered = cellValue.endsWith(searchValue);
            return filterIndex === 0
              ? { ...row, isFiltered }
              : { ...row, isFiltered: row.isFiltered && isFiltered };
          }
          case tableFilterOptionsEnum.EQUALS: {
            const isFiltered = cellValue === searchValue;
            return filterIndex === 0
              ? { ...row, isFiltered }
              : { ...row, isFiltered: row.isFiltered && isFiltered };
          }
          case tableFilterOptionsEnum.NOT_EQUALS: {
            const isFiltered = cellValue !== searchValue;
            return filterIndex === 0
              ? { ...row, isFiltered }
              : { ...row, isFiltered: row.isFiltered && isFiltered };
          }
          case tableFilterOptionsEnum.HIDE_COMMERCIAL: {
            const isFiltered = !(
              row.F_C_S_P === rowDataTypesEnum.COMMERCIAL &&
              searchValue === 'true'
            );
            return filterIndex === 0
              ? { ...row, isFiltered }
              : { ...row, isFiltered: row.isFiltered && isFiltered };
          }
          case tableFilterOptionsEnum.SHOW_NTC: {
            const isFiltered = !(
              row.F_C_S_P === rowDataTypesEnum.NTC && searchValue === 'false'
            );
            return filterIndex === 0
              ? { ...row, isFiltered }
              : { ...row, isFiltered: row.isFiltered && isFiltered };
          }
          default:
            return { ...row, isFiltered: false };
        }
      });
    });
    return filteredTableData;
  } catch (error) {
    throw error;
  }
}

function updateOffsetStartTime(row, parentRow) {
  try {
    let updatedRow = { ...row };
    if (updatedRow.Start_Time !== '00:00:00:00') {
      updatedRow.OffsetStartTime = subtractTimes(
        updatedRow.Start_Time,
        parentRow.Start_Time,
      );
    }
    return updatedRow;
  } catch (error) {
    throw error;
  }
}

function finalizeData({
  schedulingTableData,
  secondaryTableData,
  dropBucket,
  lastMinuteSpots,
  startTime,
  newActiveFeatures,
  customCellColor,
  page,
  channel,
  isNtcGroupingEnabled,
}) {
  let newSchedulingTableData = [...schedulingTableData];
  let newSecondaryTableData = [...secondaryTableData];
  let newDropBucket = [...dropBucket];
  let newLastMinuteSpots = [...lastMinuteSpots];
  if (newSchedulingTableData.length < 2) newSchedulingTableData = [];
  else {
    let dummyRow = newSchedulingTableData.shift();
    /* UPDATE START TIME OF EACH ROW */
    newSchedulingTableData = [
      ...updateStartTimes(
        newSchedulingTableData,
        newActiveFeatures[featuresEnum.SHOW_PROGRAM_BASE_TIME],
        newActiveFeatures[featuresEnum.HIDE_COMMERCIALS],
        page === pagesEnum.NTC ? 'NTC' : undefined,
        startTime,
      ),
    ];
    /* ADD ADDITIONAL INFO TO EACH ROW */
    newSchedulingTableData = getTableDataWithAdditionalInfo({
      tableData: [dummyRow, ...newSchedulingTableData],
      tableType: tableTypesEnum.SCHEDULING,
      customCellColor,
      channel,
    });
    /* DO NTC GROUPING BASED ON NTC TYPE IF NTC GROUPING IS ENABLED */
    if (
      isNtcGroupingEnabled &&
      newSchedulingTableData.length > 0 &&
      (page === pagesEnum.NTC || page === pagesEnum.FINAL_LOG)
    ) {
      newSchedulingTableData = groupNTCBasedOnNTCGroupCode(
        newSchedulingTableData,
      );
      // dummyRow = newSchedulingTableData.shift();
      newSchedulingTableData = getTableDataWithAdditionalInfo({
        tableData: newSchedulingTableData,
        tableType: tableTypesEnum.SCHEDULING,
        customCellColor,
        channel,
      });
    }
  }
  if (newSecondaryTableData.length < 2) newSecondaryTableData = [];
  else
    newSecondaryTableData = getTableDataWithAdditionalInfo({
      tableData: newSecondaryTableData,
      tableType: tableTypesEnum.SECONDARY,
      additionalInfo: [
        additionalRowInfoEnum.ROW_ID,
        additionalRowInfoEnum.ROW_INDEX,
      ],
    });
  /* FINALIZE DROP BUCKET */
  if (Array.isArray(newDropBucket))
    if (newDropBucket.length < 2) newDropBucket = [];
    else
      newDropBucket = getTableDataWithAdditionalInfo({
        tableData: newDropBucket,
        tableType: tableTypesEnum.SECONDARY,
        additionalInfo: [
          additionalRowInfoEnum.ROW_ID,
          additionalRowInfoEnum.ROW_INDEX,
        ],
      });
  /* FINALIZE LAST MINUTE SPOTS */
  if (Array.isArray(newLastMinuteSpots))
    if (newLastMinuteSpots.length < 2) newLastMinuteSpots = [];
    else
      newLastMinuteSpots = getTableDataWithAdditionalInfo({
        tableData: newLastMinuteSpots,
        tableType: tableTypesEnum.SECONDARY,
        additionalInfo: [
          additionalRowInfoEnum.ROW_ID,
          additionalRowInfoEnum.ROW_INDEX,
        ],
      });
  return {
    newSchedulingTableData,
    newSecondaryTableData,
    newDropBucket,
    newLastMinuteSpots,
  };
}

function getCustomCellColorFromTable(tableData) {
  try {
    let customCellColor = {};
    const CELL_TYPES = ['Event_Name', 'Agency', 'Client', 'Brand', 'Product'];
    /* GET CELL WISE COLOR FOR EACH CELL TYPE */
    CELL_TYPES.forEach((cellType) => {
      customCellColor[cellType] = getCellWiseColor(tableData, cellType);
    });
    return customCellColor;
  } catch (error) {
    throw error;
  }
}

function getCellWiseColor(tableData, cellType) {
  try {
    let cellWiseColor = {};
    const cellSet = new Set();
    for (const row of tableData) {
      if (
        !row[cellType] ||
        row.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION ||
        row.F_C_S_P === rowDataTypesEnum.SEGMENT
      )
        continue;
      if (!cellSet.has(row[cellType])) {
        cellSet.add(row[cellType]);
        cellWiseColor[row[cellType]] = row.customCellColor[cellType];
      }
    }
    /* SORT LIST IN ASCENDING ORDER */
    cellWiseColor = Object.fromEntries(
      Object.entries(cellWiseColor).sort(([keyA], [keyB]) =>
        keyA.localeCompare(keyB),
      ),
    );
    return cellWiseColor;
  } catch (error) {
    throw error;
  }
}

const getTableScrolledOffset = (tableRef) => {
  try {
    if (tableRef.current) {
      return tableRef.current.state.scrollOffset;
    }
    return 0;
  } catch (error) {
    throw error;
  }
};

const getSourceRowFromDragInfo = (dragInfo, schTableData, secTableData) => {
  const sourceIndex = dragInfo.source.index;
  if (dragInfo.source.droppableId === droppableIdsEnum.SCHEDULING)
    return schTableData[sourceIndex];
  else return secTableData[sourceIndex];
};

const getCorrectedDestIndexForFilteredTable = (destIndex, tableData) => {
  let isFilteredRowFound = false;
  let newDestIndex = destIndex;
  for (let index = newDestIndex; index >= 1; index--) {
    if (index - 1 !== 0 && tableData[index - 1].isFiltered) {
      newDestIndex = index;
      isFilteredRowFound = true;
      break;
    }
  }
  if (!isFilteredRowFound) {
    for (let index = newDestIndex; index <= tableData.length; index++) {
      if (tableData[index + 1]?.isFiltered) {
        newDestIndex = index;
        break;
      }
    }
  }
  return newDestIndex;
};

const getCorrectedDestIndexForIntraTableDrag = (
  dragInfo,
  tableData,
  activeFeatures,
) => {
  const sourceIndex = dragInfo.source.index;
  const destIndex = dragInfo.destination.index;
  let destinationIndex = destIndex;
  /* DESTINATION INDEX CORRECTION IF FILTER IS ACTIVE */
  if (activeFeatures[featuresEnum.FILTER]) {
    destinationIndex = getCorrectedDestIndexForFilteredTable(
      destIndex,
      tableData,
    );
  }
  if (sourceIndex < destinationIndex) {
    /* DESTINATION INDEX CORRECTION IF DRAG IS TOP TO BOTTOM */
    destinationIndex = destinationIndex + 1;
  }
  return destinationIndex;
};

const getCorrectedDestIndexIfDestIndexIsNtc = (destIndex, tableData) => {
  let newDestIndex = destIndex;
  let curDestRow = tableData[newDestIndex];
  while (curDestRow?.F_C_S_P === rowDataTypesEnum.NTC) {
    newDestIndex++;
    curDestRow = tableData[newDestIndex];
  }
  return newDestIndex;
};

const getNTCRowsForSegment = async (segment, channel, date) => {
  try {
    const response = await apiCallstoreprocedure('USP_Sch_Get_NTC_Imports', {
      ChannelCode: channel.ChannelCode,
      LocationCode: channel.LocationCode,
      TelecastDate: convertDateToYMD(date),
      NTCTypeCode: 0,
      ContentCode: parseInt(segment.ContentCode),
      Ep_No: parseInt(segment.EpisodeNo || segment.Ep_No),
      SeasonNo: parseInt(segment.SeasonNo),
      Break: parseInt(segment.BreakNumber),
    });
    if (response.status === 200) return response.data;
    else return [];
  } catch (error) {
    return [];
  }
};

const getNowNTCsForSegment = async (segment, channel, date, type, FPC_Time) => {
  try {
    console.log('segment', segment, 'type', type, 'FPC_Time', FPC_Time)
    const eventType = type === 'Now' ? 7 : 8;

    const response = await apiCallstoreprocedure('USP_Sch_Get_NTC_Imports_Now', {
      ChannelCode: channel.ChannelCode,
      LocationCode: channel.LocationCode,
      TelecastDate: convertDateToYMD(date),
      NTCTypeCode: 0,
      ContentCode: parseInt(segment.ContentCode),
      Ep_No: parseInt(segment.EpisodeNo || segment.Ep_No),
      SeasonNo: parseInt(segment.SeasonNo),
      Break: parseInt(segment.BreakNumber),
      EventType: eventType,
      FPCTime: FPC_Time
    });
    if (response.status === 200) return response.data;
    else return [];
  } catch (error) {
    return [];
  }
};

const getPromoRowsForSegment = async (segment, channel, date) => {
  try {
    const response = await apiCallstoreprocedure('USP_Sch_Get_Promo_Imports', {
      ChannelCode: channel.ChannelCode,
      LocationCode: channel.LocationCode,
      TelecastDate: convertDateToYMD(date),
      PromoTypeCode: 0,
      ContentCode: parseInt(segment.ContentCode),
      Ep_No: parseInt(segment.Ep_No),
      SeasonNo: parseInt(segment.SeasonNo),
      Break: parseInt(segment.BreakNumber),
    });
    if (response.status === 200) return response.data;
    else return [];
  } catch (error) {
    return [];
  }
};

export {
  getDefaultActiveFeatures,
  getFeaturesList,
  getTableDataWithAdditionalInfo,
  getSchedulingTableData,
  getDroppedSpots,
  getLastMinuteSpots,
  getRowWithNTC,
  isBasicDragValid,
  isDragValidForSourceRow,
  isRowDataTypePresentInDraggedRows,
  getSegmentEndIndex,
  getRowWithCellWarnings,
  getRowWithReferenceInfo,
  getRowWithActions,
  isCommercialInsertValid,
  isNTCInsertValid,
  getNTCParentRow,
  isAnyNTCPaid,
  isNTCPlacedBelowCMOrCT,
  isNTCEndingAfterDuration,
  isPaidNTCInsertValid,
  removeRowsFromTableData,
  isSegmentValid,
  isRowLastSegment,
  isRowBetweenValidTime,
  removeAdditionalInfoFromRows,
  getSegmentWiseContent,
  getProgramWithSegmentContent,
  updateProgramInSchedulingTableData,
  getFilteredTableData,
  updateOffsetStartTime,
  finalizeData,
  getCustomCellColorFromTable,
  getTableScrolledOffset,
  getSourceRowFromDragInfo,
  getCorrectedDestIndexForFilteredTable,
  isSelectedRowsBetweenStartAndEndTime,
  getCorrectedDestIndexForIntraTableDrag,
  getCorrectedDestIndexIfDestIndexIsNtc,
  isTelTimeBetweenStartAndEndTime,
  getNTCRowsForSegment,
  getNowNTCsForSegment,
  getPromoRowsForSegment,
};
