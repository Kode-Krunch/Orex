import { js2xml } from 'xml-js';
import { saveAs } from 'file-saver';
import { parseDurationE, subtractTimes } from 'views/Controls/GLOBALFUNACTION';
import { format } from 'date-fns';
import { rowDataTypesEnum } from 'views/Scheduling/Scheduler/enum';
import { addTimes } from '../../../Summary/utils';
import { v4 as uuid } from 'uuid';

const F_C_S_P_MAPPING = {
  [rowDataTypesEnum.SEGMENT]: 'program',
  [rowDataTypesEnum.PROMO]: 'promos',
  [rowDataTypesEnum.COMMERCIAL]: 'commercials',
};

const exportPlayoutForXML = (date, tableData, channelSettings) => {
  const jsonForXml = js2xml(getJsonForXml(date, tableData, channelSettings), {
    compact: false,
    spaces: 4,
  });
  const blob = new Blob([jsonForXml], { type: 'application/xml' });
  saveAs(
    blob,
    `FinalLog${channelSettings.locations.LocationName}-${
      channelSettings.Channel.ChannelName
    }A${format(new Date(), 'ddMMyyyy')}.xml`,
  );
};

const getJsonForXml = (date, tableData, channelSettings) => {
  let curCtRow = null;
  let curSegRow = null;
  let curBreak = null;
  let itemsElements = [];
  let curReconciliationCount = 0;
  tableData.forEach((row, index) => {
    if (row.F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION) {
      curCtRow = row;
    } else if (row.F_C_S_P === rowDataTypesEnum.SEGMENT) {
      curReconciliationCount++;
      curSegRow = row;
      curBreak = curBreak
        ? subtractTimes(row.Start_Time, curBreak) > '00:30:00:00'
          ? addTimes(curBreak, '00:30:00:00')
          : curBreak
        : row.Start_Time;
      itemsElements.push(
        ...getJsonForSegment(
          row,
          curCtRow,
          date,
          curBreak.slice(0, 5),
          channelSettings,
          curReconciliationCount,
        ),
      );
    } else if (
      row.F_C_S_P === rowDataTypesEnum.PROMO ||
      row.F_C_S_P === rowDataTypesEnum.COMMERCIAL ||
      row.F_C_S_P === rowDataTypesEnum.SONG
    ) {
      curReconciliationCount++;
      itemsElements.push(
        ...getJsonForPromoCommSong(
          row,
          curSegRow,
          curCtRow,
          date,
          curBreak.slice(0, 5),
          channelSettings,
          curReconciliationCount,
        ),
      );
    }
    if (
      tableData[index + 1] &&
      tableData[index + 1].F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION
    ) {
      itemsElements.push({
        type: 'element',
        name: 'event',
        attributes: { type: 'BREAK_END' },
        elements: [
          {
            type: 'element',
            name: 'item-id',
            elements: [{ type: 'text', text: uuid() }],
          },
        ],
      });
    }
  });
  return {
    elements: [
      {
        type: 'element',
        name: 'schedule',
        elements: [
          ...getJsonForHeader(channelSettings, date),
          {
            type: 'element',
            name: 'items',
            elements: itemsElements,
          },
          {
            type: 'element',
            name: 'sched-dur',
            elements: [{ type: 'text', text: '01:41:45' }],
          },
        ],
      },
    ],
  };
};

const getJsonForHeader = (channelSettings, date) => [
  {
    type: 'element',
    name: 'channel',
    elements: [
      {
        type: 'text',
        text: `${channelSettings.locations.LocationName}-${channelSettings.Channel.ChannelName}`,
      },
    ],
  },
  {
    type: 'element',
    name: 'creat-time',
    elements: [
      {
        type: 'text',
        text: `${format(new Date(), 'dd/MM/yyyy')} ${format(
          new Date(),
          'HH:mm:ss',
        )}`,
      },
    ],
  },
  {
    type: 'element',
    name: 'sched-start-time',
    elements: [
      {
        type: 'text',
        text: `${format(date, 'yyyy-MM-dd')} ${channelSettings.StartTime.slice(
          0,
          8,
        )}`,
      },
    ],
  },
  {
    type: 'element',
    name: 'sched-end-time',
    elements: [
      {
        type: 'text',
        text: `${format(date, 'yyyy-MM-dd')} ${channelSettings.EndTime.slice(
          0,
          8,
        )}`,
      },
    ],
  },
  {
    type: 'element',
    name: 'sched-part',
    elements: [{ type: 'text', text: '0' }],
  },
];

const getJsonForSegment = (
  segment,
  ctRow,
  date,
  curBreak,
  channelSettings,
  curReconciliationCount,
) => {
  return [
    {
      type: 'element',
      name: 'item',
      elements: [
        {
          type: 'element',
          name: 'item-id',
          elements: [{ type: 'text', text: uuid() }],
        },
        {
          type: 'element',
          name: 'clip-id',
          elements: [{ type: 'text', text: segment.Video_ID }],
        },
        {
          type: 'element',
          name: 'clip-name',
          elements: [{ type: 'text', text: segment.Event_Name }],
        },
        {
          type: 'element',
          name: 'data11',
          elements: [{ type: 'text', text: channelSettings.StartTime }],
        },
        {
          type: 'element',
          name: 'data12',
          elements: [{ type: 'text', text: channelSettings.EndTime }],
        },
        {
          type: 'element',
          name: 'data13',
          elements: [{ type: 'text', text: ctRow.Event_Name }],
        },
        {
          type: 'element',
          name: 'data14',
          elements: [
            {
              type: 'text',
              text: `A${format(
                new Date(),
                'ddMMyyyy',
              )}${curReconciliationCount}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'data10',
          elements: [{ type: 'text', text: 'None' }],
        },
        {
          type: 'element',
          name: 'data9',
          elements: [{ type: 'text', text: 'NA3' }],
        },
        {
          type: 'element',
          name: 'data8',
          elements: [{ type: 'text', text: uuid() }],
        },
        {
          type: 'element',
          name: 'data7',
          elements: [{ type: 'text', text: F_C_S_P_MAPPING[segment.F_C_S_P] }],
        },
        {
          type: 'element',
          name: 'data6',
          elements: [{ type: 'text', text: uuid() }],
        },
        {
          type: 'element',
          name: 'data5',
          elements: [{ type: 'text', text: segment.Event_Name }],
        },
        {
          type: 'element',
          name: 'data4',
          elements: [{ type: 'text', text: 'None' }],
        },
        {
          type: 'element',
          name: 'clip-dur',
          elements: [{ type: 'text', text: segment.Duration }],
        },
        {
          type: 'element',
          name: 'data1',
          elements: [
            { type: 'text', text: parseDurationE(24, segment.Duration) },
          ],
        },
        {
          type: 'element',
          name: 'plan-start-time',
          elements: [
            {
              type: 'text',
              text: `${format(date, 'yyyy-MM-dd')} ${segment.Start_Time}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'start-time-min',
          elements: [
            {
              type: 'text',
              text: `${format(
                date,
                'yyyy-MM-dd',
              )} ${channelSettings.StartTime.slice(0, 8)}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'start-time-max',
          elements: [
            {
              type: 'text',
              text: `${format(
                date,
                'yyyy-MM-dd',
              )} ${channelSettings.EndTime.slice(0, 8)}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'comment',
        },
        {
          type: 'element',
          name: 'break',
          elements: [
            {
              type: 'text',
              text: `${curBreak}_${ctRow.Event_Name}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'data3',
          elements: [
            {
              type: 'text',
              text: uuid(),
            },
          ],
        },
      ],
    },
    {
      type: 'element',
      name: 'event',
      attributes: { type: 'BREAK_BEGIN' },
      elements: [
        {
          type: 'element',
          name: 'item-id',
          elements: [{ type: 'text', text: uuid() }],
        },
      ],
    },
    {
      type: 'element',
      name: 'event',
      attributes: { type: 'REPLACE_BEGIN' },
      elements: [
        {
          type: 'element',
          name: 'item-id',
          elements: [{ type: 'text', text: uuid() }],
        },
      ],
    },
  ];
};

const getJsonForPromoCommSong = (
  event,
  curSegRow,
  ctRow,
  date,
  curBreak,
  channelSettings,
  curReconciliationCount,
) => {
  return [
    {
      type: 'element',
      name: 'item',
      elements: [
        {
          type: 'element',
          name: 'item-id',
          elements: [{ type: 'text', text: uuid() }],
        },
        {
          type: 'element',
          name: 'clip-id',
          elements: [{ type: 'text', text: event.Video_ID }],
        },
        {
          type: 'element',
          name: 'clip-name',
          elements: [{ type: 'text', text: event.Event_Name }],
        },
        {
          type: 'element',
          name: 'data11',
          elements: [{ type: 'text', text: channelSettings.StartTime }],
        },
        {
          type: 'element',
          name: 'data12',
          elements: [{ type: 'text', text: channelSettings.EndTime }],
        },
        {
          type: 'element',
          name: 'data13',
          elements: [{ type: 'text', text: ctRow.Event_Name }],
        },
        {
          type: 'element',
          name: 'data14',
          elements: [
            {
              type: 'text',
              text: `A${format(
                new Date(),
                'ddMMyyyy',
              )}${curReconciliationCount}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'data10',
          elements: [{ type: 'text', text: 'None' }],
        },
        {
          type: 'element',
          name: 'data9',
          elements: [{ type: 'text', text: 'NA3' }],
        },
        {
          type: 'element',
          name: 'data8',
          elements: [{ type: 'text', text: uuid() }],
        },
        {
          type: 'element',
          name: 'data7',
          elements: [{ type: 'text', text: F_C_S_P_MAPPING[event.F_C_S_P] }],
        },
        {
          type: 'element',
          name: 'data6',
          elements: [{ type: 'text', text: uuid() }],
        },
        {
          type: 'element',
          name: 'data5',
          elements: [{ type: 'text', text: event.Event_Name }],
        },
        {
          type: 'element',
          name: 'data4',
          elements: [{ type: 'text', text: 'None' }],
        },
        {
          type: 'element',
          name: 'clip-dur',
          elements: [{ type: 'text', text: event.Duration }],
        },
        {
          type: 'element',
          name: 'data1',
          elements: [
            { type: 'text', text: parseDurationE(24, event.Duration) },
          ],
        },
        {
          type: 'element',
          name: 'plan-start-time',
          elements: [
            {
              type: 'text',
              text: `${format(date, 'yyyy-MM-dd')} ${event.Start_Time}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'start-time-min',
          elements: [
            {
              type: 'text',
              text: `${format(
                date,
                'yyyy-MM-dd',
              )} ${channelSettings.StartTime.slice(0, 8)}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'start-time-max',
          elements: [
            {
              type: 'text',
              text: `${format(
                date,
                'yyyy-MM-dd',
              )} ${channelSettings.EndTime.slice(0, 8)}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'comment',
        },
        {
          type: 'element',
          name: 'break',
          elements: [
            {
              type: 'text',
              text: `${curBreak}_${curSegRow.Event_Name}`,
            },
          ],
        },
        {
          type: 'element',
          name: 'data3',
          elements: [
            {
              type: 'text',
              text: uuid(),
            },
          ],
        },
      ],
    },
  ];
};

export { exportPlayoutForXML };
