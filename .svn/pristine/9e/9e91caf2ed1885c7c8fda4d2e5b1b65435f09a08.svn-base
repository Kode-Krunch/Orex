import { Button, Card } from 'components/ui';
import React, { useEffect, useState } from 'react';
import HeaderExtra from 'views/Controls/HeaderExtra';
import { SELECT_CHANNEL_COLUMNS } from '../constants';
import { entityTypeCodeEnum, viewsEnum } from '../enum';
import { openNotification } from 'views/Controls/GLOBALFUNACTION';
import { hideStackedSideNav_secondary } from 'views/Scheduling/general';
import { useSelector } from 'react-redux';
import {
  apiEventMasterCreate,
  apiEventMasterUpdate,
  apiGetContentmasterDrop,
  apiGetEventMasterDetails,
} from 'services/ProgrammingService';
import { FiTrash2 } from 'react-icons/fi';
import WarningDialog from 'views/Controls/WarningDialog';
import AddHeader from './AddHeader';
import Events from './Events';
import SelectableTable from './SelectableTable';
import { StickyFooter } from 'components/shared';
import { IoSaveOutline } from 'react-icons/io5';
import { apiGetChannelmasterdrop } from 'services/MasterService';
import SelectEntityDialog from './SelectEntityDialog';

function AddEditEvent({
  curView,
  setShowLoader,
  clickedActionRowData,
  resetPage,
}) {
  /* REDUX */
  const channel = useSelector((state) => state.locale.selectedChannel);
  const token = useSelector((state) => state.auth.session.token);
  const loginId = useSelector((state) => state.auth.session.LoginId);

  // States
  const [eventOptions, setEventOptions] = useState([]);
  const [selectedEvent, setSelectedEvent] = useState('');
  const [selectedEntityType, setSelectedEntityType] = useState('events');
  const [selectedEventGroup, setSelectedEventGroup] = useState('');
  const [eventGroupOptions, setEventGroupOptions] = useState([]);
  const [groupWiseSelectedEntities, setGroupWiseSelectedEntities] = useState(
    {},
  );
  // Select Channel Table States
  const [selectChannelTableData, setSelectChannelTableData] = useState([]);
  const [selectedChannelRowIndexes, setSelectedChannelRowIndexes] = useState(
    [],
  );
  const [selectedChannelRows, setSelectedChannelRows] = useState({});
  const [isSelectEntityDialogOpen, setIsSelectEntityDialogOpen] =
    useState(false);
  const [isDiscardDialogOpen, setIsDiscardDialogOpen] = useState(false);
  const [isResetDialogOpen, setIsResetDialogOpen] = useState(false);

  /* USE EFFECTS */
  useEffect(() => {
    (async () => {
      try {
        hideStackedSideNav_secondary();
        setEventOptionsFromAPI();
        setSelectChannelTableDataFromAPI();
      } catch (error) {
        openNotification(
          'danger',
          'Something went wrong. Unable to fetch Events',
        );
        console.error(error);
      }
    })();
  }, []);

  useEffect(() => {
    try {
      if (!selectedEvent) setSelectedEntityType('events');
      else
        setSelectedEntityType(
          selectedEvent.ContentTypeCode === entityTypeCodeEnum.TEAM
            ? 'teams'
            : selectedEvent.ContentTypeCode === entityTypeCodeEnum.CONTENT
            ? 'contents'
            : 'events',
        );
    } catch (error) {
      console.error(error);
    }
  }, [selectedEvent]);

  useEffect(() => {
    try {
      if (selectedEvent && selectedEventGroup) {
        setIsSelectEntityDialogOpen(true);
      }
    } catch (error) {
      console.error(error);
    }
  }, [selectedEvent, selectedEventGroup]);

  useEffect(() => {
    try {
      if (curView === viewsEnum.EDIT && clickedActionRowData) {
        initializeStateForEdit();
      }
    } catch (error) {
      console.error(error);
    }
  }, [clickedActionRowData, curView, eventOptions, selectChannelTableData]);

  /* EVENT HANDLERS */
  const handleSave = async () => {
    try {
      setShowLoader(true);
      const data = generateDataForSave();
      let response = await apiEventMasterCreate(data, token);
      if (response.status === 200) {
        openNotification('success', 'Event added successfully');
        resetPage();
      } else {
        openNotification(
          'danger',
          `Unable to add event. Server responded with status code ${response.status}`,
        );
      }
      setShowLoader(false);
    } catch (error) {
      if (
        error &&
        'response' in error &&
        error.response &&
        'data' in error.response &&
        error.response.data &&
        'detail' in error.response.data &&
        error.response.data.detail === 'Data already exists'
      ) {
        openNotification('danger', 'Data already exists for selected event');
      } else {
        openNotification('danger', 'Something went wrong. Unable to add event');
      }
      setShowLoader(false);
    }
  };

  const handleUpdate = async () => {
    try {
      setShowLoader(true);
      const data = generateDataForSave();
      let response = await apiEventMasterUpdate(
        data,
        clickedActionRowData.EventCode,
        token,
      );
      if (response.status === 200) {
        openNotification('success', 'Event updated successfully');
        resetPage();
      } else {
        openNotification(
          'danger',
          `Unable to update event. Server responded with status code ${response.status}`,
        );
      }
      setShowLoader(false);
    } catch (error) {
      openNotification(
        'danger',
        'Something update wrong. Unable to update event',
      );
      setShowLoader(false);
    }
  };

  const handleReset = () => {
    try {
      setSelectedEvent('');
      setSelectedEntityType('');
      setSelectedEventGroup('');
      setGroupWiseSelectedEntities({});
      setIsSelectEntityDialogOpen(false);
      setIsDiscardDialogOpen(false);
      setIsResetDialogOpen(false);
    } catch (error) {
      console.error(error);
    }
  };

  /* HELPER FUNCTIONS */
  const initializeStateForEdit = async () => {
    try {
      // Set Selected Event Option
      const selectedOption = eventOptions.filter(
        (option) =>
          option.ContentCode === clickedActionRowData.ContentMaster.ContentCode,
      )[0];
      selectedOption.value = clickedActionRowData.ContentMaster.ContentCode;
      selectedOption.label = clickedActionRowData.ContentMaster.ContentName;
      setSelectedEvent(selectedOption);

      const response = await apiGetEventMasterDetails(
        clickedActionRowData.EventCode,
      );
      if (response.status === 200) {
        const data = response.data;
        // Set Group wise selected entities
        if (data.EventDetails.length > 0) {
          setGroupWiseSelectedEntities(
            getGroupWiseSelectedEntites(data.EventDetails),
          );
        } else {
          openNotification('info', 'No data found for selected event');
        }
        // Set Selected Channel Row Indexes
        if (data.EventLocChannelMapping.length > 0) {
          let selectedChannelRowIndexes = {};
          data.EventLocChannelMapping.map((channel) =>
            selectChannelTableData.findIndex(
              (curChannel) =>
                curChannel.ChannelCode === channel.ChannelCode &&
                curChannel.LocationCode === channel.LocationCode,
            ),
          ).forEach((index) => {
            selectedChannelRowIndexes[index] = true;
          });
          setSelectedChannelRowIndexes(selectedChannelRowIndexes);
        }
      } else if (response.status === 204) {
        openNotification('info', 'No data found for selected event');
      } else {
        openNotification(
          'danger',
          `Something went wrong while fetching data for selected event. Server responded with status code ${response.status}`,
        );
      }
    } catch (error) {
      throw error;
    }
  };

  const getGroupWiseSelectedEntites = (eventDetails) => {
    try {
      let groupWiseSelectedEntities = {};
      Array.from(new Set(eventDetails.map((item) => item.GroupName))).forEach(
        (group) => {
          let curGroupSelectedEntities = eventDetails.filter(
            (event) => event.GroupName === group,
          );
          if (selectedEvent.ContentTypeCode === entityTypeCodeEnum.CONTENT) {
            curGroupSelectedEntities = curGroupSelectedEntities.map((item) => {
              return {
                ContentCode: item.ContentCode,
                ContentName: item.ContentName,
                Content_Image: item.Content_Image,
              };
            });
          } else {
            curGroupSelectedEntities = curGroupSelectedEntities.map((item) => {
              return {
                TeamCode: item.TeamCode,
                TeamName: item.TeamName,
                Team_Image: item.Team_Image,
              };
            });
          }
          groupWiseSelectedEntities[group] = curGroupSelectedEntities;
        },
      );
      return groupWiseSelectedEntities;
    } catch (error) {
      throw error;
    }
  };

  const setEventOptionsFromAPI = async () => {
    try {
      setShowLoader(true);
      const response = await apiGetContentmasterDrop(
        undefined,
        channel.LocationCode,
        channel.ChannelCode,
        1,
      );
      if (response.status === 200) {
        setEventOptions(
          response.data.map((item) => {
            return {
              ...item,
              value: item.ContentCode,
              label: item.ContentName,
            };
          }),
        );
      } else if (response.status === 204) {
        setEventOptions([]);
      } else {
        openNotification(
          'danger',
          `Unable to fetch Events. Server responsed with status code ${response.status}`,
        );
      }
      setShowLoader(false);
    } catch (error) {
      setShowLoader(false);
      throw error;
    }
  };

  const setSelectChannelTableDataFromAPI = async () => {
    try {
      setShowLoader(true);
      const response = await apiGetChannelmasterdrop(loginId);
      if (response.status === 200) {
        const data = response.data.map((item) => ({
          ...item,
          channelNameWithLocation: `${item.LocationName} ${item.ChannelName}`,
        }));
        setSelectChannelTableData(data);
        if (curView === viewsEnum.ADD) {
          const defaultSelectedChannelIndex = data.findIndex(
            (curChannel) =>
              curChannel.ChannelCode === channel.ChannelCode &&
              curChannel.LocationCode === channel.LocationCode,
          );
          setSelectedChannelRowIndexes({ [defaultSelectedChannelIndex]: true });
        }
      } else if (response.status === 204) {
        setSelectChannelTableData([]);
      } else {
        openNotification(
          'danger',
          `Unable to fetch channels. Server responded with status code ${response.status}`,
        );
      }
      setShowLoader(false);
    } catch (error) {
      openNotification(
        'danger',
        'Something went wrong. Unable to fetch channels',
      );
      setShowLoader(false);
      throw error;
    }
  };

  const generateDataForSave = () => {
    try {
      const channelMappings = selectedChannelRows.map((channel) => {
        return {
          LocationCode: channel.LocationCode,
          ChannelCode: channel.ChannelCode,
        };
      });
      let data = {
        request: {
          EventName: selectedEvent.ContentName,
          ContentCode: selectedEvent.ContentCode,
          IsActive: 1,
        },
        details: [],
        maping: channelMappings,
      };
      Object.keys(groupWiseSelectedEntities).forEach((group) => {
        groupWiseSelectedEntities[group].forEach((entity) => {
          if (selectedEvent.ContentTypeCode === entityTypeCodeEnum.CONTENT) {
            data.details.push({
              GroupCode: eventGroupOptions.filter(
                (eventGroup) => eventGroup.GroupName === group,
              )[0].GroupCode,
              ContentCode: entity.ContentCode,
              IsActive: 1,
            });
          } else {
            data.details.push({
              GroupCode: eventGroupOptions.filter(
                (eventGroup) => eventGroup.GroupName === group,
              )[0].GroupCode,
              TeamCode: entity.TeamCode,
              IsActive: 1,
            });
          }
        });
      });
      return data;
    } catch (error) {
      throw error;
    }
  };

  return (
    <Card
      header={<HeaderExtra Component={'Event Management'} />}
      headerExtra={
        <>
          <span className="flex items-center gap-2">
            <Button
              block
              variant="twoTone"
              size="sm"
              icon={<FiTrash2 />}
              onClick={() => setIsDiscardDialogOpen(true)}
              className="w-max"
            >
              Discard
            </Button>
          </span>
          <WarningDialog
            isDialogOpen={isDiscardDialogOpen}
            title="Discard"
            description={`Are you sure you want to discard?`}
            submitButtonTitle="Discard"
            handleDialogSubmit={resetPage}
            handleDialogClose={() => setIsDiscardDialogOpen(false)}
          />
        </>
      }
      className="flex flex-col min-h-[87vh]"
      bodyClass="grow p-5 pt-4 flex flex-col"
    >
      <div className="grow grid grid-cols-4 gap-4">
        <div className="col-span-3 border-r border-r-gray-700 pr-4 min-h-full flex flex-col">
          <div className="pb-6">
            <p className="text-slate-300 text-lg font-semibold mb-3">
              Map Events
            </p>
            <AddHeader
              curView={curView}
              eventOptions={eventOptions}
              selectedEvent={selectedEvent}
              setSelectedEvent={setSelectedEvent}
              selectedEventGroup={selectedEventGroup}
              setSelectedEventGroup={setSelectedEventGroup}
              eventGroupOptions={eventGroupOptions}
              setEventGroupOptions={setEventGroupOptions}
              groupWiseSelectedEntities={groupWiseSelectedEntities}
              setShowLoader={setShowLoader}
            />
          </div>
          <div className="grow flex flex-col">
            <p className="text-slate-300 text-lg font-semibold mb-3">
              Mapped <span className="capitalize">{selectedEntityType}</span>
            </p>
            <div className="grow">
              <Events
                groupWiseSelectedEntities={groupWiseSelectedEntities}
                setGroupWiseSelectedEntities={setGroupWiseSelectedEntities}
                selectedEntityType={selectedEntityType}
                entityTypeCode={selectedEvent.ContentTypeCode}
                setIsSelectEntityDialogOpen={setIsSelectEntityDialogOpen}
                setSelectedEventGroup={setSelectedEventGroup}
                gridCols={3}
              />
            </div>
          </div>
        </div>
        <div className="grow flex flex-col gap-1">
          <p className="text-slate-300">
            Select Channel <span className="text-red-500">*</span>
          </p>
          <div className="grow border border-gray-700">
            <SelectableTable
              data={selectChannelTableData}
              columns={SELECT_CHANNEL_COLUMNS}
              selectedRowIndexes={selectedChannelRowIndexes}
              setSelectedRows={setSelectedChannelRows}
            />
          </div>
        </div>
      </div>
      <SelectEntityDialog
        channel={channel}
        isSelectEntityDialogOpen={isSelectEntityDialogOpen}
        setIsSelectEntityDialogOpen={setIsSelectEntityDialogOpen}
        selectedEventGroup={selectedEventGroup}
        setSelectedEventGroup={setSelectedEventGroup}
        groupWiseSelectedEntities={groupWiseSelectedEntities}
        setGroupWiseSelectedEntities={setGroupWiseSelectedEntities}
        entityTypeCode={selectedEvent.ContentTypeCode}
        setShowLoader={setShowLoader}
      />
      <WarningDialog
        isDialogOpen={isResetDialogOpen}
        title="Reset"
        description={`Are you sure you want to reset?`}
        submitButtonTitle="Reset"
        handleDialogSubmit={handleReset}
        handleDialogClose={() => setIsResetDialogOpen(false)}
      />
      <StickyFooter
        className="-mx-8 px-12 flex items-center justify-end py-4 mt-4"
        stickyClass="border-t bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700"
      >
        <div className="flex gap-3">
          <Button
            disabled={
              !selectedEvent ||
              Object.keys(groupWiseSelectedEntities).length === 0
            }
            onClick={() => setIsResetDialogOpen(true)}
          >
            Reset
          </Button>
          <Button
            variant="solid"
            icon={<IoSaveOutline />}
            onClick={curView === viewsEnum.ADD ? handleSave : handleUpdate}
            disabled={
              !selectedEvent ||
              Object.keys(groupWiseSelectedEntities).length === 0 ||
              selectedChannelRows.length === 0
            }
          >
            Save
          </Button>
        </div>
      </StickyFooter>
    </Card>
  );
}

export default AddEditEvent;
