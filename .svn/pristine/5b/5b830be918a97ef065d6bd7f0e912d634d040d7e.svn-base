import { useEffect, useState } from 'react';
import './index.css';
import { Card, toast, Notification, Button, Tooltip } from 'components/ui';
import Stepper from './Stepper';
import { ARUN, convertDateToYMD } from 'components/validators';
import { apiCallstoreprocedure } from 'services/CommonService';
import { useDispatch, useSelector } from 'react-redux';
import SummaryCard from './SummaryCard';
import { RiDownloadCloud2Line } from 'react-icons/ri';
import RetrievedDataSummary from './RetrievedDataSummary';
import { apiAsrunCreate } from 'services/BillingService';
import { MdCompare, MdOutlineArrowBack } from 'react-icons/md';
import MatchedDataSummary from './MatchedDataSummary';
import ImportedDataSummary from './ImportedDataSummary';
import { CalendarView, Container } from 'components/shared';
import { apiGetDailyFPCStatus } from 'services/SchedulingService';
import {
  isChannelSelected,
  openNotification,
} from 'views/Controls/GLOBALFUNACTION';
import SelectChannelDialog from 'views/Controls/SelectChannelDialog';
import {
  setIsSelectChannelDialogOpen,
  setdateForm,
} from 'store/locale/localeSlice';
import { asunMatchingRouteTitle } from 'configs/routes.config';
import { telecastStatus } from './components/ManualMatch/enums';
import {
  GREEN_700,
  RED_700,
} from 'views/Controls/Dashboard/constants/tw_colors';
import ManualMatchDialog from './components/ManualMatch/ManualMatchDialog';
import { summaryEnum, viewEnum } from './enums';
import Loader from 'views/Controls/Loader';
import appConfig from 'configs/app.config';
import { CLIENT } from 'views/Controls/clientListEnum';

function AsrunMatching() {
  /* REDUX*/
  const channel = useSelector((state) => state.locale.selectedChannel);
  const token = useSelector((state) => state.auth.session.token);
  const currentRouteTitle = useSelector(
    (state) => state.base.common.currentRouteTitle,
  );
  const dipatch = useDispatch();
  /* STATES */
  const [calendarMonth, setCalendarMonth] = useState(new Date());
  const [date, setDate] = useState(null);
  const [telecastedSpotsDetails, setTelecastedSpotsDetails] = useState(null);
  const [retrievedData, setRetrievedData] = useState(null);
  const [importedData, setImportedData] = useState(null);
  const [matchedData, setMatchedData] = useState(null);
  const [events, setevents] = useState(null);
  // UI States
  const [curView, setCurView] = useState(viewEnum.asrunMatching);
  const [step, setStep] = useState(0);
  const [stepLoaders, setStepLoaders] = useState({
    retrievedDataLoader: false,
    importDataLoader: false,
    matchLoader: false,
  });
  const [activeSummary, setActiveSummary] = useState(null);
  const [showLoader, setShowLoader] = useState(false);
  const [isManualMatchDialogOpen, setIsManualMatchDialogOpen] = useState(false);

  /* USE EFFECTS */
  useEffect(() => {
    const gboxElement = document.getElementsByClassName('Gbox2')[0];
    const gboxElementchild =
      document.getElementsByClassName('Gbox2')[0].children[1];
    if (gboxElement) {
      gboxElement.style.display = 'block';
      gboxElementchild.style.display = 'block';
    } // Optionally, you might want to revert the change when the component unmounts
    return () => {
      if (gboxElement) {
        gboxElement.style.display = 'none';
        gboxElementchild.style.display = 'none';
      }
    };
  }, []);

  useEffect(() => {
    try {
      dipatch(
        setdateForm([
          date,
          currentRouteTitle === asunMatchingRouteTitle
            ? 'Asrun Match'
            : 'NTC Asrun Match',
        ]),
      );
    } catch (error) {
      console.error(error);
    }
  }, [currentRouteTitle, date]);

  useEffect(() => {
    (async () => {
      try {
        setShowLoader(true);
        let data = {};
        data.LocationCode = channel.LocationCode;
        data.ChannelCode = channel.ChannelCode;

        data.Screen = 'ASRUN';
        let TelecastDate = convertDateToYMD(calendarMonth);
        let response;
        setevents(null);
        if (currentRouteTitle === asunMatchingRouteTitle) {
          response = await apiGetDailyFPCStatus(data, TelecastDate);
        } else {
          data.Screen = 'NTCASRUN';
          response = await apiGetDailyFPCStatus(data, TelecastDate);
        }
        if (response) {
          if (response.status === 200) {
            setevents(ARUN(response.data));
          } else if (response.status == 404) {
            openNotification('warning', 'Data Not Found');
            setevents(null);
          } else if (response.status == 500) {
            openNotification('danger', 'Server Error.');
            setevents(null);
          }
        }
        setShowLoader(false);
      } catch (error) {
        openNotification(
          'danger',
          'Something went wrong while fetching FPC Status',
        );
        setShowLoader(false);
        console.error(error);
      }
    })();
  }, [calendarMonth, channel]);

  useEffect(() => {
    try {
      resetState();
    } catch (error) {
      console.error(error);
    }
  }, [channel]);

  /* EVENT HANDLERS */
  const handleDateClick = async (event, type) => {
    try {
      setShowLoader(true);
      let isPresent = false;
      let date = null;
      if (type === 'select') {
        date = convertDateToYMD(event.start);
        isPresent = events.some((row) => row.start === event.startStr);
      } else if (type === 'event') {
        date = event.event.startStr;
        isPresent = events.some((row) => row.start === event.event.startStr);
      }
      if (isPresent) {
        if (isTelecastedSpotsPresent(date)) {
          setCurView(viewEnum.telecastedSpotsSummary);
          await setTelecastedSpotDetailsFromSP(date);
        } else {
          handleRetrieve(date);
        }
        setDate(date);
      } else {
        openNotification('info', 'Spots not schedule for selected date');
      }
      setShowLoader(false);
    } catch (error) {
      openNotification(
        'danger',
        'Something went wrong while fetching AsRun Data',
      );
      setShowLoader(false);
      console.error(error);
    }
  };

  const handleImport = async (files) => {
    try {
      setShowLoader(true);
      setStepLoaders({ ...stepLoaders, importDataLoader: true });

      if (importedData && matchedData) {
        // Reset next steps done for previous import
        setMatchedData(null);
      }

      const selectedFile = files[0];
      const fileExt = selectedFile.name.split('.').pop();
      const reader = new FileReader();

      reader.onload = async (event, index) => {
        const arrayBuffer = event.target.result;
        let tableData = [];
        // For FOODFOOD CLIENT For USA
        if (fileExt === 'txt' && channel.label == CLIENT.FOOD_USA) {
          const text = new TextDecoder().decode(arrayBuffer);
          let lines = text.split('\n');
          lines.slice(0).forEach((line) => {
            // Trim leading/trailing spaces from the line
            line = line.trim();
            const values = line.split(/\s+/);
            if (
              values[3] !== undefined &&
              values[3] !== 'FileName' &&
              values[3] !== 'FileName:' &&
              values[0] !== 'From:' &&
              values[0] !== 'From' &&
              values[1] !== ':' &&
              values[0] !== 'Created' &&
              values[0] !== 'Created:'
            ) {
              tableData.push({
                Time: values[4]?.trim(),
                FileName: values[5]?.trim(),
                Title: values[6]?.trim(),
                ActualDuration: values[7]?.trim(),
                Status: 1,
              });
            }
          });
        }
        // For FOODFOOD CLIENT For India
        else if (fileExt === 'txt' && channel.label == CLIENT.FOOD_INDIA) {
          const text = new TextDecoder().decode(arrayBuffer);
          let lines = text.split('\n');
          lines.slice(0).forEach((line) => {
            // Trim leading/trailing spaces from the line
            line = line.trim();
            const values = line.split('|');
            if (values[3] !== undefined && values[3] !== 'FileName') {
              tableData.push({
                Time: values[0]?.trim().split('-')[1],
                FileName: values[2]?.trim(),
                Title: values[3]?.trim(),
                ActualDuration: values[4]?.trim(),
                Status: 0,
              });
            }
          });
        } else if (fileExt === 'asr') {
          const text = new TextDecoder().decode(arrayBuffer);
          let lines = text.split('\n');
          lines.forEach((line, index) => {
            if (index !== lines.length - 1) {
              if (line.length >= 105) {
                tableData.push({
                  Time: line.substring(10, 21).trim(),
                  FileName: line.substring(22, 32).trim(),
                  Title: line.substring(60, 92).trim(),
                  ActualDuration: line.substring(94, 105).trim(),
                  Status: 0,
                });
              }
            }
          });
        } else if (fileExt === 'log') {
          // This line is only for Swami
          const text = new TextDecoder('utf-16').decode(arrayBuffer);
          let lines = text.split('\n');
          lines.splice(0, 2); // Removes first two lines
          lines.splice(1, 1); // Removes data type line
          lines.slice(1).forEach((line) => {
            // Trim leading/trailing spaces from the line
            line = line.trim();
            // Skip lines that start with "Date" or "#LOGHEADER"
            if (line.startsWith('Date') || line.startsWith('#LOGHEADER')) {
              return;
            }
            const values = line.split('\t');
            if (values[3] !== undefined && values[3] !== 'FileName') {
              tableData.push({
                Time: values[1]?.trim(),
                FileName: values[3]?.split('\\')?.pop()?.split('.')[0],
                Title: values[4]?.trim(),
                ActualDuration: values[7]?.trim(),
                Status: 0,
              });
            }
          });
        }

        // API call to upload the tableData
        let response;
        if (currentRouteTitle === asunMatchingRouteTitle) {
          response = await apiAsrunCreate(
            tableData,
            date,
            channel.LocationCode,
            channel.ChannelCode,
            token,
          );
        } else {
          /* CALL NTC API HERE */
        }
        if (response.status === 200) {
          setImportedData(tableData);
          nextStep(2);
          setActiveSummary(summaryEnum.importedData);
          showToast(`Spots imported successfully.`, 'success', 2000);
        } else {
          showToast(
            `Something went wrong while importing the file. Server responded with status code ${response.status}.`,
            'danger',
            2000,
          );
        }
        setStepLoaders({ ...stepLoaders, importDataLoader: false });
        setShowLoader(false);
      };

      reader.readAsArrayBuffer(selectedFile);
    } catch (error) {
      openNotification('danger', 'Something went wrong while importing file');
      setStepLoaders({ ...stepLoaders, importDataLoader: false });
      setShowLoader(false);
      console.error(error);
    }
  };

  const handleMatch = async () => {
    try {
      setShowLoader(true);
      setStepLoaders({ ...stepLoaders, matchLoader: true });
      // API call to match the data
      let param = {
        ChannelCode: channel.ChannelCode,
        LocationCode: channel.LocationCode,
        TelecastDate: date,
      };
      let response;
      if (currentRouteTitle === asunMatchingRouteTitle) {
        response = await apiCallstoreprocedure(
          'USP_Billing_Asrun_MatchLogic',
          param,
        );
      } else {
        /* CALL NTC API HERE */
      }
      if (response.status === 200) {
        setMatchedData({
          matchedSpots: filterMatchedData(response.data, 'matched'),
          missedSpots: filterMatchedData(response.data, 'missed'),
          allSpots: filterMatchedData(response.data, 'all'),
          actualMatchedDataResponse: response.data,
        });
        nextStep(step + 1);
        setActiveSummary(summaryEnum.matchedData);
        showToast('Spots matched successfully.', 'success', 2000);
      } else {
        showToast(
          `Something went wrong. Server responded with status code ${response.status}.`,
          'danger',
          2000,
        );
      }

      setStepLoaders({ ...stepLoaders, retrievedDataLoader: false });
      setShowLoader(false);
    } catch (error) {
      setStepLoaders({ ...stepLoaders, matchLoader: false });
      setShowLoader(false);
      if (error.response.status === 404) {
        showToast(`No match found for selected date.`, 'info', 2000);
      } else if (error.response.status) {
        showToast(
          `Something went wrong. Server responded with status code ${error.response.status}.`,
          'danger',
          2000,
        );
      } else {
        showToast(`Something went wrong.`, 'danger', 2000);
      }
      console.error(error);
    }
  };

  const handleToggleRetrieveData = async () => {
    try {
      setCurView(viewEnum.asrunMatching);
      setTelecastedSpotsDetails(null);
      handleRetrieve(date);
    } catch (error) {
      console.error(error);
    }
  };

  /* HELPER FUNCTIONS */
  const isTelecastedSpotsPresent = (date) => {
    try {
      return (
        events.filter(
          (event) =>
            event.start === date &&
            event.eventColor === 'yellow' &&
            parseInt(event.title.split(':')[1].trim()) > 0,
        ).length > 0
      );
    } catch (error) {
      throw error;
    }
  };

  const setTelecastedSpotDetailsFromSP = async (date) => {
    try {
      const param = {
        par_LocationCode: channel.LocationCode,
        par_ChannelCode: channel.ChannelCode,
        par_TelecastDate: date,
      };
      const response = await apiCallstoreprocedure(
        'usp_Billing_ShowAsrun',
        param,
      );
      if (response.status === 200) {
        setTelecastedSpotsDetails({
          matchedSpots: filterMatchedData(response.data, 'matched'),
          missedSpots: filterMatchedData(response.data, 'missed'),
          allSpots: response.data,
          actualMatchedDataResponse: response.data,
        });
      } else {
        openNotification(
          'danger',
          `Something went wrong while fetching telecasted spots details. Server responded with status code ${response.status}`,
        );
      }
    } catch (error) {
      openNotification(
        'danger',
        `Something went wrong while fetching telecasted spots details`,
      );
      throw error;
    }
  };

  const handleRetrieve = async (date) => {
    try {
      setShowLoader(true);
      setStepLoaders({ ...stepLoaders, retrievedDataLoader: true });

      // API call to retreive data for selected date
      let param = {
        ChannelCode: channel.ChannelCode,
        LocationCode: channel.LocationCode,
        TelecastDate: date,
      };
      let response;
      if (currentRouteTitle === asunMatchingRouteTitle) {
        response = await apiCallstoreprocedure(
          'USP_Billing_Asrun_RetrivePlaylistData',
          param,
        );
      } else {
        response = await apiCallstoreprocedure(
          'USP_Billing_NTCAsrun_RetrivePlaylistData',
          param,
        );
      }
      if (response.status === 200) {
        setRetrievedData(response.data);
        setActiveSummary(summaryEnum.retrievedData);
        nextStep(step + 1);
        showToast('Spots retrieved successfully.', 'success', 2000);
      } else if (response.status === 204) {
        setRetrievedData([]);
        setActiveSummary(summaryEnum.retrievedData);
        nextStep(step + 1);
      } else {
        showToast(
          `Something went wrong. Server responded with status code ${response.status}.`,
          'danger',
          2000,
        );
      }

      setStepLoaders({ ...stepLoaders, retrievedDataLoader: false });
      setShowLoader(false);
    } catch (error) {
      setStepLoaders({ ...stepLoaders, retrievedDataLoader: false });
      setShowLoader(false);
      if (error.response.status === 404) {
        showToast(`No spots to show for selected date.`, 'info', 2000);
      } else if (error.response.status) {
        showToast(
          `Something went wrong. Server responded with status code ${error.response.status}.`,
          'danger',
          2000,
        );
      } else {
        showToast(`Something went wrong.`, 'danger', 2000);
      }
      console.error(error);
    }
  };

  const nextStep = (nextStep) => {
    try {
      if (nextStep < 0) {
        setStep(0);
      } else if (nextStep > 3) {
        setStep(3);
      } else {
        setStep(nextStep);
      }
    } catch (error) {
      console.error(error);
    }
  };

  const resetState = () => {
    try {
      setCalendarMonth(new Date());
      setDate(null);
      setTelecastedSpotsDetails(null);
      setRetrievedData(null);
      setImportedData(null);
      setMatchedData(null);
      setevents(null);
      setCurView(viewEnum.asrunMatching);
      setStep(0);
      setStepLoaders({
        retrievedDataLoader: false,
        importDataLoader: false,
        matchLoader: false,
      });
      setActiveSummary(null);
      setShowLoader(false);
      setIsManualMatchDialogOpen(false);
    } catch (error) {
      console.error(error);
    }
  };

  const showToast = (message, type, duration) => {
    try {
      toast.push(
        <Notification closable type={type} duration={duration}>
          {message}
        </Notification>,
      );
    } catch (error) {
      console.error(error);
    }
  };

  const filterMatchedData = (data, type) => {
    try {
      let filteredSpots = [];
      if (type === 'matched') {
        data.forEach((spot) => {
          if (spot.OutputTable === 'MatchedSpots') {
            let spotWithBgColor = { ...spot };
            spotWithBgColor.bgColor = GREEN_700;
            spotWithBgColor.fontColor = 'white';
            filteredSpots.push(spotWithBgColor);
          }
        });
      } else if (type === 'missed') {
        data.forEach((spot) => {
          if (spot.OutputTable === 'UnMatchedSpots') {
            let spotWithBgColor = { ...spot };
            spotWithBgColor.bgColor = RED_700;
            spotWithBgColor.fontColor = 'white';
            filteredSpots.push(spotWithBgColor);
          }
        });
      } else if (type === 'all') {
        data.forEach((spot) => {
          if (spot.OutputTable === 'AllSpots') {
            let spotWithBgColor = { ...spot };
            spotWithBgColor.fontColor = 'white';
            if (spot.Remark === telecastStatus.TELECASTED) {
              spotWithBgColor.bgColor = GREEN_700;
            } else {
              spotWithBgColor.bgColor = RED_700;
            }
            filteredSpots.push(spotWithBgColor);
          }
        });
      }
      return filteredSpots;
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <div className="p-4 min-h-full asrun-matching-container flex flex-col gap-4 dark:!bg-[#1f2639] !bg-[#fff]">
      <div className="flex justify-end items-center">
        {date && (
          <div className="flex gap-2">
            {curView === viewEnum.telecastedSpotsSummary && (
              <>
                <Button
                  size="sm"
                  variant="twoTone"
                  icon={<RiDownloadCloud2Line />}
                  onClick={handleToggleRetrieveData}
                >
                  Retrieve Data
                </Button>
                <Button
                  size="sm"
                  variant="twoTone"
                  icon={<MdCompare />}
                  onClick={() => setIsManualMatchDialogOpen(true)}
                >
                  Manual Match
                </Button>
              </>
            )}
            <Tooltip title="Back">
              <Button
                size="sm"
                icon={<MdOutlineArrowBack />}
                onClick={resetState}
              >
                Back
              </Button>
            </Tooltip>
          </div>
        )}
      </div>

      {!date ? (
        <Container style={{ height: 570 }}>
          <CalendarView
            events={events}
            select={(event) => {
              if (isChannelSelected(channel)) {
                handleDateClick(event, 'select');
              } else {
                dipatch(setIsSelectChannelDialogOpen(true));
              }
            }}
            eventClick={(event) => {
              handleDateClick(event, 'event');
            }}
            dayCellClassNames="hover:cursor-pointer"
            validRange={{
              end: new Date(),
            }}
            selectable
            datesSet={(dateInfo) =>
              setCalendarMonth(dateInfo.view.getCurrentData().currentDate)
            }
          />
        </Container>
      ) : (
        <>
          {curView === viewEnum.asrunMatching ? (
            <>
              <Stepper
                step={step}
                handleImport={handleImport}
                stepLoaders={stepLoaders}
                handleMatch={handleMatch}
              />
              {/* Top Level Summary Cards*/}
              {(retrievedData || importedData || matchedData) && (
                <div className="grid grid-cols-4 gap-4">
                  {retrievedData && (
                    <SummaryCard
                      id={summaryEnum.retrievedData}
                      className="col-span-1"
                      value={retrievedData.length}
                      label="Retrieved Spots"
                      icon={<RiDownloadCloud2Line />}
                      avatar={{ className: '!bg-indigo-600' }}
                      active={activeSummary === summaryEnum.retrievedData}
                      setActiveSummary={setActiveSummary}
                    />
                  )}
                  {importedData && (
                    <SummaryCard
                      id={summaryEnum.importedData}
                      className="col-span-1"
                      value={importedData.length}
                      label="Imported Spots"
                      icon={<RiDownloadCloud2Line />}
                      avatar={{ className: '!bg-yellow-600' }}
                      active={activeSummary === summaryEnum.importedData}
                      setActiveSummary={setActiveSummary}
                    />
                  )}
                  {matchedData && (
                    <SummaryCard
                      id={summaryEnum.matchedData}
                      className="col-span-1"
                      value={
                        matchedData.matchedSpots.length +
                        matchedData.missedSpots.length
                      }
                      label="Total Spots"
                      icon={<MdCompare />}
                      avatar={{ className: '!bg-green-600' }}
                      active={activeSummary === summaryEnum.matchedData}
                      setActiveSummary={setActiveSummary}
                    />
                  )}
                </div>
              )}
              {/* Summary of Retrieved Data */}
              {retrievedData && activeSummary === summaryEnum.retrievedData && (
                <Card>
                  <RetrievedDataSummary
                    data={retrievedData}
                    date={date}
                    channel={channel}
                    currentRouteTitle={currentRouteTitle}
                    token={token}
                  />
                </Card>
              )}
              {/* Summary of Imported Data */}
              {importedData && activeSummary === summaryEnum.importedData && (
                <Card>
                  <ImportedDataSummary data={importedData} />
                </Card>
              )}
              {/* Summary of Matched Data */}
              {matchedData && activeSummary === summaryEnum.matchedData && (
                <Card className="h-full" bodyClass="h-full">
                  <MatchedDataSummary
                    data={matchedData}
                    channel={channel}
                    telecastDate={date}
                    currentRouteTitle={currentRouteTitle}
                    token={token}
                  />
                </Card>
              )}
            </>
          ) : (
            <>
              {telecastedSpotsDetails ? (
                <div className="pt-6 border-t-2 border-t-gray-700">
                  <MatchedDataSummary
                    data={telecastedSpotsDetails}
                    channel={channel}
                    telecastDate={date}
                    currentRouteTitle={currentRouteTitle}
                    token={token}
                  />
                </div>
              ) : (
                <div className="h-full flex justify-center items-center border-t-2 border-t-gray-700">
                  No data to show
                </div>
              )}
            </>
          )}
        </>
      )}
      <ManualMatchDialog
        isManualMatchDialogOpen={isManualMatchDialogOpen}
        setIsManualMatchDialogOpen={setIsManualMatchDialogOpen}
        channel={channel}
        date={date}
        currentRouteTitle={currentRouteTitle}
        token={token}
      />
      <SelectChannelDialog />
      <Loader showLoader={showLoader} />
    </div>
  );
}

export default AsrunMatching;
