import {
  additionalRowInfoEnum,
  droppableIdsEnum,
  tableTypesEnum,
} from '../../../enum';
import {
  getNTCParentRow,
  getRowWithNTC,
  getTableDataWithAdditionalInfo,
  removeRowsFromTableData,
} from '../../utils';
import {
  getCorrectedDestIndexForSecTableDrag,
  getCorrectedDestIndex,
  isNTCDragValid,
  updatePropOfNTCs,
  validateNTCs,
} from './utils';
import {
  getFlatArrForGroupedArr,
  getGroupedRows,
  openNotification,
} from 'views/Controls/GLOBALFUNACTION';
import { addTimes } from 'views/Scheduling/Scheduler/components/SchedulingArea/components/Summary/utils';

const executeSecNTCDrag = (
  dragInfo,
  schTableData,
  secTableData,
  secTableSelectedRows,
  activeFeatures,
  channel,
  isAutoCalculateOffsetTime,
) => {
  try {
    const sourceDroppableId = dragInfo.source.droppableId;
    const destinationDroppableId = dragInfo.destination.droppableId;
    const selectedRows =
      secTableSelectedRows.length > 0
        ? secTableSelectedRows
        : [secTableData[dragInfo.source.index]];
    let newSchTableData = [...schTableData],
      newSecTableData;
    if (
      sourceDroppableId === droppableIdsEnum.SECONDARY &&
      destinationDroppableId === droppableIdsEnum.SECONDARY
    ) {
      newSecTableData = executeSecTableDrag(
        dragInfo,
        secTableData,
        selectedRows,
        activeFeatures,
      );
    } else if (
      sourceDroppableId === droppableIdsEnum.SECONDARY &&
      destinationDroppableId === droppableIdsEnum.SCHEDULING
    ) {
      const result = executeSecToSchTableDrag(
        dragInfo,
        schTableData,
        secTableData,
        selectedRows,
        activeFeatures,
        channel,
        isAutoCalculateOffsetTime,
      );
      if (!result) return false;
      newSchTableData = result.newSchTableData;
      newSecTableData = result.newSecTableData;
    }
    return { newSchTableData, newSecTableData };
  } catch (error) {
    throw error;
  }
};

const executeSecTableDrag = (
  dragInfo,
  tableData,
  selectedRows,
  activeFeatures,
) => {
  try {
    let newTableData = [...tableData];
    let selectedRowsWithNewRowId = getTableDataWithAdditionalInfo({
      tableData: selectedRows,
      tableType: tableTypesEnum.SECONDARY,
      additionalInfo: [additionalRowInfoEnum.ROW_ID],
    });
    let destinationIndex = getCorrectedDestIndexForSecTableDrag(
      dragInfo,
      tableData,
      activeFeatures,
    );
    newTableData.splice(destinationIndex, 0, ...selectedRowsWithNewRowId);
    newTableData = removeRowsFromTableData(selectedRows, newTableData);
    return newTableData;
  } catch (error) {
    throw error;
  }
};

const executeSecToSchTableDrag = (
  dragInfo,
  schTableData,
  secTableData,
  selectedRows,
  activeFeatures,
  channel,
  isAutoCalculateOffsetTime,
) => {
  try {
    let destinationIndex = getCorrectedDestIndex(
      dragInfo.destination.index,
      schTableData,
      activeFeatures,
    );
    /* DRAG VALIDATION */
    if (!isNTCDragValid(dragInfo, schTableData, destinationIndex)) return false;
    return executeSecToSchTableNtcInsert(
      schTableData,
      secTableData,
      destinationIndex,
      selectedRows,
      channel,
      isAutoCalculateOffsetTime,
    );
  } catch (error) {
    throw error;
  }
};

const executeSecToSchTableNtcInsert = (
  schTableData,
  secTableData,
  destIndex,
  selectedRows,
  channel,
  isAutoCalculateOffsetTime,
) => {
  let newSchTableData = [...schTableData];
  let newSecTableData = [...secTableData];
  let secTableRowsToRemove = [];
  if (isAutoCalculateOffsetTime) {
    // Get ntc parent row
    let ntcParentRow = getNTCParentRow(destIndex, schTableData);
    const { newTableData, insertedNTCs } =
      insertNTCsBasedOnOffsetTimeAutoCalculation(
        ntcParentRow,
        selectedRows,
        schTableData,
        destIndex,
      );
    newSchTableData = newTableData;
    // If few NTCs are not inserted, give notification to user
    if (insertedNTCs.length < selectedRows.length)
      openNotification(
        'danger',
        'Some NTCs are not inserted due to insufficient duration.',
      );
    // If inserted NTCs are paid NTCs, remove them from secondary table
    if (insertedNTCs[0].BookingDetailsID) {
      secTableRowsToRemove = insertedNTCs;
    }
  } else {
    const validNTCs = validateNTCs({
      destIndex: destIndex,
      tableData: newSchTableData,
      selectedRows,
      channel,
      isAutoCalculateOffsetTime,
    });
    if (!validNTCs) return false;
    newSchTableData.splice(destIndex, 0, ...validNTCs);
    // If few NTCs are not inserted, give notification to user
    if (validNTCs.length < selectedRows.length)
      openNotification(
        'danger',
        'Some NTCs are not inserted due to insufficient duration.',
      );
    if (validNTCs[0].BookingDetailID) secTableRowsToRemove = validNTCs;
  }
  // Remove inserted rows from secondary table
  newSecTableData = removeRowsFromTableData(
    secTableRowsToRemove,
    newSecTableData,
  );
  return { newSchTableData, newSecTableData };
};

const insertNTCsBasedOnOffsetTimeAutoCalculation = (
  parentRow,
  selectedRows,
  tableData,
  destIndex,
) => {
  // Get grouped selected NTCs
  const groupedSelectedNTCs = getGroupedRows(selectedRows, 'NTCGroupCode');
  // Get all ntcs for parent row
  const existingNTCs = getRowWithNTC([parentRow], tableData, false);
  // Get grouped existing NTCs
  const groupedExistingNTCs = getGroupedRows(existingNTCs, 'NTCGroupCode');
  // Iterate over each group and insert valid NTCs
  const { newGroupedNTCs, insertedNTCs } = insertValidSelNTCsInRespectiveGroups(
    groupedExistingNTCs,
    groupedSelectedNTCs,
    destIndex,
    parentRow,
  );
  // Flat the grouped NTCs
  const flattenedNewGroupedNTCs = getFlatArrForGroupedArr(newGroupedNTCs);
  // Add new row id to NTCs
  let ntcsWithNewRowId = getTableDataWithAdditionalInfo({
    tableData: flattenedNewGroupedNTCs,
    tableType: tableTypesEnum.SCHEDULING,
    additionalInfo: [additionalRowInfoEnum.ROW_ID],
  });
  // Insert NTCs
  let newTableData = [...tableData];
  // Remove old NTCs from its parent row
  newTableData = removeRowsFromTableData(existingNTCs, newTableData);
  // Insert new NTCs below its parent row
  newTableData.splice(
    newTableData.findIndex((row) => row.rowId === parentRow.rowId) + 1,
    0,
    ...ntcsWithNewRowId,
  );
  return { newTableData, insertedNTCs };
};

const insertValidSelNTCsInRespectiveGroups = (
  groupedExistingNTCs,
  groupedSelectedNTCs,
  destIndex,
  parentRow,
) => {
  let newGroupedNTCs = {};
  let insertedNTCs = [];
  let tempGroupedExistingNTCs = { ...groupedExistingNTCs };
  let existingNTCGroups = Object.keys(tempGroupedExistingNTCs);
  if (existingNTCGroups.length === 0) {
    // If no NTCs is present in parent row, create temporary NTC groups from selected NTCs
    Object.keys(groupedSelectedNTCs).forEach((groupCode) => {
      tempGroupedExistingNTCs[groupCode] = [];
      existingNTCGroups.push(groupCode);
    });
  }
  // Insert selected NTCs in respective groups
  existingNTCGroups.forEach((groupCode) => {
    // Get existing NTCs of current group
    const existingNTCs = tempGroupedExistingNTCs[groupCode];
    // Get selected NTCs of current group
    const selectedNTCs = groupedSelectedNTCs[groupCode];
    if (!selectedNTCs) {
      newGroupedNTCs[groupCode] = tempGroupedExistingNTCs[groupCode];
    } else {
      // Get destination index to insert selected NTCs
      const destIndexForGroup = existingNTCs.findIndex(
        (row) => row.rowIndex === destIndex,
      );
      if (destIndexForGroup === -1) {
        // If NTCs is placed in other group, insert NTCs at the end of current group
        const result = insertValidNTCsAtTheEnd(
          existingNTCs,
          selectedNTCs,
          parentRow,
        );
        newGroupedNTCs[groupCode] = result.newNTCs;
        insertedNTCs = [...insertedNTCs, ...result.insertedNTCs];
        delete groupedSelectedNTCs[groupCode];
      } else {
        // Else, insert NTCs at the destination index
        const result = insertValidNTCsAtDestIndexForGroupedNTCs(
          existingNTCs,
          selectedNTCs,
          parentRow,
          destIndexForGroup,
        );
        newGroupedNTCs[groupCode] = result.newNTCs;
        insertedNTCs = [...insertedNTCs, ...result.insertedNTCs];
        delete groupedSelectedNTCs[groupCode];
      }
    }
  });
  // If any unprocessed selected NTCs remain, update their properties and add them to new grouped NTCs
  if (Object.keys(groupedSelectedNTCs).length > 0) {
    newGroupedNTCs = {
      ...newGroupedNTCs,
      ...updatePropOfGroupedNTCs(groupedSelectedNTCs, [
        'offsetTime',
        'defaultGap',
      ]),
    };
    insertedNTCs = [
      ...insertedNTCs,
      ...getFlatArrForGroupedArr(groupedSelectedNTCs),
    ];
  }
  return {
    newGroupedNTCs,
    insertedNTCs,
  };
};

const insertValidNTCsAtTheEnd = (existingNTCs, selectedNTCs, parentRow) => {
  let newNTCs = [...existingNTCs];
  let insertedNTCs = [];
  selectedNTCs.forEach((ntc) => {
    let tempNTCs = [...newNTCs, ntc];
    tempNTCs = updatePropOfNTCs(tempNTCs, ['offsetTime', 'defaultGap']);
    const lastTempNtc = tempNTCs.at(-1);
    const isTempNTCsValid =
      addTimes(lastTempNtc.OffsetStartTime, lastTempNtc.Duration) <=
      parentRow.Duration;
    if (isTempNTCsValid) {
      newNTCs = [...tempNTCs];
      insertedNTCs.push(ntc);
    }
    return newNTCs;
  });
  return { newNTCs, insertedNTCs };
};

const insertValidNTCsAtDestIndexForGroupedNTCs = (
  existingNTCs,
  selectedNTCs,
  parentRow,
  destIndex,
) => {
  let newNTCs = [...existingNTCs];
  let newDestIndex = destIndex;
  let insertedNTCs = [];
  selectedNTCs.forEach((ntc) => {
    let tempNTCs = [...newNTCs];
    tempNTCs.splice(newDestIndex, 0, ntc);
    tempNTCs = updatePropOfNTCs(tempNTCs, ['offsetTime', 'defaultGap']);
    const lastTempNtc = tempNTCs.at(-1);
    const isTempNTCsValid =
      addTimes(lastTempNtc.OffsetStartTime, lastTempNtc.Duration) <=
      parentRow.Duration;
    if (isTempNTCsValid) {
      newNTCs = [...tempNTCs];
      insertedNTCs.push(ntc);
      newDestIndex++;
    }
    return newNTCs;
  });
  return { newNTCs, insertedNTCs };
};

const updatePropOfGroupedNTCs = (groupedNTC, properties) => {
  const newGroupedNTCs = {};
  Object.keys(groupedNTC).forEach((groupCode) => {
    const ntcRows = groupedNTC[groupCode];
    const newNTCs = updatePropOfNTCs(ntcRows, properties);
    newGroupedNTCs[groupCode] = newNTCs;
  });
  return newGroupedNTCs;
};

export {
  executeSecNTCDrag,
  insertValidSelNTCsInRespectiveGroups,
  executeSecToSchTableNtcInsert,
  insertNTCsBasedOnOffsetTimeAutoCalculation,
};
