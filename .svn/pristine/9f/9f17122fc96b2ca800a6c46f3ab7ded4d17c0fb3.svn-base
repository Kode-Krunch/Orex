import {
  getFlatArrForGroupedArr,
  getGroupedRows,
  getUniqueObjects,
  openNotification,
} from 'views/Controls/GLOBALFUNACTION';
import {
  getNTCParentRow,
  getRowWithNTC,
  getTableDataWithAdditionalInfo,
  removeRowsFromTableData,
} from '../../utils';
import { insertValidSelNTCsInRespectiveGroups } from '../ntcOperations/ntcDrag';
import {
  additionalRowInfoEnum,
  tableTypesEnum,
} from 'views/Scheduling/Scheduler/enum';
import { updatePropOfNTCs } from '../ntcOperations/utils';

const moveNTCsBasedOnOffsetTimeAutoCalculation = (
  selectedRows,
  tableData,
  destIndex,
  isCopyEnabled,
) => {
  // Get source parent rows for selected NTCs
  const srcParentRows = getNTCParentRowForSelectedNTCs(selectedRows, tableData);
  // Get grouped NTCs for each source parent row
  const srcParentRowsWithGroupedNTCs = getGroupedNTCsForParentRows(
    srcParentRows,
    tableData,
  );
  // Get destination NTC parent row
  const destParentRow = getNTCParentRow(destIndex, tableData);
  // Get all NTCs for destination parent row
  const destParentNTCs = getRowWithNTC([destParentRow], tableData, false);
  // Get grouped NTCs for destination parent row
  const destParentGroupedNTCs = getGroupedRows(destParentNTCs, 'NTCGroupCode');
  // Get grouped NTCs for selected NTCs
  const selectedGroupedNTCs = getGroupedRows(selectedRows, 'NTCGroupCode');
  // Move NTCs
  let result;
  if (Object.keys(srcParentRowsWithGroupedNTCs).includes(destParentRow.rowId)) {
    // If destination parent is same as one of source parent
    result = moveNTCsWithinSrcParent({
      srcParentRowsWithGroupedNTCs,
      destParentRow,
      destParentNTCs,
      destParentGroupedNTCs,
      selectedGroupedNTCs,
      selNTCs: selectedRows,
      destIndex,
      tableData,
      isCopyEnabled,
    });
  } else {
    // Else destination parent is different from source parent
    result = moveNTCsToDestParent({
      destParentNTCs,
      destParentGroupedNTCs,
      selectedGroupedNTCs,
      destIndex,
      destParentRow,
      tableData,
      srcParentRowsWithGroupedNTCs,
      isCopyEnabled,
    });
  }
  // If few NTCs are not inserted, give notification to user
  if (result.insertedNTCs.length < selectedRows.length)
    openNotification(
      'danger',
      `Some NTCs are not ${
        isCopyEnabled ? 'copied' : 'moved'
      } due to insufficient duration`,
    );
  return result;
};

const getNTCParentRowForSelectedNTCs = (selectedNTCs, tableData) => {
  let parentRows = [];
  selectedNTCs.forEach((ntc) => {
    parentRows.push(getNTCParentRow(ntc.rowIndex, tableData));
  });
  parentRows = getUniqueObjects(parentRows, 'rowId');
  return parentRows;
};

const getGroupedNTCsForParentRows = (parentRows, tableData) => {
  let parentRowsWithGroupedNTCs = {};
  parentRows.forEach((curParentRow) => {
    const curParentNTCs = getRowWithNTC([curParentRow], tableData, false);
    const curParentGroupedNTCs = getGroupedRows(curParentNTCs, 'NTCGroupCode');
    parentRowsWithGroupedNTCs[curParentRow.rowId] = curParentGroupedNTCs;
  });
  return parentRowsWithGroupedNTCs;
};

const moveNTCsWithinSrcParent = ({
  srcParentRowsWithGroupedNTCs,
  destParentRow,
  destParentNTCs,
  destParentGroupedNTCs,
  selectedGroupedNTCs,
  selNTCs,
  destIndex,
  tableData,
  isCopyEnabled,
}) => {
  // Remove selected NTCs from destination parent grouped NTCs if copy feature is not active
  let newDestParentGroupedNTCs = !isCopyEnabled
    ? removeNTCsFromParentGroupedNTCs(selNTCs, destParentGroupedNTCs)
    : destParentGroupedNTCs;
  // Insert selected NTCs in respective groups of destination parent grouped NTCs
  const { newGroupedNTCs, insertedNTCs } = insertValidSelNTCsInRespectiveGroups(
    newDestParentGroupedNTCs,
    selectedGroupedNTCs,
    destIndex,
    destParentRow,
  );
  newDestParentGroupedNTCs = newGroupedNTCs;
  // Flat the new destination parent grouped NTCs
  const newDestParentNTCs = getFlatArrForGroupedArr(newDestParentGroupedNTCs);
  let ntcsToRemove = isCopyEnabled
    ? insertedNTCs.filter((row) => row.BookingDetailID)
    : insertedNTCs;
  // Add new row id to NTCs
  let ntcsWithNewRowId = getTableDataWithAdditionalInfo({
    tableData: newDestParentNTCs,
    tableType: tableTypesEnum.SCHEDULING,
    additionalInfo: [additionalRowInfoEnum.ROW_ID],
  });
  // Move NTCs
  let newTableData = [...tableData];
  // Remove old NTCs from destination parent row
  newTableData = removeRowsFromTableData(destParentNTCs, newTableData);
  // Insert moved NTCs below destination parent row
  newTableData.splice(
    newTableData.findIndex((row) => row.rowId === destParentRow.rowId) + 1,
    0,
    ...ntcsWithNewRowId,
  );
  // Update row index of Table Data
  newTableData = getTableDataWithAdditionalInfo({
    tableData: newTableData,
    tableType: tableTypesEnum.SCHEDULING,
    additionalInfo: [additionalRowInfoEnum.ROW_INDEX],
  });
  /* Remove moved NTCs from source parent rows if source is multiple */
  if (Object.keys(srcParentRowsWithGroupedNTCs).length > 1) {
    // Remove destination parent row from source parent rows
    delete srcParentRowsWithGroupedNTCs[destParentRow.rowId];
    // Remove moved NTCs from source parent rows
    const newSrcParentRowsWithGroupedNTCs =
      removeSelNTCsFromSrcParentsGroupedNTCs(
        srcParentRowsWithGroupedNTCs,
        ntcsToRemove,
      );
    // Assign new grouped NTCs to source parent rows
    newTableData = assignGroupedNTCsToParentRows(
      newSrcParentRowsWithGroupedNTCs,
      newTableData,
    );
  }
  return { newTableData, insertedNTCs };
};

const removeNTCsFromParentGroupedNTCs = (selNTCs, groupedNTCs) => {
  const newGroupedNTCs = {};
  const selNTCsRowIds = selNTCs.map((row) => row.rowId);
  Object.keys(groupedNTCs).forEach((groupCode) => {
    let newCurGrpNTCs = [];
    let newOffsetStartTime = '00:00:00:00';
    // Remove selected NTCs from current grouped NTCs
    groupedNTCs[groupCode].forEach((row, index) => {
      if (selNTCsRowIds.includes(row.rowId)) {
        if (index === 0) {
          newOffsetStartTime = row.OffsetStartTime;
        }
      } else newCurGrpNTCs.push(row);
    });
    // Update offset start time of NTCs
    newCurGrpNTCs = updatePropOfNTCs(
      newCurGrpNTCs.map((row) => ({
        ...row,
        OffsetStartTime: newOffsetStartTime,
      })),
      ['offsetTime', 'defaultGap'],
    );
    newGroupedNTCs[groupCode] = newCurGrpNTCs;
  });
  return newGroupedNTCs;
};

const moveNTCsToDestParent = ({
  destParentNTCs,
  destParentGroupedNTCs,
  selectedGroupedNTCs,
  destIndex,
  destParentRow,
  tableData,
  srcParentRowsWithGroupedNTCs,
  isCopyEnabled,
}) => {
  // Insert selected NTCs in respective groups of destination parent grouped NTCs
  const { newGroupedNTCs, insertedNTCs } = insertValidSelNTCsInRespectiveGroups(
    destParentGroupedNTCs,
    selectedGroupedNTCs,
    destIndex,
    destParentRow,
  );
  // Flat the grouped NTCs
  const flattenedNewGroupedNTCs = getFlatArrForGroupedArr(newGroupedNTCs);
  let ntcsToRemove = isCopyEnabled
    ? insertedNTCs.filter((row) => row.BookingDetailID)
    : insertedNTCs;
  // Add new row id to NTCs
  let ntcsWithNewRowId = getTableDataWithAdditionalInfo({
    tableData: flattenedNewGroupedNTCs,
    tableType: tableTypesEnum.SCHEDULING,
    additionalInfo: [additionalRowInfoEnum.ROW_ID],
  });
  // Move NTCs
  let newTableData = [...tableData];
  // Remove old NTCs from destination parent row
  newTableData = removeRowsFromTableData(destParentNTCs, newTableData);
  // Insert moved NTCs below destination parent row
  newTableData.splice(
    newTableData.findIndex((row) => row.rowId === destParentRow.rowId) + 1,
    0,
    ...ntcsWithNewRowId,
  );
  // Update row index of Table Data
  newTableData = getTableDataWithAdditionalInfo({
    tableData: newTableData,
    tableType: tableTypesEnum.SCHEDULING,
    additionalInfo: [additionalRowInfoEnum.ROW_INDEX],
  });
  // Remove moved NTCs from source parent rows
  const newSrcParentRowsWithGroupedNTCs =
    removeSelNTCsFromSrcParentsGroupedNTCs(
      srcParentRowsWithGroupedNTCs,
      ntcsToRemove,
    );
  // Assign new grouped NTCs to source parent rows
  newTableData = assignGroupedNTCsToParentRows(
    newSrcParentRowsWithGroupedNTCs,
    newTableData,
  );
  return { newTableData, insertedNTCs };
};

const removeSelNTCsFromSrcParentsGroupedNTCs = (
  srcParentRowsWithGroupedNTCs,
  selectedRows,
) => {
  const newSrcParentRowsWithGroupedNTCs = {};
  const selectedRowIds = selectedRows.map((row) => row.rowId);
  // Iterate through each parent row in the source data
  Object.keys(srcParentRowsWithGroupedNTCs).forEach((parentRowId) => {
    const parentRowGroupedNTCs = srcParentRowsWithGroupedNTCs[parentRowId];
    let newParentRowGroupedNTCs = {};
    // Iterate through each NTC group within the parent row
    Object.keys(parentRowGroupedNTCs).forEach((groupCode) => {
      const curGrpNTCs = parentRowGroupedNTCs[groupCode];
      const startOffsetTime = curGrpNTCs[0].OffsetStartTime;
      // Remove selected NTCs from the group
      let newGrpNTCs = curGrpNTCs.filter(
        (row) => !selectedRowIds.includes(row.rowId),
      );
      // Maintain the original start offset time for the remaining NTCs
      newGrpNTCs = newGrpNTCs.map((row) => ({
        ...row,
        OffsetStartTime: startOffsetTime,
      }));
      // Update necessary properties (like offsetTime and defaultGap) for consistency
      newGrpNTCs = updatePropOfNTCs(newGrpNTCs, ['offsetTime', 'defaultGap']);
      // Store the updated NTC group back into the parent row
      newParentRowGroupedNTCs[groupCode] = newGrpNTCs;
    });
    // Store the updated parent row with its modified grouped NTCs
    newSrcParentRowsWithGroupedNTCs[parentRowId] = newParentRowGroupedNTCs;
  });
  return newSrcParentRowsWithGroupedNTCs;
};

const assignGroupedNTCsToParentRows = (
  srcParentRowsWithGroupedNTCs,
  tableData,
) => {
  let newTableData = [...tableData];
  // Remove old NTCs from its parent row and insert new NTCs below its parent row
  Object.keys(srcParentRowsWithGroupedNTCs).forEach((parentRowId) => {
    const parentRow = newTableData.find((row) => row.rowId === parentRowId);
    // Remove old NTCs from parent row
    const parentOldNTCs = getRowWithNTC([parentRow], newTableData, false);
    newTableData = removeRowsFromTableData(parentOldNTCs, newTableData);
    // Insert new NTCs below parent row
    const parentNewGroupedNTCs = srcParentRowsWithGroupedNTCs[parentRowId];
    const flattenedParentNewGroupedNTCs =
      getFlatArrForGroupedArr(parentNewGroupedNTCs);
    newTableData.splice(
      newTableData.findIndex((row) => row.rowId === parentRow.rowId) + 1,
      0,
      ...flattenedParentNewGroupedNTCs,
    );
    // Update row index of Table Data
    newTableData = getTableDataWithAdditionalInfo({
      tableData: newTableData,
      tableType: tableTypesEnum.SCHEDULING,
      additionalInfo: [additionalRowInfoEnum.ROW_INDEX],
    });
  });
  return newTableData;
};

export { moveNTCsBasedOnOffsetTimeAutoCalculation };
