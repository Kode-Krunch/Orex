const {
  featuresEnum,
  rowDataTypesEnum,
  ntcDescriptionTypesEnum,
  ntcDurationTypesEnum,
} = require('views/Scheduling/Scheduler/enum');
const {
  getCorrectedDestIndexForFilteredTable,
  getRowWithNTC,
  getNTCParentRow,
  isBasicDragValid,
  isTelTimeBetweenStartAndEndTime,
} = require('../../utils');
const {
  addTimes,
} = require('views/Scheduling/Scheduler/components/SchedulingArea/components/Summary/utils');
const { CLIENT } = require('views/Controls/clientListEnum');
const {
  openNotification,
  subtractTimes,
  getFlatArrForGroupedArr,
  getGroupedRows,
} = require('views/Controls/GLOBALFUNACTION');

const getCorrectedDestIndexForSecTableDrag = (
  dragInfo,
  secTableData,
  activeFeatures,
) => {
  const sourceIndex = dragInfo.source.index;
  const destIndex = dragInfo.destination.index;
  let destinationIndex = destIndex;
  /* DESTINATION INDEX CORRECTION IF FILTER IS ACTIVE */
  if (activeFeatures[featuresEnum.FILTER]) {
    destinationIndex = getCorrectedDestIndexForFilteredTable(
      destIndex,
      secTableData,
    );
  }
  if (sourceIndex < destinationIndex) {
    /* DESTINATION INDEX CORRECTION IF DRAG IS TOP TO BOTTOM */
    destinationIndex = destinationIndex + 1;
  }
  return destinationIndex;
};

const getCorrectedDestIndex = (destIndex, schTableData, activeFeatures) => {
  let destinationIndex = destIndex;
  /* DESTINATION INDEX CORRECTION IF FILTER IS ACTIVE */
  if (activeFeatures[featuresEnum.FILTER]) {
    destinationIndex = getCorrectedDestIndexForFilteredTable(
      destIndex,
      schTableData,
    );
  }
  return destinationIndex > 1 ? destinationIndex : 2;
};

const validateNTCs = ({
  dragInfo,
  destIndex,
  tableData,
  selectedRows,
  channel,
  isAutoCalculateOffsetTime,
  isSchTableDrag = false,
}) => {
  let validNTCs,
    isChannelForbes = channel.label === CLIENT.USA_Forbes;
  /* --------------------- GAURD CLAUSES ----------------------------- */
  // CLAUSE 1 - If operation is drag and drop, check if basic drag is valid
  if (dragInfo && !isBasicDragValid(dragInfo, destIndex)) return false;
  // CLAUSE 2 - If NTCs are placed below Commercial or Content Termination
  if (isNTCPlacedBelowComm(tableData, destIndex)) {
    openNotification('danger', 'NTC cannot be placed after Commercial');
    return false;
  }
  if (isNTCPlacedBelowCT(tableData, destIndex)) {
    openNotification(
      'danger',
      'NTC cannot be placed after Content Termination',
    );
    return false;
  }
  // CLAUSE 3 - If channel is Forbes and NTCs are placed after Live Event
  if (isChannelForbes && isNTCPlacedBelowLive(tableData, destIndex)) {
    openNotification('danger', 'NTC cannot be placed after Live Event');
    return false;
  }
  // Get valid NTCs as per different validations
  let ntcParentRow = getNTCParentRow(destIndex, tableData);
  if (isAutoCalculateOffsetTime) {
    validNTCs = getValidNTCsAsPerOffsetTimeAutoCalculation(
      ntcParentRow,
      selectedRows,
      tableData,
      isSchTableDrag,
    );
  } else {
    // Get NTCs ending within parent duration
    validNTCs = getNTCsWithinParentDuration(selectedRows, ntcParentRow);
    if (!validNTCs) {
      openNotification('danger', 'NTCs are out of parent duration');
      return false;
    } else if (validNTCs.length < selectedRows.length) {
      openNotification('danger', 'One or more NTCs are out of parent duration');
    }
    // Get NTCs that are paid and within time band
    if (selectedRows[0].BookingDetailsID)
      validNTCs = getValidPaidNTCs(validNTCs, tableData[destIndex]);
    if (!validNTCs) {
      openNotification('danger', 'NTCs are out of time band');
      return false;
    } else if (validNTCs.length < selectedRows.length) {
      openNotification('danger', 'One or more NTCs are out of time band');
    }
  }
  return validNTCs;
};

const isNTCPlacedBelowComm = (tableData, destIndex) => {
  return tableData[destIndex - 1].F_C_S_P === rowDataTypesEnum.COMMERCIAL;
};

const isNTCPlacedBelowCT = (tableData, destIndex) => {
  return (
    tableData[destIndex - 1].F_C_S_P === rowDataTypesEnum.CONTENT_TERMINATION
  );
};

const isNTCPlacedBelowLive = (tableData, destIndex) => {
  return tableData[destIndex - 1].F_C_S_P === rowDataTypesEnum.LIVE;
};

const getValidNTCsAsPerOffsetTimeAutoCalculation = (
  ntcParentRow,
  selectedRows,
  tableData,
  isSchTableDrag,
) => {
  // Get all ntcs for parent row
  const ntcs = getRowWithNTC([ntcParentRow], tableData, false);
  // Group all ntcs as per type
  let existingGroupedNTCs = getGroupedRows(ntcs, 'NtcTypeName');
  // Get new inital offset time for each group
  const newOffsetTimeForExistingNtcGroup =
    getGroupwiseNewOffsetTime(existingGroupedNTCs);
  // Group all selected ntcs as per type
  const selectedGroupedNTCs = getGroupedRows(selectedRows, 'NtcTypeName');
  // Append selected rows to each group
  const newGroupedNTCs = appendSelectedRowsToEachNTCGroup(
    selectedGroupedNTCs,
    newOffsetTimeForExistingNtcGroup,
    ntcParentRow,
    isSchTableDrag,
  );
  const validNTCs = getFlatArrForGroupedArr(newGroupedNTCs);
  if (validNTCs.length === 0) {
    openNotification('danger', 'NTCs are out of parent duration');
    return false;
  } else if (validNTCs.length < selectedRows.length) {
    openNotification('danger', 'One or more NTCs are out of parent duration');
  }
  return validNTCs;
};

const getNTCsWithinParentDuration = (selectedRows, parentRow) => {
  let validNTCs = [];
  selectedRows.forEach((row) => {
    const offsetStartTime = addTimes(parentRow.Start_Time, row.OffsetStartTime);
    const ntcEndTime = addTimes(offsetStartTime, row.Duration);
    if (ntcEndTime <= addTimes(parentRow.Start_Time, parentRow.Duration))
      validNTCs.push(row);
  });
  return validNTCs.length > 0 ? validNTCs : false;
};

const getValidPaidNTCs = (selectedRows, parentRow) => {
  try {
    let validNTCs = [];
    selectedRows.forEach((row) => {
      if (isTelTimeBetweenStartAndEndTime(parentRow, row)) validNTCs.push(row);
    });
    return validNTCs.length > 0 ? validNTCs : false;
  } catch (error) {
    throw error;
  }
};

const getGroupwiseNewOffsetTime = (groupedRows) => {
  const newOffsetTimeForNtcGroup = {};
  Object.keys(groupedRows).forEach((group) => {
    const lastRow = groupedRows[group].at(-1);
    newOffsetTimeForNtcGroup[group] = addTimes(
      lastRow.Tel_Time,
      lastRow.Duration,
    );
  });
  return newOffsetTimeForNtcGroup;
};

const appendSelectedRowsToEachNTCGroup = (
  selectedGroupedNTCs,
  newOffsetTimeForExistingNtcGroup,
  parentRow,
  isSchTableDrag,
) => {
  const newGroupedNTCs = {};
  Object.keys(selectedGroupedNTCs).forEach((selectedGroup) => {
    // Set new initial offset time for each group
    let newOffsetTime = newOffsetTimeForExistingNtcGroup[selectedGroup]
      ? newOffsetTimeForExistingNtcGroup[selectedGroup]
      : isSchTableDrag
      ? '00:00:00:00'
      : selectedGroupedNTCs[selectedGroup][0].OffsetStartTime;
    // Set new valid NTCs for each group
    selectedGroupedNTCs[selectedGroup].forEach((row) => {
      // If NTC of cur type already present and gap is also present, add gap duration to offset time
      if (
        (newOffsetTimeForExistingNtcGroup[selectedGroup] ||
          newGroupedNTCs[selectedGroup]) &&
        row.Gap
      )
        newOffsetTime = addTimes(newOffsetTime, row.Gap);
      let rowWithNewOffsetTime = { ...row, OffsetStartTime: newOffsetTime };
      delete rowWithNewOffsetTime.Gap;
      // Check if cur NTC is between parent duration
      let validNTCs = getNTCsWithinParentDuration(
        [rowWithNewOffsetTime],
        parentRow,
      );
      if (newGroupedNTCs[selectedGroup]) {
        let lastNtcOfCurGroup = newGroupedNTCs[selectedGroup].at(-1);
        // Check if cur NTC is valid paid NTC
        if (rowWithNewOffsetTime.BookingDetailsID)
          validNTCs = getValidPaidNTCs(validNTCs, lastNtcOfCurGroup);
        // If valid NTC, append to cur group
        if (validNTCs) {
          newGroupedNTCs[selectedGroup].push(rowWithNewOffsetTime);
          lastNtcOfCurGroup = newGroupedNTCs[selectedGroup].at(-1);
          newOffsetTime = addTimes(
            lastNtcOfCurGroup.OffsetStartTime,
            lastNtcOfCurGroup.Duration,
          );
        }
      } else {
        // Check if cur NTC is valid paid NTC
        if (rowWithNewOffsetTime.BookingDetailsID)
          validNTCs = getValidPaidNTCs(validNTCs, parentRow);
        // If valid NTC, add NTC in new group
        if (validNTCs) {
          newGroupedNTCs[selectedGroup] = validNTCs;
          const lastNtcOfCurGroup = newGroupedNTCs[selectedGroup].at(-1);
          newOffsetTime = addTimes(
            lastNtcOfCurGroup.OffsetStartTime,
            lastNtcOfCurGroup.Duration,
          );
        }
      }
    });
  });
  return newGroupedNTCs;
};

const addPropertiesToSelectedNTCs = (
  selectedRows,
  parentRow,
  descriptionType,
  bulkNTCInsDesc,
  durationType,
  bulkNTCInsDuration,
  bulkNTCInsOffsetTime,
) => {
  try {
    let updatedSelectedRows = selectedRows.map((curRow) => ({
      ...curRow,
      Description:
        descriptionType === ntcDescriptionTypesEnum.PARENT
          ? parentRow.Event_Name
          : descriptionType === ntcDescriptionTypesEnum.CUSTOM
          ? bulkNTCInsDesc
          : curRow.Description,
      Duration:
        durationType === ntcDurationTypesEnum.PARENT
          ? subtractTimes(parentRow.Duration, bulkNTCInsOffsetTime)
          : durationType === ntcDurationTypesEnum.CUSTOM
          ? bulkNTCInsDuration
          : curRow.Duration,
      OffsetStartTime: bulkNTCInsOffsetTime,
    }));
    return updatedSelectedRows;
  } catch (error) {
    throw error;
  }
};

const insertNTCsBelowParent = (parentIndex, tableData, selectedRows) => {
  try {
    const parentRow = tableData[parentIndex];
    let newTableData = [...tableData];
    let insertIndex = parentIndex + 1;
    selectedRows.forEach((selectedRow) => {
      // Insert NTCs that fits within the parent duration
      const ntcStartTime = addTimes(
        parentRow.Start_Time,
        selectedRow.OffsetStartTime,
      );
      const ntcEndTime = addTimes(ntcStartTime, selectedRow.Duration);
      if (ntcEndTime <= addTimes(parentRow.Start_Time, parentRow.Duration)) {
        newTableData.splice(insertIndex, 0, {
          ...selectedRow,
          Start_Time: ntcStartTime,
          Tel_Time: ntcStartTime,
        });
        insertIndex = insertIndex + 1;
      }
    });
    return newTableData;
  } catch (error) {
    throw error;
  }
};

const isNTCDragValid = (dragInfo, tableData, destIndex) => {
  let isDragValid = true;
  /* --------------------- GAURD CLAUSES ----------------------------- */
  // CLAUSE 1 - If operation is drag and drop, check if basic drag is valid
  if (dragInfo && !isBasicDragValid(dragInfo, destIndex)) isDragValid = false;
  // CLAUSE 2 - If NTCs are placed below Commercial or Content Termination
  if (isNTCPlacedBelowComm(tableData, destIndex)) {
    openNotification('danger', 'NTC cannot be placed after Commercial');
    isDragValid = false;
  }
  if (isNTCPlacedBelowCT(tableData, destIndex)) {
    openNotification(
      'danger',
      'NTC cannot be placed after Content Termination',
    );
    isDragValid = false;
  }
  return isDragValid;
};

const updatePropOfNTCs = (ntcs, properties) => {
  const newNTCs = [];
  ntcs.forEach((ntc, index) => {
    const prevNTC = newNTCs[index - 1];
    let newOffsetTime, gap;
    if (prevNTC && properties.includes('offsetTime'))
      newOffsetTime = addTimes(
        prevNTC.OffsetStartTime,
        prevNTC.Duration,
        prevNTC.DefaultGAP,
      );
    if (properties.includes('defaultGap'))
      gap = ntc.Gap ? ntc.Gap : ntc.DefaultGAP;
    if (index === 0) newNTCs.push({ ...ntc, DefaultGAP: gap });
    else {
      newNTCs.push({ ...ntc, OffsetStartTime: newOffsetTime, DefaultGAP: gap });
    }
  });
  return newNTCs;
};

const updateOffsetStartTimeOfNTCs = (tableData) => {
  const newTableData = [];
  tableData.forEach((row, index) => {
    if (index === 0) newTableData.push(row);
    else {
      const prevRow = newTableData[index - 1];
      if (prevRow.F_C_S_P !== rowDataTypesEnum.NTC) newTableData.push(row);
      else {
        if (prevRow.NTCGroupCode !== row.NTCGroupCode) newTableData.push(row);
        else {
          const newOffsetTime = addTimes(
            prevRow.OffsetStartTime,
            prevRow.Duration,
            prevRow.DefaultGAP,
          );
          newTableData.push({
            ...row,
            OffsetStartTime: newOffsetTime,
            Start_Time: newOffsetTime,
            Tel_Time: newOffsetTime,
          });
        }
      }
    }
  });
  return newTableData;
};

export {
  getCorrectedDestIndexForSecTableDrag,
  getCorrectedDestIndex,
  validateNTCs,
  addPropertiesToSelectedNTCs,
  insertNTCsBelowParent,
  isNTCDragValid,
  updatePropOfNTCs,
  updateOffsetStartTimeOfNTCs,
};
