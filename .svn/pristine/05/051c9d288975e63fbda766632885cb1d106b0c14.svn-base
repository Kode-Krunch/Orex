import React, { useEffect, useState, useCallback, useMemo, useContext } from 'react';
import { DragDropContext, Draggable, Droppable } from '@hello-pangea/dnd';
import { AdaptableCard, Container } from 'components/shared';
import {
  Avatar,
  Button,
  Card,
  Dialog,
  Drawer,
  Input,
  Radio,
  Switcher,
  Table,
  Tabs,
  Tooltip,
} from 'components/ui';
import { HiOutlineExclamationCircle, HiOutlineUser } from 'react-icons/hi';
import { RiDraggable } from 'react-icons/ri';
import { TbSettings } from 'react-icons/tb';
import { getRandomColorClass } from 'views/Billing/BillGeneration/dtat';
import {
  apiGetsmartshufflesetting,
  apiPostsmartshufflesetting,
  apiPutsmartshufflesetting,
} from 'services/SchedulingService';
import { useSelector } from 'react-redux';
import {
  formatOnHHMMSSFFBlur,
  handleChangeWithFrameNew,
  openNotification,
} from 'views/Controls/GLOBALFUNACTION';
import { convertDateToYMD, isNumbers } from 'components/validators';
import Loader from 'views/Controls/Loader';
import TabList from 'components/ui/Tabs/TabList';
import TabNav from 'components/ui/Tabs/TabNav';
import { apiGetbrandmaster } from 'services/ProgrammingService';
import { apiCallstoreprocedure } from 'services/CommonService';
import SchedulerContext from 'views/Scheduling/Scheduler/context/SchedulerContext';
import { operationTypesEnum } from 'views/Scheduling/Scheduler/enum';
import { apiGetagencymasterDrop } from 'services/CreditcontrolService';

const { Tr, Th, Td, THead, TBody } = Table;

const getListStyle = (isDraggingOver) => ({
  background: isDraggingOver ? 'transparent' : 'transparent',
});

const getItemStyle = (isDragging, draggableStyle) => ({
  userSelect: 'none',
  margin: '0 0 5px 0',
  background: isDragging ? 'transparent' : 'transparent',
  display: isDragging ? 'flex' : null,
  ...draggableStyle,
});


const SmartShuffleDrawer = ({ verticalOpen, onDrawerClose, }) => {
  /* CONTEXT */
  const {
    date,
    showLoader,
    setShowLoader,
    executeOperation
  } = useContext(SchedulerContext);

  const ChannelSetting = useSelector(
    (state) => state.auth.session.ChannelSetting,
  );
  const Channel = useSelector((state) => state.locale.selectedChannel);
  const [currentStep, setCurrentStep] = useState('0');
  const [storeApiData, setStoreApiData] = useState({});
  const [isConfirmDialog, setIsConfirmDialog] = useState(false);

  const [inputs, setInputs] = useState({
    SpotSequence: 2,
    SpotRate: 0,
    Timeband: 0,
  });
  const [brandsList, setBrandsList] = useState([]);
  const [agencyList, setAgencyList] = useState([]);

  const formatAgencysandBrand = useCallback((items) => {
    return items.map((item, index) => ({
      Code: item.Code,
      Name: item.Name,
      colorClass: getRandomColorClass(),
      back2back: item?.back2back === 1,
      multi: item?.multi === 1,
      sequence: item?.sequence || index + 1,
    }));
  }, []);

  useEffect(() => {
    const fetchSmartShuffleSetting = async () => {
      try {
        setShowLoader(true);
        const params = {
          LocationCode: Channel.LocationCode,
          ChannelCode: Channel.ChannelCode,
        };
        const response = await apiGetsmartshufflesetting(params);

        if (response.data[0]) {
          const data = response.data[0];

          setStoreApiData(data);
          setInputs({
            SmartshufflesettingCode: data.SmartshufflesettingCode,
            MultiSpots: data.MultiSpots === 1,
            MakeGoodPriority: data.MakeGoodPriority === 1,
            BreakDuration: data.BreakDuration,
            BonusRatio: data.BonusRatio,
            SpotRate: data.SpotRate,
            Timeband: data.Timeband,
            SpotSequence: data.SpotSequence,
            Isbarkrating: data.Isbarkrating === 1,
            hour_allocation: data.hour_allocation == "1",
          });

          // Fetch brand/agency lists based on SpotSequence
          if (data.SpotSequence === 2) {
            fetchAgencyList([]); // Fetch agency list from API
            fetchBrandList(data.details);
          } else if (data.SpotSequence === 1) {
            fetchBrandList([]);
            fetchAgencyList(data.details);
          } else {
            fetchBrandsAndAgencies();
          }
        }
      } catch (error) {
        console.error("Failed to fetch Smart Shuffle Setting:", error);
      } finally {
        setShowLoader(false);
      }
    };

    fetchSmartShuffleSetting();
  }, [Channel]);


  const mergeUniqueEntries = (existingArray, newData, codeKey, nameKey) => {
    const existingCodes = new Set(existingArray.map((item) => item.Code));
    const updatedExistingArray = existingArray.map((item) => ({
      ...item,
      colorClass: item.colorClass || getRandomColorClass(),
    }));
    return [
      ...updatedExistingArray,
      ...newData
        .filter((item) => !existingCodes.has(item[codeKey]))
        .map((item, index) => ({
          Code: item[codeKey],
          Name: item[nameKey],
          back2back: 0,
          colorClass: getRandomColorClass(),
          multi: 0,
          sequence: updatedExistingArray.length + index + 1,
        })),
    ];
  };


  const fetchBrandList = async (array) => {
    try {
      const brandResponse = await apiGetbrandmaster();
      const newBrandList = array.length > 0
        ? mergeUniqueEntries(array, brandResponse.data, "BrandCode", "BrandName")
        : formatAgencysandBrand(
          brandResponse.data.map(({ BrandName, BrandCode }) => ({
            Name: BrandName,
            Code: BrandCode,
          }))
        );
      setBrandsList(newBrandList);
    } catch (error) {
      console.error("Error fetching brand list:", error);
    }
  };

  const fetchAgencyList = async (array) => {
    try {
      const agencyResponse = await apiGetagencymasterDrop();
      const newAgencyList = array.length > 0
        ? mergeUniqueEntries(array, agencyResponse.data, "AgencyCode", "AgencyName")
        : formatAgencysandBrand(
          agencyResponse.data.map(({ AgencyName, AgencyCode }) => ({
            Name: AgencyName,
            Code: AgencyCode,
          }))
        );

      setAgencyList(newAgencyList);
    } catch (error) {
      console.error("Error fetching agency list:", error);
    }
  };

  const fetchBrandsAndAgencies = async () => {
    try {
      const [brandResponse, agencyResponse] = await Promise.all([
        apiGetbrandmaster(),
        apiGetagencymasterDrop(),
      ]);

      setBrandsList(
        formatAgencysandBrand(
          brandResponse.data.map(({ BrandName, BrandCode }) => ({
            Name: BrandName,
            Code: BrandCode,
          }))
        )
      );

      setAgencyList(
        formatAgencysandBrand(
          agencyResponse.data.map(({ AgencyName, AgencyCode }) => ({
            Name: AgencyName,
            Code: AgencyCode,
          }))
        )
      );
    } catch (error) {
      console.error("Error fetching brands or agencies:", error);
    }
  };


  const handleInputChange = (field, value) => {

    setInputs((prev) => ({ ...prev, [field]: value }));
  };
  const handleBlur = (event) => {
    const { name, value } = event.target;
    const formattedValue = (value, Number(ChannelSetting[0]?.FramePerSec || 24));
    setInputs((prevFormState) => ({
      ...prevFormState,
      [name]: formattedValue,
    }));
  };
  const handleToggle = (field) => {
    setInputs((prev) => ({ ...prev, [field]: !prev[field] }));
  };

  const handleSwitchChange = (index, field) => {
    setBrandsList((prev) =>
      prev.map((item, i) =>
        i === index
          ? {
            ...item,
            [field]: !item[field],
            ...(field === "back2back" && !item[field] ? { multi: true } : {}), // If back2back is checked, set multi to true
          }
          : item
      )
    );
  };

  const handleSwitchChangeAgency = (index, field) => {
    setAgencyList((prev) =>
      prev.map((item, i) =>
        i === index
          ? {
            ...item,
            [field]: !item[field],
            ...(field === "back2back" && !item[field] ? { multi: true } : {}), // If back2back is checked, set multi to true
          }
          : item
      )
    );
  };

  const saveData = async () => {
    setShowLoader(true);

    const ParamsData = {
      request: {
        ...inputs,
        Isbarkrating: inputs.Isbarkrating ? 1 : 0,
        MultiSpots: inputs.MultiSpots ? 1 : 0,
        MakeGoodPriority: inputs.MakeGoodPriority ? 1 : 0,
        LocationCode: Channel.LocationCode,
        ChannelCode: Channel.ChannelCode,
        IsActive: 1,
        BreakDuration: inputs.BreakDuration,
        BonusRatio: inputs.BonusRatio,
        SpotRate: inputs.SpotRate,
        Timeband: inputs.Timeband,
        SpotSequence: inputs.SpotSequence,
        hour_allocation: inputs.hour_allocation ? '1' : '0',

      },

      details: inputs.SpotSequence == 0 ? [] : inputs.SpotSequence == 1 ? agencyList.map((item, key) => ({ ...item, back2back: item.back2back ? 1 : 0, multi: item.multi ? 1 : 0, sequence: key + 1 })) : brandsList.map((item, key) => ({ ...item, back2back: item.back2back ? 1 : 0, multi: item.multi ? 1 : 0, sequence: key + 1 })),
    };
    try {
      const response = inputs.SmartshufflesettingCode
        ? await apiPutsmartshufflesetting(
          ParamsData,
          inputs.SmartshufflesettingCode,
        )
        : await apiPostsmartshufflesetting(ParamsData);

      if (response.status === 200) {
        onDrawerClose();
      }
    } catch (error) {
      console.error('Failed to save data:', error);
    } finally {
      setShowLoader(false);
    }
  };

  const onDragEndBrand = (result) => {
    if (!result.destination) return;

    const reorderedList = Array.from(brandsList);
    const [moved] = reorderedList.splice(result.source.index, 1);
    reorderedList.splice(result.destination.index, 0, moved);

    setBrandsList(reorderedList);
  };
  const onDragEndAgency = (result) => {
    if (!result.destination) return;

    const reorderedList = Array.from(agencyList);
    const [moved] = reorderedList.splice(result.source.index, 1);
    reorderedList.splice(result.destination.index, 0, moved);

    setAgencyList(reorderedList);
  };
  const Footer = (
    <div className="text-right w-full">
      <Button size="sm" className="mr-2" onClick={onDrawerClose}>
        Cancel
      </Button>

      <Button size="sm" variant="twoTone" onClick={saveData} className="mr-2">
        Save
      </Button>
      <Button size="sm" variant="solid" onClick={() => setIsConfirmDialog(true)}>
        Smart Shuffle
      </Button>
    </div>
  );
  return (
    <>
      <Loader showLoader={showLoader} />
      <Drawer
        title="Auto Smart Shuffle"
        isOpen={verticalOpen}
        placement="right"
        footer={Footer}
        width={800}
        onClose={onDrawerClose}
      >
        <Container className="h-full">
          <div className="grid grid-cols-6 gap-4 ">
            <div className="col-span-6">
              <Tabs
                value={currentStep}
                onChange={(val) => setCurrentStep(val)}
              >
                <TabList>
                  <TabNav value={'0'} icon={<TbSettings />}>
                    Settings
                  </TabNav>
                  <TabNav value={'1'} icon={<TbSettings />}>
                    Spot Sequence
                  </TabNav>

                </TabList>
              </Tabs>
            </div>
          </div>
          {currentStep === '0' && (
            <Card
              className="col-span-6 mt-4"
            >
              <div className="flex justify-between grid grid-cols-6 gap-3 pb-2 ">
                <div className=" col-span-2" >
                  <div >
                    <label>Per Break</label>
                    <Input
                      className="w-50 "
                      size="sm"
                      name="BreakDuration"
                      maxLength="12"
                      value={inputs.BreakDuration}
                      disabled={inputs.hour_allocation}
                      onChange={(e) =>
                        handleChangeWithFrameNew(e, setInputs, Number(ChannelSetting[0]?.FramePerSec || 24))
                      }
                      onBlur={handleBlur}
                    />
                  </div>

                </div>
                <div className=" col-span-1">
                  <label>Bonus Ratio</label>
                  <Input
                    className="w-28"
                    size="sm"
                    prefix="%"
                    maxLength="3"
                    suffix={
                      <Tooltip title="Between 100%">
                        <HiOutlineExclamationCircle className="text-lg cursor-pointer ml-1" />
                      </Tooltip>
                    }
                    value={inputs.BonusRatio}
                    onChange={(e) => {
                      if (isNumbers(e.target.value)) {
                        handleInputChange('BonusRatio', e.target.value);
                      }
                    }}
                  />
                </div>
                <div className="col-span-3">
                  <Switcher
                    checked={inputs.hour_allocation}
                    className="mt-1 mr-2"
                    onChange={(e) => {
                      handleToggle('hour_allocation');
                      if (!inputs.hour_allocation) {
                        setInputs((prev) => ({ ...prev, 'BreakDuration': '' }));
                      }
                    }}
                  />
                  <div>
                    <h6 className="!font-medium !text-sm">Hourly Allocation</h6>
                    <p>Multiple One program for better reach and revenue.</p>
                  </div>
                </div>
              </div>
              <div className='grid grid-cols-3 gap-2 pb-4 pt-2'  >
                <AdaptableCard bodyClass="p-3" className="w-[200px]  col-1">
                  <h6>Timeband</h6>
                  <Radio.Group
                    vertical
                    value={inputs.Timeband}
                    onChange={(val) => handleInputChange('Timeband', val)}
                  >
                    <Radio value={0}>No Preference</Radio>
                    <Radio value={1}>Short Timeband</Radio>
                    <Radio value={2}>Long Timeband</Radio>
                  </Radio.Group>
                </AdaptableCard>
                {/* {inputs.Timeband} */}
                <div>
                  <Card bodyClass="p-3">
                    <h6>SpotRate</h6>
                    <Radio.Group
                      vertical
                      value={inputs.SpotRate}
                      onChange={(val) => handleInputChange('SpotRate', val)}
                    >
                      <Radio value={0}>No Preference</Radio>
                      <Radio value={1}>Low To High</Radio>
                      <Radio value={2}>High To Low</Radio>

                    </Radio.Group>
                  </Card>
                </div>


              </div>
              <div className="flex justify-between mb-4">
                <div>
                  <div className="flex mb-3">
                    <Switcher
                      checked={inputs.MultiSpots}
                      className="mt-1 mr-2"
                      onChange={() => handleToggle('MultiSpots')}
                    />
                    <div>
                      <h6 className="!font-medium !text-sm">Multi Spots</h6>
                      <p>Multiple One program for better reach and revenue.</p>
                    </div>
                  </div>
                  <div className="flex mb-3">
                    <Switcher
                      checked={inputs.MakeGoodPriority}
                      className="mt-1 mr-2"
                      onChange={() => handleToggle('MakeGoodPriority')}
                    />
                    <div>
                      <h6 className="!font-medium !text-sm">
                        MakeGood Priority
                      </h6>
                      <p>
                        Set Priority spots if their original spots fail to air.
                      </p>
                    </div>
                  </div>
                  <div className="flex mb-3">
                    <Switcher
                      checked={inputs.Isbarkrating}
                      className="mt-1 mr-2"
                      onChange={() => handleToggle('Isbarkrating')}
                    />
                    <div>
                      <h6 className="!font-medium !text-sm">As Per BARC Rating</h6>
                      <p>Multiple One program for better reach and revenue.</p>
                    </div>
                  </div>
                </div>{' '}


              </div>
            </Card>
          )}
          {currentStep === '1' && (
            <AdaptableCard
              className="h-full col-span-6 grow overflow-y-auto mt-4"
              bodyClass="h-full grow overflow-y-auto"
            >
              <Card bodyClass="p-2 " className='mb-2'>
                <h6 className='mb-2'>Spot Sequence</h6>
                <Radio.Group
                  value={inputs.SpotSequence}
                  onChange={(val) => handleInputChange('SpotSequence', val)}
                >
                  <Radio value={0}>No Preference</Radio>
                  <Radio value={1}>Agency Wise</Radio>
                  <Radio value={2}>Brand Wise</Radio>
                </Radio.Group>
              </Card>
              {inputs.SpotSequence == 2 && <DragDropContext onDragEnd={onDragEndBrand}>
                <Droppable droppableId="brandsList">
                  {(provided, snapshot) => (
                    <div
                      {...provided.droppableProps}
                      ref={provided.innerRef}
                      style={getListStyle(snapshot.isDraggingOver)}
                    >
                      <Table compact borderlessRow={false}>
                        <THead>
                          <Tr>
                            <Th>Brand</Th>
                            <Th>Is Back 2 Back</Th>
                            <Th>Is MultiBrand</Th>
                          </Tr>
                        </THead>
                        <TBody>
                          {brandsList.map((item, index) => (
                            <Draggable
                              key={`${item?.Code}`}
                              draggableId={`${item?.Code}`}
                              index={index}
                            >
                              {(provided, snapshot) => (
                                <Tr
                                  ref={provided.innerRef}
                                  {...provided.draggableProps}
                                  {...provided.dragHandleProps}
                                  style={getItemStyle(
                                    snapshot.isDragging,
                                    provided.draggableProps.style,
                                  )}
                                >
                                  <Td className="flex items-center">
                                    <RiDraggable
                                      size={20}
                                      className="mr-1"
                                    />
                                    <Avatar
                                      size="sm"
                                      shape="circle"
                                      className={`mr-3 dark:${item.colorClass} ${item.colorClass}`}
                                    >
                                      <p className="text-base dark:text-gray-200 text-gray-800">
                                        {item?.Name && item?.Name.slice(0, 1)}
                                      </p>
                                    </Avatar>
                                    <div>
                                      <p className="text-base font-semibold dark:text-gray-200 text-gray-800 capitalize">
                                        {item?.Name}
                                      </p>{' '}
                                      <p className="text-xs dark:text-gray-400 text-gray-400">
                                        {item?.Name}
                                      </p>
                                    </div>
                                  </Td>
                                  <Td>
                                    <Switcher
                                      checked={item?.back2back}
                                      onChange={() =>
                                        handleSwitchChange(
                                          index,
                                          'back2back',
                                        )
                                      }
                                    />
                                  </Td>
                                  <Td>
                                    <Switcher
                                      checked={item?.multi}
                                      onChange={() =>
                                        handleSwitchChange(
                                          index,
                                          'multi',
                                        )
                                      }
                                    />
                                  </Td>
                                </Tr>
                              )}
                            </Draggable>
                          ))}
                          {provided.placeholder}
                        </TBody>
                      </Table>
                    </div>
                  )}
                </Droppable>
              </DragDropContext>}
              {inputs.SpotSequence == 1 && <DragDropContext onDragEnd={onDragEndAgency}>
                <Droppable droppableId="agencyList">
                  {(provided, snapshot) => (
                    <div
                      {...provided.droppableProps}
                      ref={provided.innerRef}
                      style={getListStyle(snapshot.isDraggingOver)}
                    >
                      <Table compact borderlessRow={false}>
                        <THead>
                          <Tr>
                            <Th>Agency</Th>
                            <Th>Is Back 2 Back</Th>
                            <Th>Is Multi Agency</Th>
                          </Tr>
                        </THead>
                        <TBody>
                          {agencyList.map((item, index) => (
                            <Draggable
                              key={`${item?.Code}`}
                              draggableId={`${item?.Code}`}
                              index={index}
                            >
                              {(provided, snapshot) => (
                                <Tr
                                  ref={provided.innerRef}
                                  {...provided.draggableProps}
                                  {...provided.dragHandleProps}
                                  style={getItemStyle(
                                    snapshot.isDragging,
                                    provided.draggableProps.style,
                                  )}
                                >
                                  <Td className="flex items-center">
                                    <RiDraggable
                                      size={20}
                                      className="mr-1"
                                    />
                                    <Avatar
                                      size="sm"
                                      shape="circle"
                                      className={`mr-3 dark:${item.colorClass} ${item.colorClass}`}
                                    >
                                      <p className="text-base dark:text-gray-200 text-gray-800">
                                        {item?.Name?.slice(0, 1)}
                                      </p>
                                    </Avatar>
                                    <div>
                                      <p className="text-base font-semibold dark:text-gray-200 text-gray-800 capitalize">
                                        {item?.Name}
                                      </p>{' '}
                                      <p className="text-xs dark:text-gray-400 text-gray-400">
                                        {item?.Name}
                                      </p>
                                    </div>
                                  </Td>
                                  <Td>
                                    <Switcher
                                      checked={item.back2back}
                                      onChange={() =>
                                        handleSwitchChangeAgency(
                                          index,
                                          'back2back',
                                        )
                                      }
                                    />
                                  </Td>
                                  <Td>
                                    <Switcher
                                      checked={item?.multi}
                                      onChange={() =>
                                        handleSwitchChangeAgency(
                                          index,
                                          'multi',
                                        )
                                      }
                                    />
                                  </Td>
                                </Tr>
                              )}
                            </Draggable>
                          ))}
                          {provided.placeholder}
                        </TBody>
                      </Table>
                    </div>
                  )}
                </Droppable>
              </DragDropContext>}
            </AdaptableCard>)}


        </Container>
      </Drawer>
      <Dialog
        isOpen={isConfirmDialog}
        onClose={() => setIsConfirmDialog(false)}
        onRequestClose={() => setIsConfirmDialog(false)}
      >
        <h5 className="mb-4">Confirm Smart Shuffle</h5>
        <p>
          Are you sure you want to do Smart Shuffle
        </p>
        <div className="text-right mt-6">
          <Button
            className="ltr:mr-2 rtl:ml-2"
            variant="plain"
            onClick={() => setIsConfirmDialog(false)}
          >
            Cancel
          </Button>
          <Button variant="solid" onClick={async () => {
            try {
              setShowLoader(true);
              const Resp = await apiCallstoreprocedure('CloudBATS_AutoShuffle', {
                LocationCode: Channel.LocationCode,
                ChannelCode: Channel.ChannelCode,
                ScheduleDate: convertDateToYMD(date)
              })
              if (Resp.status === 200) {
                try {
                  await executeOperation({
                    operation: operationTypesEnum.INITIALIZE_SCHEDULER,
                    isFirstLoad: true,
                  });
                  openNotification('success', 'Smart Shuffle has been successfully completed');
                } catch (error) {
                  openNotification(
                    'danger',
                    'Smart Shuffle is failed to refresh the schedule',
                  );
                }

              }
            } catch (error) {
              openNotification(
                'danger',
                'Please Save Settings before Smart Shuffle.!',
              );
            } finally {
              setShowLoader(false);
              setIsConfirmDialog(false)
            }

          }}>
            Okay
          </Button>
        </div>
      </Dialog>
    </>
  );
};

export default SmartShuffleDrawer;
